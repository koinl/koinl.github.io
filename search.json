[{"title":"第 4 章  抽样推断","date":"2022-09-22T03:09:36.888Z","url":"/posts/as04/","categories":[["Applied Statistics","/categories/Applied-Statistics/"]],"content":"简单随机抽样标志值条件下的计算步骤现从参加测试的 1000 名考生中随机重复抽取 10% 的成绩进行排查，所得有分布数列： 成绩&#x2F;分 0-60 60-70 70-80 80-90 90-100 人数&#x2F;人 10 20 22 40 8 以 95.45% 的置信度求 1000 名考生的考试平均成绩的估计区间。 成数条件下的计算步骤依旧是上表，现以 95.45% 的置信度求成绩在 80 分以上的考生的考试平均成绩的估计区间。 类型抽样标志值条件下的计算步骤某地有 4000 公顷地，现划分 3 个区域：A、B、C。从 4000 公顷中按 10% 抽样，有表： 地 总体&#x2F;公顷 样本&#x2F;公顷 平均公顷产量&#x2F;kg 公顷产量方差 样本中的高产地块公顷数 A 1000 100 1000 50 20 B 1500 150 1200 60 80 C 1500 150 1100 80 60 以 95.45% 的置信度求 4000 公顷地平均公顷产量的估计区间。 成数条件下的计算步骤依旧是上表，现以 99.73% 的置信度求 4000 公顷地中的高产地块所占比重的估计区间。 整群抽样标志值条件下的计算步骤抽取某公司的 3个车间，调查各车间内部所有工人月平均生产量，得表： 车间号 工人数&#x2F;人 月平均生产量&#x2F;件 1 30 20 2 60 35 3 80 40 以 95.45% 的置信度求该公司所有车间全部工人月平均生产量的估计区间。 成数条件下的计算步骤"},{"title":"第三章  MapReduce基础","date":"2022-09-07T04:21:59.916Z","url":"/posts/hadoop03/","categories":[["Hadoop","/categories/Hadoop/"]],"content":"本章首先介绍了 MapReduce 的基础知识和工作流程，然后通过单词统计和二次排序两个案例介绍了如何利用 MapReduce 进行编程。Hadoop 支持多种语言但对 Java 支持最好，在编写 MapReduce 函数时，需要新建 3 个类：Mapper 类、Reducer 类、main 类。另外，前两个类也可以作为内部类放到 main 类中。Mapper 类需要集成 MapRecude API 所提供的Mapper 类并重写 map() 方法，Reduce() 类同理。 一、MapReduce 概述MapReduce 是 Hadoop 系统中最重要的计算引擎，它不仅直接支持交互式应用，基于程序的应该，还是 Hive 组件的基础。 1. 分布式并行计算1) 分布式计算一个任务，拆分成无数个小任务，将这些小任务派发给多台计算机进行计算，最后将结构进行汇总以得到最终的结果。 分解后的任务直接相互独立，计算结果几乎互不影响，对实时性要求不高。 2) 并行计算允许让多条指令以平行方式同时进行计算的模式，包括时间与空间并行两种方式。 时间并行：多条流水线同时作业空间并行：使用多种计算资源（如多个处理器）执行并发计算。 2. MapReduce 的含义针对大规模集群种的分布式文件即下并行处理的计算模型。 MapReduce 主要将数据处理任务拆分为 M（映射）和 Reduce（规约）两个任务。例如，要统计一个班的数学成绩，数学老师让数学课代表统计它所在班的数学成绩。数学课代表就让每一组的组长统计它们组的数学成绩，相当于 Map 任务，而数学课代表统计处理每个组所报上来的数学成绩，就是 Reduce 任务。由此可以看出，MapReduce 充分体现了 “分而治之”的思想：把一个复杂的任务拆分成小的任务并行处理，从而提高任务的处理速度。 3. MapReduce 的特点开发简单易于实现；良好的可扩展性：动态增加节点的方式；高容错性：如果集群中某计算节点出现故障，使得作业执行失败，MapReduce 可自动将作业分配到可用的计算节点上重新执行。 计算局限（不适合数据事务处理或单一请求处理）性能局限应用局限 二、MapReduce 的工作流程输入分片和数据格式化，Map过程，Shuffle 过程，Reduce 过程，结果输出 1. 输入分片和数据格式化首先，MapReduce 将存储在 HDFS 中的大规模数据集切分成独立的输入分片，每一个输入分片对应一个 Map 任务。输入分片是一个逻辑概念，因此对输入数据集的切分也是一种逻辑切分。 此外，由于 Map 任务的输入要i去是键值对的形式，所以需要对输入分片进行格式化，即对输入处理成 &lt;key, balue&gt; 形式的数据，然后再传递给 Map 任务。 2. Map 过程利用 Map() 函数来处理数据 3. Shuffle 过程通常，Map() 后的输出需要进行一系列处理才交给 Reduce() 任务，这一系列处理过程被称作洗牌（Shuffle）过程。 这一系列包括有“分区”、“排序”、“合并”、“滥写”、“归并”等。 4. Reduce 过程Reduce() 任务接收归并排序后的数据流，并对已有序的相同 key 的键值对调用一次 Reduce() 函数。另外，Reduce() 任务的输出结果经过输出格式化后再输出到文件系统中，并且输出结果文件名默认为“part-r-00000”开始，逐渐递增。 三、案例解析——单词统计编程1. 案例描述假设在 hdfs://hadoop0:9000/jqe/wc/data 中存在两个文本文件（文件中仅有字符串和空格），分别是 words1.txt 和 words2.txt。其中，word1.txt内容如下： word2.txt内容如下： 要求 计算这两个文件的单词频数，输出结果 按照单词的字母顺序进行排序，并输出到 两个文件中（以字母 g 分隔开来）。另外，还要对输出数据进行格式化：单词和词频之间以~~~~~隔开。 2. 设计思路根据分析，单词统计程序可分为 7 个模块，分别是输入、输入分片及其格式化、设计 map() 函数、分区、设计 reduce() 函数、输出格式化、输出。 指定输入文件位置； 将两个文件切分成两个输入分片，对输入分片进行格式化，如文件按行分解，从而形成以 key 为偏移量、value 为行内容的键值对； 设计 map() 函数，将键值对的 value 按空格分解成一个个单词，生成 &lt;word, l&gt;形式的键值对。 设计分区函数，将 key 的首字母小于 g 的键值对划分为 1 个分区，其余的划分在另一个分区。 设计 reduce() 函数，将输入的 &lt;word, list(value)&gt; 形式（如 &lt;”ls”,{1, 1}&gt;）的数据进行汇总，生成以 key 为单词、value 为单词频数的键值对。 系统默认的输出格式为“单词+空格+单词频数”的形式，若要输出特定样式的数据，需要对输出结果进行格式化，使得单词与但磁盘技能书之间以“~~~~~”间隔。 指定单词统计程序的输出结果文件位置。 3. 编程实现4. 运行程序四、案例解析——二次排序编程"},{"title":"第二章  磁盘I/O操作","date":"2022-09-07T04:20:56.899Z","url":"/posts/hadoop02/","categories":[["Hadoop","/categories/Hadoop/"]],"content":"在系统中，当需要处理的数据非常大时，数据出现损坏的可能性会大很多。因此需要进行数据完整性检查；Hadoop 采用 RPC 来实现进程间的通信，采用的是 Writable 序列化机制。序列化有两个目的：进程间通信与数据持久性存储。在传输之前，可以对文件先进行压缩，这样做有两大好处，这俩好处也对于处理大量数据十分重要：减少存储空间与加速数据在网络和磁盘上的传输。对于某些应用，往往需要一种特殊的数据结构来存储数据，所以 Hadoop 为此开发了更高层次的容器：SequenceFile 和 Mapfile. 一、数据完整性一般情况下，可用通过验证校验和的方式来检查数据的完整性。 校验和（checksum）是指再数据处理和数据通信领域用于校验一组终端数据项的和。数据在传输之前会生成一个校验和，当传输过去后会再次计算校验和，若不一致，则判定数据已损坏。另外，文件系统重启时也会计算校验和。 1. HDFS 的数据完整性除了在写入和读取时会计算验证校验和来验证数据的完整性外，HDFS 还会定期计算 block 的校验和以验证数据完整性。 1) 向 HDFS 中写入数据时的验证Client 向 HDFS 发送写入请求，最后一个接收 block 副本的 DataNode 会计算校验和，并与 Client 发送的校验和进行比较，相同存入并返回信息，错误就会给 Client 抛出一个 IOException 错误。此外，DataNode 复制其他数据节点的数据时，也会通过比较校验和的方式对数据进行验证。 2) 从 HDFS 中读取数据时的验证每个数据节点都会将每次验证后的校验和与校验和的更新时间持久保存到某个日志中。Client 从数据节点读取数据时，会将数据放置在 Client 的缓存中，然后重新计算校验和并于数据节点所存储的最新校验和进行比较。 3) DataNode 后台守护进程定期检测解决的是物理存储媒介损坏的问题，每个数据节点都会在后台运行一个 DataBlockScanner 进程，该进程定期检查数据节点上的块，以便在 Client 读取损坏的块前将其及时检测并修复。此外，当发现某块副本的校验和和日志中的数据不一致，数据节点就会将其标注为已损坏。当数据节点向元数据节点发送心跳时，元数据节点就会让数据节点处理损坏的数据块。 2. 验证数据完整性为了验证，用户可用去编写程序调用客户端校验类和校验和文件系统类。 1) 客户端校验（LocalFileSystem）类例如，当调用该类来写入一个“a.txt”的文件时，文件系统会自动创建一个“.a.txt.crc”的隐藏文件。 2) 校验和文件系统（ChecksumFileSystem）类二、序列化与反序列化Java 序列化会将 Java 对象转换为字节序列的过程，Java 反序列化是将字节序列恢复到 Java 对象的过程。例如，将 Java 图片对象序列化，通过网络进行传输，最后将其反序列化以获得需要的对象。 1. 序列化简单来讲，序列化就是将对象转化为便于传输的格式，例如二进制、字节数组、json、xml等。Hadoop 使用的时 Writable。 1) Writable 接口Writable 接口针对 DataOutput 和 DataInput 定义了两个方法：write() 和 readFields() 。分别实现对数据的序列化和反序列化。 2) Writable 类3) 自定义 Writable 类有时候，还是需要自己构建新类滴，因此，实现自定义的 Writable 也是十分有必要滴，下方代码构建了一个 ListWritable 类（Writable 集合类中没有提供），用于实现 Writable 接口从而达到 List 集合的效果。 2. 反序列化简单来讲，是对应的，是序列化的逆过程。 三、数据压缩Hadoop 的数据量过大，有必要对文件进行压缩，减少文件存储所使用的存储空间，也可以加快数据在网络和磁盘上的传输速度。 1. 压缩与解压缩方法 Codec1) CompressionCodec 接口CompressionCodec 接口定义了数据的压缩和解压缩方法，分别是 createOutputStream() 和 createInputStream()。使用 createOutputStream() 方法，可以对未压缩的数据新建一个 CompressionOutputStream 对象，对输出流的数据进行压缩。使用 createInputStream() 方法，可以对输入流读取的数据进行解压缩，解压缩的数据新构建一个 CompressionInputStream 对象。 在 Eclipse 中运行 Compressor() 测试方法，可以在本地系统的指定位置（如“E:&#x2F;data”）生成一个压缩文件（如“c.txt.gz”）；运行 UnCompressor() 测试方法，下方的“Console”窗口中会输出将压缩文件解压缩后所得的文件内容。 2) CompressionCodecFactory 类当读取一个压缩文件时，CompressionCodecFactory 类可以根据文件扩展名来推断使用哪个 Codec 算法。 利用 CompressionCodecFactory 提供的 getCodec() 方法，可以接收一个 Path 对象，并将文件扩展名映射到相应的 Codec 方法中。在 Eclipse 中运行 FileDecompressor() 测试方法，可以在与压缩文件（即 hdfs:&#x2F;&#x2F;hadoop00:9000&#x2F;mywork&#x2F;test&#x2F;c.txt.gz）相同的目录下得到一个解压缩后的文件。 2. 压缩与输入分片Hadoop 的数据量过大，压缩后是否支持切分也是很有必要的。例如，一个 2GB 的文件切分成 16 个块（默认每个块128MB），如果该文件作为 MapReduce 的作业输入，将会创建 16 个分片，每个分片启动一个 Map任务单独处理分片数据。 假设压缩后的文件大小为 1.6GB，那么块个数就会降低到 13 个，此时 Map 任务也会减少，由此可用提高作业效率。当然压缩格式需要支持切分功能（如 bzip2），对于不支持切分的，emmm。 四、Hadoop 文件的数据结构其中，SequenceFile 和 MapFile 较典型，MapFile 类型文件是排序后带有索引的 SequenceFile 文件。 1. SequemceFile是序列化后的二进制文件，以键值对的方式记录数据。 在 Eclipse 中运行 SequemceFileWriteDemo() 测试方法，可以将数据写入到 SequemceFile 文件（即 hdfs:&#x2F;&#x2F;hadoop00:9000&#x2F;mywork&#x2F;test&#x2F;sequencedemo.seq）。 在 虚拟机中，通过执行下行命令可以查看该文件内容：hdfs dfs -text /mywork/test/sequencedemo.seq 在 Eclipse 中运行 SequemceFileReadDemo() 测试方法，可以从 SequemceFile 文件中读取数据，下方的“Console”窗口中会输出日志。 2. MapFile在 Eclipse 中运行 MapFileWriteDemo() 测试方法，可以将数据写入到 MapFile 文件（即 hdfs:&#x2F;&#x2F;hadoop00:9000&#x2F;mywork&#x2F;test&#x2F;mapfiledemo.map）。 在虚拟机中，通过执行下行命令可以分别查看该文件的 index 和 data 内容：hdfs dfs -text /mywork/test/mapfiledemo.map/index 和 hdfs dfs -text /mywork/test/mapfiledemo.map/data。 在 Eclipse 中运行 MapFileReadDemo() 测试方法，可以从 MapFile 文件中读取数据，此时下方的“Console”窗口中会输出全部文件内容及 key 值为 10 的内容。"},{"title":"第一章  分布式文件系统（HDFS）概述","date":"2022-09-07T04:18:31.731Z","url":"/posts/hadoop01/","categories":[["Hadoop","/categories/Hadoop/"]],"content":"HDFS 是一个支持海量数据存储的分布式文件系统，是存储大数据文件的重要载体。本章主要介绍了 HDFS 的体系结构、运行机制、工作流程和基本操作。 一、HFDS 概述1. HDFS 的设计目标和不足 设计目标： 支持超大文件存储 采用一次写入多次读取（write-once-read-many）访问模型 具有故障检测和快速自动恢复功能 采用流式数据访问 支持移动计算 不足： 不适合处理低延迟数据访问 无法高效存储大量小文件 不支持多用户写入和任意修改文件 2. HDFS 的体系结构HDFS 是一个主&#x2F;从（master&#x2F;slave）架构的系统，即一个 HDFS 集群由一个 NameNode 和若干 DataNode 组成。它俩也是 HDFS 的核心组件，其中，NameNode 被称为“元数据节点”、另一个被称为“数据节点”。 3. 数据块（block）磁盘数据块是磁盘读写的最小单位，也只能读写块整倍大小的数据。HDFS 的默认数据块大小为 128MB。 通常为512B，那为什么设置这么大？数据块越大，寻址开销越小。当然，盲目过大也不行，MapReduce 中的 Map 一次只处理一个块的内容，过大会导致整体任务量变少，进而影响数据的并行处理速度。 优点：可以存储任意大小的数据文件，只要物理切片就可以。简化了存储系统的管理：元数据信息和文件数据信息分开管理。有利于实现分布式文件系统的容错性：一个节点出故障，其他块读取副本。有利于实现负载军和并提高集群可靠性：某个数据节点的剩余空间低于临界点，就将这个数据节点移动到其他的数据节点上；此外，数据块的副本被安排在不同的机架上，即使丢失某台机架，读取副本即可，大大提高了集群的可靠性。与此同时，Hadoop 的故障检测和快速自动回复功能就可以及时将这些块副本数量恢复到正常水平。 4. NameNode 和 SecondaryNameNode1) 元数据节点（NameNode）管理 HDFS 文件系统的命名空间（namespace）。其实就是 HDFS 的目录结构，用户可以进行增删改重命名等 HDFS 文件。 所存储的元数据信息： 文件名、目录名与层次关系 文件目录的属主和权限 每个文件由哪些数据块组成 数据块到数据节点的映射信息 元数据信息被持久化的存到本地磁盘的两个文件中：fsimage（元数据镜像文件）和 edits（事务日志文件）。 元数据节点正常运行时，所有更新操作被写入 edits 文件中，如果直接写入元数据镜像文件，逐渐一段时间后，过大会导致系统运行速度变慢。即 edits 文件越来越大，不会对系统有明显影响，但是元数据节点的重启过程会越来越慢。 2) SecondaryNameNode（辅助者 · 元数据节点）解决掉 edits 文件过大的问题。是对 元数据镜像文件和事务日志文件进行定期合并。由于合并时需要消耗内存，因此通常这俩没在一个节点上面。 优点： 提升了集群性能，保存了元数据节点的元数据信息，一定程度上提高了元数据的安全性和可靠性。 3) 数据节点（DataNode）一个数据节点有多个数据块，每个数据块会在多个数据节点上存储副本，但一个数据节点只能有一个副本。 作用：负责向客户端或元数据节点提供数据的检索和读写服务，并通过心跳机制定期向元数据节点发送自己的块列表信息。一般情况下，数据节点会从磁盘中读取数据块，但如果某个块被频繁访问，系统会将其存放在数据节点的内存中。 从现有集群里面动态增加一个数据节点，怎么破？—索引眼：增加数据节点增加一个数据节点增加一个DataNode增加DataNodehadoop04**Hadoop04— 二、数据错误与恢复HDFS 的主要目标有一条是“具有故障检测和快速自动恢复功能”，这就要求即使再出错的情况下也要保证数据存储的可靠性。常见的出错情况包括block 损坏、NameNode 和 DataNode 的错误。 1. block 损坏处理网络传输错误和机器硬件故障等因素会造成数据损坏。客户端在读取文件时会对每个读取的块进行校验，如果出错，就会读取其他数据节点上的数据块，并将错误块报告给元数据节点，元数据节点随后会重新复制。此外，每一个数据节点都会开启一个块扫描进程，来定期验证块的正确性，不正确会报告给元数据节点进行处理。 2. NameNode 和 DataNode 错误处理1) NameNode 错误处理NameNode 上保存了元数据信息，仅此一份独一无二，因此必须确保该安全。 容错方式有以下三种： 元数据信息持久化到本地磁盘并同步到 NFS 中，但会因网络带宽等原因造成元数据丢失。 运行 SecondaryNameNode。但由于该备份的元数据信息滞后于 NameNode，所以也会丢失掉部分的数据信息。 启用主备两个NameNode。 三、HDFS的运行机制1. 副本机制 作用：为了维护爱与和平…咳咳串台了，再来！为了保证集群的容错性和可用性。 2. 心跳机制NameNode 启动后，会等待所有 DataNode 的“心跳”：DataNode 每隔一定间隔（默认三秒）主动向 NameNode 发送“心跳”，主动报告自己的状态信息。然后 NameNode 通过心跳向 DataNode 下达命令。如果长时间未收到，则可以证明该 DataNode 宕机，然后检查该 DataNode 上的块副本信息并备份到其他的 DataNode 上。对了，DataNode 会给主备主数据节点都会发送“心跳”。 3. 副本放置与机架感应策略1) 副本放置一个集群中多个机架，每个机架上多个数据节点，每个数据节点保存多个块副本。另外，元数据节点的元数据存储着每个数据节点所属的机架 ID。那么，如何分配文件的块副本到集群中的数据节点上面呢？ 默认下，副本的配置数为 3，其中，有两个被放在同一机架的不同数据节点上面，另外一个被另一个机架上。 一般情况下，3 个足矣。若大于等于 3，则之后的副本可以随意放置。避免一个机架有太多同意副本即可。 2) 机架感应（rack-aware）由于副本的存放位置会影响 HDFS 的可靠性和性能，HDFS 采用了一种机架感知策略来提高数据的可靠性，并提高网络带宽的利用率。这样一来，即使一个机架发生故障，由于其他机架上的副本仍然可用，不会影响数据的可靠性。另外，当读取数据时，应用程序可用在多个机架上同时读取，大大提高数据的读取速度。 4. 联邦（Federation）机制每个文件的元数据信息都需要保存到 NameNode 的内存中，于是便有了联邦机制。 作用：集群横向扩展的方式解决 NameNode 的瓶颈问题，即增加元数据节点的数量。由于 Hadoop 针对海量数据进行存储管理，并采用了数据冗余存储方式，所以磁盘I&#x2F;O才是集群的《主要瓶颈》。 在联邦机制中，每个 NameNode 分别管理文件系统命名口径的一部分（命名空间卷）。各卷中分别存储了命名空间的元数据和文件数据块的块池。同时，各卷相互独立互不影响互不通信。此外，集群中的所有 DataNode 都必须注册到各个 NameNode。 不过，没有解决掉单点故障问题，若某一个 NameNode 失效，仍无法恢复无法访问。 5. HA（7*24小时不中断服务） 机制所谓HA，即高可用（7*24小时不中断服务）。实现高可用最关键的是消除单点故障。方式：允许运行主备两个 NameNode，当 NameNode 节点发生故障时，可以快速启用备用的 NameNode，以确保集群正常运行。 备主数据节点和主主数据节点始终同步（元数据信息一致），它们之间通过 JournalNode 守护进程进行通信。 6. 安全模式启用后，就进入了安全模式。该模式下，主数据节点会检查块的完整性。此外，它还是一种只读模式。正常情况下，NameNode启动（额外延迟30s）就会退出安全模式，但是如果DataNode 丢失的数据块超过设定的值，集群就会一直处于安全模式。 两件事 等待每个数据节点的心跳，判断是否宕机，然后NameNode 将 DataNode 所发送的 block 报告与其元数据进行对比，以判断数据块是否正常。 在内存中加载 fsimage，然后将 fsimage 和edits 合并成新的 fsimage，并创建一个新的 edits。合并完成后删除旧的 fsimage 和 edits，并将新的俩重命名。7. 垃圾回收没有任何利用价值的块副本被认为是垃圾：若一个文件被删除，那么备份的该文件副本也就没有用。删除不会直接删除，会移动到回收站。四、HDFS 的工作流程在 Hadoop 集群中，客户端与元数据节点之间的通信、元数据节点与数据节点之间的通信、数据节点相互之间的通信、都是基于 RPC（远程过程调用）机制的。 1. 启动流程在 HDFS 的启动过程中，需要启动 NameNode 和DataNode。启动时，会先进入安全模式。数据节点启动时，会开启一个 DataBlockScanner 进程来扫描 block，并且由该进程定期向各个 NameNode 发送“心跳”。 2. 读流程Client 读取时，首先会访问 NameNode 以确认是否可以读取。是，则 Client 获得文件的 block 和 DataNode 信息，然后执行 HDFS 的读操作来获取数据。在读取数据结束后，需要关闭文件输入流。 3. 写流程Client 将数据预备写入到 HDFS 文件时，首先会访问 NameNode 确认写入的权限和文件是否存在（存在是否覆盖）。是，Client 在 NameNode 上创建写入文件的元数据信息，并返回可存储数据的 block 和 DataNode 信息，然后根据返回信息执行副本复制过程。写入结束后，需要关闭文件输出流。 4. 删除流程1) 使用 HDFS 命令删除文件root 用户的回收站目录为 hdfs://hadoop0:9000/user/root/.Trash。当用户使用 HDFS 命令执行删除操作后，系统会将需要删除的文件移动到回收站内的“&#x2F;Current”下。例如，root用户删除了“koinl01.txt”文件，就可以在 hdfs://hadoop0:9000/user/root/.Trash/Current/koinl01.txt 找到。回收站也是有时间周期滴。 2) 使用 Java API 删除文件需要有一段延迟时间，才可以真正删除掉。 五、HDFS 的基本操作基本操作包括：创建文件、移动文件、查看文件目录、读取文件等 1. HDFS 命令行操作 命令 解析 备注 hdfs dfs -help hdfs dfs -ls &#x2F; 查看HDFS根目录下目录和文件 -R选项递归展示 hdfs dfs -mkdir &#x2F;mywork 根目录下创建文件夹 -p选项多级目录 hdfs dfs -put a.txt &#x2F;mywork 虚拟机本地文件上传到HDFS中 -f 强制覆盖 hdfs dfs -get &#x2F;mywork&#x2F;a.txt &#x2F;root&#x2F;Downloads HDFS中文件下载到虚拟机本地 hdfs dfs -cp &#x2F;mywork&#x2F;a.txt &#x2F;mywork&#x2F;t1 HDFS中文件复制到目录 若复制到文件，即复制+重命名 hdfs dfs -mv &#x2F;mywork&#x2F;a.txt &#x2F;input&#x2F; HDFS中文件移动到目录 若移动到文件，即移动+重命名 hdfs dfs -cat &#x2F;input&#x2F;word.txt HDFS中查看文件内容 hdfs dfs -rm &#x2F;imput&#x2F;a.txt HDFS中删除文件 -r选项删除目录 hdfs dfs -df&#x2F; 查看HDFS可用空间 2. HDFS Java API 操作使用 HDFS Java API 可以远程对 HDFS 中文件进行创建、上传、下载、删除、读写等操作。 1) 新建 Map&#x2F;Reduce 项目和测试类创建目录在 Testfiles 类中添加一个用于创建目录的 createDir() 测试方法，该方法可以创建新目录。 上传 Windows 本地文件在 Testfiles 类中添加一个用于上传文件的 putFiles() 测试方法，该方法用于从 Windows 系统本地上传多个文件到集群。 下载文件到本地在 Testfiles 类中添加一个用于下载文件的 getFiles() 测试方法，该方法通过正则表达式过滤出以“txt”为文件扩展名的文件并下载。 删除文件（或目录）在 Testfiles 类中添加一个用于删除文件（或目录）的 deleteFiles() 测试方法，该方法用于从 HDFS 中删除文件（或目录）。 写入数据在 Testfiles 类中添加一个用于写入数据到文件的 writeHDFS() 测试方法，该方法用于向 HDFS 中写入文件。 读取数据在 Testfiles 类中添加一个用于读取文件数据的 readHDFS() 测试方法，该方法可以分行读取文件数据。"},{"title":"第四章  数据预处理","date":"2022-09-07T04:07:05.447Z","url":"/posts/DPaA04/","categories":[["Data-Processing-and-Analysing","/categories/Data-Processing-and-Analysing/"]],"content":"数据清洗与准备正则表达式数据规整为什么要有数据预处理技术？在数据挖掘的时候，现实世界的不完整，不一致的“脏”数据会致使无法直接进行数据挖掘。因此有了数据预处理技术在数据挖掘之前使用，会大大提高数据挖掘的质量，减少实际进行数据挖掘所需要的时间。数据预处理有很多种方法：数据清理，数据集成，数据变换，数据规约等。 一、数据清洗与准备需要被清洗的数据一般有以下三种类型：重复数据、异常数据（如 “age&#x3D;’-10’”）、缺失数据（如缺少属性值）。下面逐一介绍： 1.数据清洗准备1)重复数据的预处理重复数据过多，会导致结果具有错误的倾向性 2)异常数据的预处理也被称为噪声数据。例如，一个人的身高为100米，这是一个错误数据，因此需要被剔除掉。常用的检测方法有：箱线图，简单统计量、3？原则；常用的处理方法有删除法、插补法、替换法。 3)缺失数据的预处理如信息统计中年龄和性别丢失的情况，数据缺失的预处理方法主要有四种：均值补差、同类均值补差、极大似然估计、多重补差。 2.数据清洗1) 重复数据获取唯一值的方法是采用 unique() 函数，用于 Series 对象。 获取唯一值的方法是采用 drop_duplicates() 函数，用于 DataFrame 对象。 2) 缺失数据数据删除 数据填补 替换缺失值。对于数值型的数据，可以使用平均数或者中位数等方法补足 拟合缺失值。如果是数值变量，采用回归模型；如果是分类变量，采用分类模型 不处理。如果拥有较高的容忍度或者更灵活的处理方法，就可以在预处理阶段不做处理 3) 异常数据1） 异常点检测 箱线图、正太分布图、模型法2）异常点处理①不处理②填充③删除④编码 二、正则表达式快速匹配，不过…也太多了点，跳过跳过后来补 三、数据规整进行了数据清洗准备后，需要对数据进行规整处理 1.聚合、分组、数据透视1) 分组与聚合"},{"title":"第三章  数据可视化（Matplotlib）","date":"2022-09-07T04:05:54.496Z","url":"/posts/DPaA03/","categories":[["Data-Processing-and-Analysing","/categories/Data-Processing-and-Analysing/"]],"content":"数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。因此本章主要在于掌握数据图像的绘画。 在本章中，我们需要先将工具 Matplotlib 下载下来；其次，我们需要掌握进行简单的图形绘制；再次，一个好的图表不能只有图形，故需要掌握如何完善图表。最后，通过一个例子（掷骰子）来总结下所学内容。 一、安装 Matplotlib巧妇安能作无面汤饼乎？Matplotlib 为 Python 中第三方库，需要进行安装。安装方法：在 PyCharm 的最下方“终端中”输入：pip install matplotlib -i  --trusted-host mirrors.aliyun.com 二、简单认识下折线图、柱状图、直方图、散点图等1. 折线图（plt.plot()） go– 参数等同于：color，marker，linestyle 2. 柱状图（bar()） width 柱状宽度,mor 0.8hatch 填充,hatch ,&#x2F; * . obottom y轴起点数值align {‘center‘,’edge’}color 颜色edgecolor 柱体边缘颜色linewidth 柱状宽度 3. 直方图（hist()） 粗体为默认值！histtype 参数，可选{‘bar‘,’barstacked’,’step’,’stepfilled’}align 参数，可选{‘left’,’mid‘,’right’}orientation 参数，可选{‘horizontal’,’vertical‘}rwidth 参数，设置长条形的宽度占 bin 宽度的比例color 参数，指定颜色label 参数，区分多个数据集facecolor 参数，直方图的颜色edgecolor 参数，直方图边框的颜色alpha 参数，设置透明度 4. 散点图5. 等值线图三、对图形的优化总的来说，在 Matplotlib 中有两大元素： 基础类元素：线、点、文字、图例、标题、图片等。 容器类元素：图形、坐标图形、坐标轴和刻度。 我们可以绘制出来一个 在我们绘制图形时，牢记下述口诀，妈妈再也不怕我忘记如何画图了！ 导入所需库——字体设置——准备数据——绘制图形——美化图形——保存图形——展示图形 字体设置在图表中出现中文的时候使用美化图形在自己想要自定义图表的时候使用保存图形在自己想要保存图表的时候使用故最简单的绘图计划为：导入所需库——准备数据——绘制图形——展示图形 "},{"title":"第二章  数据分析（Pandas）","date":"2022-09-07T04:05:27.764Z","url":"/posts/DPaA02/","categories":[["Data-Processing-and-Analysing","/categories/Data-Processing-and-Analysing/"]],"content":"Pandas 库是基于 NumPy 的工具，该工具是为了完成数据分析任务而创建的。 一、下载 pandas 库下载方法：在PyCharm的最下方“终端中”输入：pip install pandas -i  --trusted-host mirrors.aliyun.com另外，若要导入 .xlsx 文件，则需要另外导入两个包：xlrd 和 openpyxl。 二、Series 对象Series 类似于一维数组对象，由一组数据和另一组与之相关联的索引组成。 1. Series 对象的创建可以通过数组和字典来构造 Series 对象。在矩阵中可以指定 index 。 点击显/隐 Series 对象的创建代码 2. Series 对象的访问可以分别访问 index 数组和 values数组。另外，若要访问指定数组的值，可以通过主数组的下标来访问，也可以采用通过 Series 对象的 index 标签来访问。另外，若要访问多个元素，方法与获取一个元素类似，但也稍有不同。 点击显/隐 Series 对象的访问的代码 3. Series 对象的增删改操作增加（或修改）操作都是直接对想要增加（或修改）的元素进行赋值。在删除操作中，del x[&#39;a&#39;] 可直接删除索引为 a 的元素；x.pop(&#39;a&#39;) 会返回删除的值的内容；&#96;x.drop(‘a’)&#96;&#96; 返回一个没有索引为a的元素的数组，即返回一个删除操作后的数组，x 对象其值并没有改变。 点击显/隐 Series 对象的增删改操作 三、DataFrame 对象Series 类似于二维数组对象 1. DataFrame 对象的创建可以通过矩阵和字典来构造 DataFrame 对象在矩阵中可以指定 index 和 columns，在字典中可以指定 index（columns 为字典的 key） 点击显/隐 DataFrame 对象的创建的代码 2. DataFrame 对象的访问可以分别访问 index 数组、columns 数组和 values数组。另外，若要访问指定数组的值，可以通过主数组的下标来访问，也可以采用通过 Data Frame 对象的 columns, index 标签来访问。另外，若要访问多个元素，方法与获取一个元素类似，但也稍有不同。 点击显/隐 Series 对象的访问的代码 3. DataFrame 对象的增删改操作增加（或修改）操作都是直接对想要增加（或修改）的元素进行赋值。在删除操作中，del x[&#39;a&#39;] 可直接删除索引为 a 的元素；x.pop(&#39;a&#39;) 会返回删除的值的内容；&#96;x.drop(‘a’)&#96;&#96; 返回一个没有索引为a的元素的数组，即返回一个删除操作后的数组，x 对象其值并没有改变。 点击显/隐 DataFrame 对象的增删改操作的代码 四、NumPy 的基本运用1. 数据统计1) 最值与求和若需要求每列最大值和最小值，使用函数 idxmax() 和 idxmin() 即可，axis=1 参数 可以改变为按行获值。；若需要按列求和，使用函数 sum()、若需要累计按列求和，使用函数 cumsum()，axis=1 参数 可以改变为按行获值。 点击显/隐数据统计 · 最值与求和的代码 2) 去重去重主要有两个函数：unique() 和 value_counts()。unique() 函数的作用是去除重复的元素，若参数为 Series 对象，则返回一个 NumPy 数组。value_counts() 函数的作用是返回一个 Series 对象，其中 index 为原 Series 对象中不重复的元素， values 为不重复的元素出现的次数。 五、导入与导出数据 "},{"title":"第一章  数据计算（NumPy）","date":"2022-09-07T04:03:46.766Z","url":"/posts/DPaA01/","categories":[["Data-Processing-and-Analysing","/categories/Data-Processing-and-Analysing/"]],"content":"NumPy 是用于科学计算的基础软件库，主要用来存储数组对象和处理大型矩阵，主要用于数组计算。 一、下载 NumPy 库下载方法：在PyCharm的最下方“终端中”输入：pip install numpy -i  --trusted-host mirrors.aliyun.com 二、认识NumPy 中的数组对象数据对象的创建 使用 array() 函数创建数组 使用 zeros()、ones()、empty() 函数创建全 0、全 1、随机数组 使用 arange() 函数创建等间隔的数组 数组对象的常用属性 数组元素的访问与修改 数组对象的基础运算 数组对象的常用函数 函数 功能 reshape() 改变数组的形状 ravel() 展开至一维数组 concatenate() 连接数组 delete() 删除指定值 sort 排序 小试牛刀：使用 NumPy 进行数学运算位运算函数 函数 功能 bitwize_and() bitwize_or() invert() left_shift() right_shift() 数学运算函数 函数 功能 三角函数 舍入函数 算术运算 函数 功能 add() subtract() multiply() divide() reciprocal() power() mod() remainder() 统计函数 函数 功能 amax() amin() percentile() median() mean() average() std() var() 线性代数函数 函数 功能 dot() vdot() inner() matmul() linalg.det() linalg.solve() linalg.inv() "},{"title":"第一章 待补充...","date":"2022-09-07T03:44:49.016Z","url":"/posts/DM01/","categories":[["Data-Mining","/categories/Data-Mining/"]]},{"title":"绪论  聊聊需要的软件","date":"2022-09-07T03:40:48.292Z","url":"/posts/hadoop00/","categories":[["Hadoop","/categories/Hadoop/"]]},{"title":"⌊电脑篇⌉ 电脑声音无法出现","date":"2022-08-25T08:03:44.238Z","url":"/posts/EDc-sound/","categories":[["电子设备","/categories/%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87/"]],"content":"挺不幸的是，最近电脑的声音老是会出现故障，便有了这篇文章可以在不便处供查询。我遇到的问题是这样：“外放没有声音，但是耳机正常能够识别到声音” 序言在写本篇时所使用的电脑是 惠普 星13 Air。本篇也仅使用于 惠普 星13 Air。 … 一般情况，喇叭的话，一般分成两个方面，首先，硬件喇叭出现损坏，导致的没有声音，硬件正常的情况下，一般就是跟驱动，系统文件，甚至一些可能的软件，病毒等导致的一个外放识别错误。那就先检查下硬件！先确认硬件正常后，再调试调试，如果无效后续也可以通过重装系统全面修复，如果硬件有问题就直接尝试保修下。 查询电脑是否为硬件问题查询硬件正常的工具：点击此处下载查询硬件工具 使用方法：重启机器，重启过程中连续点击f2按键，出现选择界面后，选择组件测试选项，选择音频，选择音频播放测试，如若有声音，证明电脑硬件正常。 该步骤完毕。可以强制关机掉。 软件问题，重装驱动即可即全面重置还原重装下声音模块。 首先，设备管理器下，所有的声音，游戏视频控制器位置所有的程序都右键，卸载， 此设备的驱动程序也应该一并卸载。这样机器会直接喇叭变成x，没有声音。 然后下载这个： 点击此处下载驱动工具 下载好后运行安装，会出现一个cmd框框，自动消失后，关机， 关机状态下同时按住win+v不松手，再按住电源开关两秒，然后先松开电源开关，待画面提示COMS reset（502）的信息后松开全部按键，按回车进入系统 重新让电脑加载各个驱动还有设备 •••大功告成！"},{"title":"第二章  查找","date":"2022-08-13T09:21:22.107Z","url":"/posts/dsa05/","categories":[["Data Structure and Algorithm","/categories/Data-Structure-and-Algorithm/"]],"content":"查找算法分为静态查找表与动态，其中，静态只能进行查找操作、动态可以在其中进行增删操作。 基于线性表的查找顺序查找[1,2,3,4,5,6,7,8,9]当腰查找8时，查看下标为0的是否等于，不等于查看下标为1，依此类推。若超出查找范围仍未找到，可以设定返回一个值。 二分查找顺序查找的改进。[1,2,3,4,5,6,7,8,9]，若找8先将a[(0+7)&#x2F;2]&#x3D;a[4]&#x3D;5与8比较，8大，所以8肯定在下标4-7内。再将a[(4+7)&#x2F;2]&#x3D;a[5]&#x3D;6与8比较，8大，所以8肯定在下标6-7内。再将a[(6+7)&#x2F;2]&#x3D;a[6]&#x3D;7与8比较，8大，所以8肯定在下标7内。 分块查找又称索引顺序查找，是上述两个查找的结合，性能介于两者之间。 每个块可以无序，但是关键码（即最大值）必须从左到右由小到大。 步骤： 选取各块的最大关键码构成一个索引表； 对索引表进行两种选一查找方法，以确定在哪一块中； 对已确定的块进行顺序查找。 二叉排序树"},{"title":"三级考试(数据库篇)错题整理(选择题, 填空题篇)","date":"2022-07-29T21:54:00.718Z","url":"/posts/sqlservers/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第 1 套第 2 套第 3 套第 4 套第 5 套第 6 套第 7 套第 8 套第 9 套第 10 套第 11 套第 12 套第 13 套第 14 套第 15 套O 第 16 套OK 第 17 套已做完 第 18 套已做完 第 19 套已做完 第 20 套已做完 第 21 套已做完 第 22 套已做完"},{"title":"第七章  文件和数据格式化","date":"2022-07-27T00:45:51.475Z","url":"/posts/python07/","categories":[["Python","/categories/Python/"]],"content":"7.1文件的使用文件是存储在辅助存储器上的一组数据序列，可以包含任何数据内容。概念上，文件是数据的集合和抽象。文件包括文本文件和二进制文件两种类型。7.1.1文件的类型文本文件一般由单一特定编码的字符组成，如UTF-8编码，内容容易统一展示和阅读。大部分文本文件都可以通过文本编辑软件或文字处理软件创建、修改和阅读。由于文本文件存在编码,所以，它也可以被看作是存储在磁盘上的长字符串，如一个txt 格式的文本文件二进制文件直接由比特О和比特1组成，没有统一的字符编码，文件内部数据的组织格式与文件用途有关。二进制是信息按照非字符但有特定格式形式的文件，如png格式的图片文件、avi格式的视频文件。二进制文件和文本文件最主要的区别在于是否有统一的这符编码。二进制文件没有统一的字符编码，只能当作字节流，而不能看作是字符串无论文件创建为文本文件或者是二进制文件，都可以用“文本文件方式”和“二进制文件方式”打开，但打开后的操作不同。一个文本文件 a.txt，其内容为“全国计算机等级考试”，采用文本方式打开。这里需要将文本文件与Python程序文件放在同一个目录中。采用文本方式读入文件，文件经过编码形成字符串，打印出有含义的字符;采用二进制方式打开文件,文件被解析为字节流。由于存在编码,字符串中的一个字符由多个字节表示。7.1.2文件的打开和关闭Python对文本文件和二进制文件采用统一的操作步骤，即“打开—操作—关闭”，操作系统中的文件默认处于存储状态，首先需要将其打开，使用得当前程序有权操作这个文件，打开不存在的文件系统可以创建这个文件。打开后的文件处于占用状态，此时，另一个进程不能操作这个文件。可以通过一组方法读取文件的内容或向文件写入内容，操作之后需要将文件关闭，关闭将释放对文件的控制使用文件恢复成存储状态，此时，另一进程能够操作这个文件。Python通过open()函数打开一个文件，并返回一个操作这个文件的变量。语法结构:变量名&#x3D;open(文件路径及文件名,打开模式)open()函数有两个参数:文件名和打开模式。文件名可以是文件的实际名字，也可以是包含完整路径的名字。打开模式用于控制使用何种方式打开文件，open()函数提供了7种基本的打开模式。文件的打开模式r 只读模式，如果文件不存在，返回异常FileNotFoundError，默认值w 覆盖写模式，文件不存在则创建，存在则完全覆盖原文件x 创建写模式，文件不存在则创建，存在则返回异常FileExistsErrora 追加写模式，文件不存在则创建，存在则在原文件最后追加内容b 二进制文件模式t 文本文件模式，默认值 与r&#x2F;w&#x2F;x&#x2F;a一同使用，在原功能基础上增加同时读写功能打开模式使用字符串方式表示，根据字符串定义，单引号或者双引号均可。上述打开模式中，r,w,x,a或以和 b,t,+组合使用，形成既表达读写又表达文件模式的方式。 7.1.3文件的读写根据打开方式不同，文件读写也会根据文本文件或二进制打开方式有所不同。f.read(size&#x3D;-1)：从文件中读入整个文件内容。参数可选，如果给出，读入前size长度的字符串或字节流。f.readline(size&#x3D;-1)：从文件中读入一行内容。参数可选，如果给出，读入该行前size长度的字符串或字节流。f.readlines(hint&#x3D;-1)：从文件中读入所有行，以每行为元素形成一个列表。参数可选，如果给出，读入hint行。f.seek(offset)：改变当前文件操作指针的位置，offset的值:o为文件开头;2为文件结尾。如果文件以文本文件方式打开，则读入字符串;如果文件以二进制方式打开，则读入字节流。如果文件不大，可以一次性将文件内容读入，保存到程序内部变量中。f.read()是最常用的一次性读入文件的函数．其结果是一个字符串。f.write(s)：向文件写入一个字符串或字节流f.writelines(lines)：将一个元素为字符串的列表整体写入文件f.write(s)向文件写入字符串 s，每次写入后，将会记录一个写入指针。该方法可以反复调用，在写入指针后分批写入内容，直至文件被关闭。使用f.write(s)时，要显示地使用”\\n”对写入文本进行分行，如果不进行分行，每次写入的字符串会被连接起来。f.writelines(lines)直接将列表类型的各元素连接起来写入文件f。7.2数据组织的维度一组数据在被计算机处理前需要进行一定的组织，表明数据之间的基本关系和逻辑，进而形成“数据的维度”。根据数据的关系不同，数据组织可以分为:一维数据、二维数据和高维数据。7.2.1一维数据一维数据由对等关系的有序或无序数据构成，采用线性方式组织，对应于数学中数组的概念。例如，中国的直辖市列表即可表示为一维数据，一维数据具有线性特点。维数据十分常见，任何表现为序列或集合的内容都可以看作是一维数据。7.2.2二维数据二维数据，也称表格数据，由关联关系数据构成，采用二维表格方式组织，对应于数学中的矩阵，常见的表格都属于二维数据。例如，国家统计局发布的居民消费价格数是二维数据。表格横向包括“指标”“2014年”“2015年”“2016年”，分别表示项目和时间维度，表格纵向为具体指标点，形成了二维数据关系。其中，第一行为说明部分，可以看作是与其他行一致的二维数据一行，也可以看作具数据外的数明部分7.2.3高维数据高维数据由键值对类型的数据构成，采用对象方式组织，可以我层嵌套。高维数据在Web系统中十分常用，作另当今Internet组织内容的主要方式，高维数据衍生出HTML、XML、JSON等具体数据组织的语法结构。以JSON格式为例，下面给出了描述“本书”的高维数据表示形式，其中冒号(:）形成一个键值对，逗号(,）分隔键值对，JSON格式中[]组织各键值对成为一个整体，与“本书”形成高层次的键值对。高维数据相比一维数据和二维数据能表达更加灵活和复杂的数据产系。7.3.1一维数据的表示一维数据是最简单的数据组织类型，幽于是线性结构，在Python 语言中主要采用列表形式表示。例如，中国的直辖市数据可以采用一个列表变量表示。采用列表类型表示一维数据的时候需要注意每个数据的数据类型。7.3.2一维数据的存储一维数据的文件存储有多种方式，总体思路是采用特殊字符分隔各数据。采用存储方法包括如下4种。(1）采用空格分隔元素，列如:(2)采用逗号分隔元素，例如:(3）使用换行分隔元素，例如:(4) 其他特殊符号分割这4种方法中，逗号分隔的存储格式叫作csv格式(Comma-Separated Values，即逗号分隔值)，它是一种通用的、相对简单的文件格式，在商业和科学上广泛应用，大部分编辑器都支持直接读入或保存文件为CSv格式，如 Windows平台上的记事本或微软Office Excel等。存储的文件一般采用.csv为扩展名。一维数据保存成CSV格式后，各元素采用逗号分隔，形成一行，这里的逗号是英文逗号。从Python表示到数据存储，需要将列表对象输出为CSV格式以及CSV格式读入成列表对象。列表对象输出为CSV格式文件方法如下，采用字符串的join()方法最为方便。 7.3.3一维数据的处理对一维数据进行处理首先需要从CSV格式文件读入一维数据,并将其表示为列表对象。需要注意，从CSV文件中获得内容时，最后一个元素后面包含了一个换行符(“‘n”)。对于数据的表达和使用来说，这个换行是多余的，需要采用字符串的strip()方法去掉数据尾部的换行符，进一步使用split()方法以逗号进行分隔。 7.4二维数据的处理7.4.1二维数据的表示二维数据由多个一维数据构成，可以看作是一维数据的组合形式。因此，二维数据可以采用二维列表来表示,即列表的每个元素对应二维数据的一行,这个元素本身也是列表类型,其内部各元素对应这行中的各列值。提示:二维数据的数据类型二维数据一般采用相同的数据类型存储数据，便于操作。尽管在二维数据中存在大量数值，但由于本例中数值所在行或列不都是数字，存在字符文本，因此，将数值统一表示为字符串形式。7.4.2二维数据的存储二维数据由一维数据组成，用CSV格式文件存储。CSV文件的每一行是一维数据，整个CSV文件是一个二维数据。存储以下数据为.csv文件，名称为cpi.csv。二维数据存储为CSV格式，需要将二维列表对象写入CSV格式文件以及将CSV格式读成二维列表对象。二维列表对象输出为CSV格式文件方法如下。 7.4.3二维数据的处理对二维数据进行处理首先需要从CSV格式文件读入二维数据，并将其表示为二维列表对象。读取CSV格式文件方法如下: "},{"title":"第八章  计算生态","date":"2022-07-27T00:24:29.043Z","url":"/posts/python08/","categories":[["Python","/categories/Python/"]],"content":"8.1计算生态近20年的开源运动产生了深植于各信息技术领域的大量可重用资源，直接且有力地支撑了信息技术超越其他技术领域的发展速度，形成了计算生态。产业界广泛利用可重用资源快速构建应用已经是主流的产品开发方式。Python 语言从诞生之初就致力于开源开放，建立健了全球最大的编程计算生态。Python官方网站提供了第三友库索引功能:该页面列出了Python语言十几万个第三方库的基本信息，这些函数库覆盖了信息领域所有技术方向。这里需要说明的是，Python语言的函数库并非都采用Python语言编写。由于Python有非常简单灵活的编程方式，很多采用c、C+t等语言编写的专业库可以经过简单的接口封装供Python 语言程序调用。这样的黏性功能使得 Python语言成了各类编程语言之间的接口，Python语言也被称为什“胶水语言”。正是因为什 Python语言有了胶水的黏性，围绕它迅速形成了全球最大的编程语言开放社区，建立了十几万个第三方库的庞大规模经，构建了计算生态。30年前，计算机领域还处于刀耕火种年代，编写程序仅能调用官方提供的API功能。20 年前，随着开源运动的兴起和蓬勃发展，一批开源项目诞生，降低了专业人士编写程序的难度，实现了专业级别的代码复用。10 年前，开源运动深入展，专业人士开始大量贡献各领域最优秀的研究和开发成果，并通过开源库形式发布出来。那今天呢?编程领域形成了庞大的计算生态，需要一种编程语言或方式能够将不同语言、不同特点、不同使用方式的代码统一起来。历史选择了Python语言，Python语言也证明了它的价值。Python第三方程序包括(库)、模块和程序包等多种命名，这些概念之间略有区别,在本教程中我们统一将这些可重用的代码统称为“库”。8.1.1Python标准库有一部分Python计算生态随Python安装包一起发布,用户可以随时使用,被称为Pytrion标准库。受限于Python安装包的设定大小，标准库数量不会很多，270个左右。Python的标准库一般会安装在Lib目录下C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35部分Python标准库由PSF (Python 软件基金会）运行维护，但大部分Python标准库仍然由最初的开发者维护。8.1.2Python第三方库更广泛的Python计算生态采用额外安装方式服务用户，被称为Python第三方库。这些第三方库由全球各行业专家、工程师和爱好者开发，没有顶层设计，由开发者采用“尽力而为”的方式维护。Python通过新一代安装工具 pip管理大部分Python第三方库的安装。"},{"title":"第九章  标准库概览","date":"2022-07-26T23:22:06.596Z","url":"/posts/python09/","categories":[["Python","/categories/Python/"]],"content":"9.1turtle库概述turtle（海龟）是 Python重要的标准库之一，它能够进行基本的图形绘制。turtle 图形绘制的概念诞生于1969年，成功就用于LOGO编程语言。由于 turtle图形绘制概念十分直观且非常流行，Python接受了这个概念，形成了Python 的turtle库，并成为标准库之一。turtle 库绘制图形有一个基本框架:一个小海龟在坐标系中爬行，其爬行轨迹形成了绘制图形。对于小海龟来说，有“前进”“后退”“旋转”等爬行行为，对坐标系的探索也通过“前进方向”“后退方向”“左侧方向”和“右侧方向”等小海龟自身角度方位来完成。则开始绘制时，小海龟位于画布中，此处坐标为（o，0)，前进方向为水平右方。turtle是最有价值的程序设计入门实践库,它是程序设计入门层面最常用的基本绘图库。5使用import 保留字对turtle库的引用有如下3种方式:importturtle，则对turtle库中函数调用采用turtle.函数名()形式。from turtle import* ,则对turtle库中函数调用直接采用函数名()形式，不再使用turtle作为前导。from turtle import *circle(200)import turtle as t ,则对turtle库中函数调用采用更简洁的t.函数名()形式，保留字as 的作用是将turtle库给予别名t。此处也可以使用t 之外的其他别名。import turtle as t t.circle(200)9.2turtle 库与基本绘图turtle库包含100多个功能函数，主要包括窗体函数、画笔状态和画笔运动函数3类。9.2.1窗体函数turtle库的turtle.setup()函数与窗体有关。函数定义如下:turtle.setup(width,height,startx,starty)参数详解:width:窗口宽度。如果值是整数，表示的是像素值;如果值是小数，表示窗口宽度与屏幕的比例。height:窗口高度。如果值是整数，表示的是像素值;如果值是小数，表示窗口高度与屏幕的比例。startx:窗口左侧与屏幕左侧的像素距离。如果值是None，窗口位于屏幕水平中央。starty:窗口顶部与屏幕顶部的像素距离。如果值是None，窗口位于屏幕垂直中央。import turtleturtle.setup(100,100,100,100)9.2.2画笔状态函数 pendown()：放下画笔,别名pd(),down()penup()：提起画笔，与pendown()配对使用，别名pu(),up()pensize(width)：设置画笔线条的粗细为指定大小，别名width()pencolor()：设置画笔的颜色color() I：设置画笔和填充颜色begin_fill()：填充图形前,调用该方法end_fill()：填充图形结束filling():返回填充的状态,True为填充,False为未填充clear():清空当前窗口，但不改变当前窗口的位置reset():重置当前窗口，并重置位置等状态为默认值screensize():设置画布窗口的宽度、.高度和背景颜色hideturtle():隐藏画笔的turtle形状showturtle():显示画笔的turtle形状isvisible()：如果turtle可见，则返回Truewrite(str,font&#x3D;None)：输出font字体的字符串：font&#x3D;(‘Arial’,50,’normal’))9.2.3画笔运动函数turtle通过一组函数控制画笔的行进动作，进而绘制形状序号forward(distance)：沿着当前方向前进指定距离，别名fd()background(distance)：沿着当前相反方向后退指定距离，别名bk()right(angle)：向右旋转angle角度left(angle)：向左旋转angle角度goto(x,y)：移动到绝对坐标(x,y)处setx(x)：修改画笔的横坐标到x，纵坐标不变sety(y)：修改画笔的纵坐标到y，横坐标不变seth[eading] (angle)：设置当前朝向为angle角度home()：设置当前画笔位置为原点，朝向东circle(radius,e)：绘制一个指定半径r和角度e的圆或弧形dot(r,color)：绘制一个指定半径r和颜色color的圆点undo()：撤销画笔最后一步动作speed()：设置画笔的绘制速度，参数为0~10之间9.3random库概述随机数在计算机应用中十分常见，Python语言提供了random库用于产生各种分布的伪随机数序列。random库采用梅森旋转算法生成伪随机数序列，可用于除随机性要求更高的加密算法外的大多数工程应用。使用random库的主要目的是生成随机数。这个库提供了不同类型的随机数，其中最基本的函数是random.random()，它生成一个[0.0,1.0)之间的随机小数，所有其他随机数都是基于这个函数而来的。seed(a&#x3D;None)：初始化随机数种子，默认值为当前系统时间random()：生成一个[0.0,1.0)之间的随机小数randint(a,b)：生成一个[a,b]之间的整数getranddbits(k)：生成一个k比特长度的随机整数randrange(start,stop[,step])：生成一个[start,stop)之间以step为步数的随机整数uniform(a,b)：生成一个[a,b]之间的随机小数choice(seq)：从序列类型中随机返回一个元素shuffle(seq)：将序列类型中元素随机排列，返回打乱后的序列sample(pop,k)：从pop类型中随机选取k个元素，以列表类型返回与其他编程语言相似，Python语言中随机数的生成基于随机数“种子”，每个种子作为输入，利用算法生成一系列随机数，构成伪随机序列。random 库使用random.seed(a)对后续产生成的随机数设置种子。所有的随机数都是基于random()函数实现的基种具体功能。(再次设置相同的种子，则后续产生的随机数相同)9.5time 库概述处理时间是程序最常用的功能之一，time库是 Python提供的处理时间标准库。Time库提供系统级精确计时器的计时功能，可以用来分析程序性能，也可让程序暂停运行时间。使用time库之前需要使用import进行导入time库的功能主要分为3个方面:时间处理、时间格式化和计时。时间处理主要包括4个函数: time.time()、time.gmtime()、time.localtime()、 time.ctime()。时间格式化主要包括3个函数:time.mktime()、time.strftime()、time.strptime()。计时主要包括3个函数:time.sleep()、time.monotonic()、time.perf_counter()o使用time.time()获取当前时间戳使用time.time()获取当前时间戳使用time.gmtime(sec)获取当前时间戳对应的struct_time对象。使用time.localtime(secs)获取当前时间戳对应的本地时间的 struct_time对象。与time.gmtime()的区别，是UTC时间已自动转的为北京时间。time.ctime(secs)获取当前时间戳对应的易读字符串表示，内部会调用time.localtime()函数以输出当地时间。time库使用time.mktime()、time.strftime()、time.strptime()进行时间格式化。使用time.mktime(t)将 struct_time对象t转换为时间戳，注意t代表当地时间。struct_time对象的元素构成下标 属性 值0 tm_year 年份、整数1 tm_mon 月份[1,12]tm_mday 日期[1,31]tm_hour 小时[0,23]tm_min 分钟[0,59]tm_sec 秒[0,61]tm_wday 星期[o,6]（o表示星期一）tm_yday 该年第几天[1,366]tm_isdst 是否夏令时，o否，1是，-1未知调用time.mktime(t)函数 time.strftime()函数是时间格式化最有效的方法，几乎可以以任何通用格式输出时间。该方法利用一个格式字符串，对时间林式进行表示。strftime()方法的格式化控制符%Y 年份 00019999例如:1900%m 月份 0112例如:10%B 月名 JanuaryDecember例如:April%b 月名缩写 JanDec例如Apr%d 日期 0131例如25%A 星期 MondaySunday 例如 wWednesday%a 星期缩写 Monsun例如Wed%H 小时（24h制) 0023例如12%I 小时（12h制) 0112例如7%p 上&#x2F;下午 AM,PM例如PM%M 分钟 0059例如26%S 秒 o0~59例如26 strptime()方法与strftime()方法完全相反，用于提取字符串中的时间来生成struct_time对象，可以很灵活地作为time模块输入接口。"},{"title":"第十章  第三方库概览","date":"2022-07-26T12:19:47.443Z","url":"/posts/python10/","categories":[["Python","/categories/Python/"]],"content":"10.1Python第三方库的获取和安装Python第三方库依照安装方式灵活性和难易程序有3个方法，这三个方法是: pip工具安装、自定义安装、文件安装。10.1.1pip工具安装最常用且最高效的Python第三方库安装方式是采用pip工具安装。pip是Python官方提供并维护的在线第三方库安装工具。对于Python3.x版本环境，可以采用 pip3命令代替pip命令专为Python3.x版本安装第三方库。使用pip安装第三方库需要联网。安装语法:pip install库名10.1.2自定义安装自定义安装指按照第三方库提供的步骤和方式安装。第三方库都有主页用于维护库的代码和文档。科学计算用的 numpy 的官方主页是:。浏览网页找到下载链接。。进而根据提示步骤安装。自定义安装一般适用于在pip中尚无登记或安装失败的第三方库。10.1.3文件安装由于Python某些第三方库仅提供源代码，通过pip下载文件后无法在 Windows系统编译安装，会导致第三方库安装失败。在 Windows平台下所遇到无法安装第三方库的问题大多属于这类10.1.4pip工具使用除了进行第三方库安装之外，pip工具能对第三方库进行基本的维护。执行pip-h 将列出pip 常用的子命令。pip支持安装(install&gt;、下载( download)、卸载( uninstall&gt;、列表(list)、查看(show)、查找(search）等一系列安装和维护子命令。pip 的uninstall子命令可以卸载一个已经安装的第三方库。10.2PyInstaller库概述PyIlnstaller是一个十分有用的 Python第三方库，它能够在 Windows、Linux、MacOS等操作系统下将Python源文件打包、变成直接可运行的可执行文件。通过对源文件打包，Python程序可以在没有安装Python 的环境中运行，也可以作为一个独立文件方便传递和管理。PyInstaller需要在命令行下用pip工具安装。pip install Pylnstallerpip指令可以将PyInstaller 库自动安装到Python 解释器目录，与pip或pip3命令路径相同，可以直接在命令行调用。Pylnstaller针对不同操作系统打包生成的可执行文件都不同。10.3PyInstaller库与程序打包使用PyInstaller库对Python源文件打包十分简单。语法结构:Pyinstaller源文件名执行完毕后，源文件所在目录将生成dist和 build两个文件夹。其中，build目录是PyInstaller存储临时文件的目录，可以安全删除。最终的打包程序在dist内部与源文件同中的目录中。目录中其他文件是可执行文件的动态链接库。可以通过-F参数对Python源文件生成一个独立的可执行文件。pyinstaller -F a.py执行后在dist目录中出了a.exe文件，没有任何依赖库，执行它即可运行程序。使用Pylnstaller库需要注意以下问题:文件路径不能出现空格和英文句号(.)源文件必须是UTF_8编码，暂时不支持其他编码类型。pyinstaller命令的常用参数-h、–help：查看帮助–clean：清理打包过程中的临时文件-D，–onedir：默认值，生成dist目录-F，–onefile：在 dist文件夹中只能生成独立的打包文件-i&lt;图标文件名.ico&gt;：指定打包程序使用的图标icon文件pyinstaller命令不需要在Python源文件中增加代码，只需要通过命令进行打包即可。 10.4jieba库概述由于中文文本的单词不是通过空格或者标点符号分割,中文及类似语言存在一个重要的“分词”问题。jieba是Python 中一个重要的第三方中文分词函数库，能够将一段中文文本分割成中文词语的序列。jieba 库需要通过pip指令安装。pip installer jiebajieba 库的分词原理是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词，jieba还提供增加自定义中文单词的功能。jieba库支持三种分词模式:精确模式，将句子最精确地切开，适合文本分析;全模式，把句子中所有可以成词的词语都扫描出来,速度非常快,但是不能解决歧义;搜索引擎模式，在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。对中文分词来说，jieba只需要一行代码。(英文文本不存在分词问题)10.5jieba库与中文分词jieba 库主要提供中文分词功能，可以辅助自定义分词词典。jieba库常用的分词函数jieba.lcut(s)：精确模式，返回一个列表类型jieba.lcut(s,cut_all&#x3D;True)：全模式，返回一个列表类型jieba.lcut_for_search(s)：搜索引擎模式，返回一个列表类型jieba.add_word(w)：向分词字典中增加新词wjieba.lcut(s)是最常用的中文分词函数，用于精确模式，即将字符串分割成等量的中文词组，返回结果是列表类型。jieba.lcut(s,cut_all&#x3D;True)用于全模式，即将字符串的所有分词可能均列出来，返回结果是列表类型，冗余性最大。相比精确模式，全模式会找到所有分词可能，比如“计算机”被分词为3个可能词语“计算”、“计算机”、“算机”。Jieba.lcut_for_search(s)返回搜索引掌候式，首先执行精确模式，在对其中长词进一步切分获得最终结果。相比精确模式，其中长词“计算机”被再次分词成“计算”、“算机”、“计算机”三个词语，存在一定冗余。提示:精确模式因为不产生冗余，最为常用。搜索引擎模式更倾向于寻找短诃语，这种方式具有一定冗余度，但相比全模式较少。3种分词模式如何选择?看需求如果希望对文本准确分词，不产生冗余，只能选择jieba.Icut(s)函数希望对文本分词更准确，不漏掉仕何可能的分词结果，选用全模式。没想好怎么用，可以使用搜索引擎模式。jieba.add word()函数，用来向jieba词库增加新的单词。10.6wordcloud 库概述数据展示的方式多种多样，传统的统计图尽管很“科学”，但略显古板。尤其对于文本来说，更加直观、带有一定艺术感的展示效果需要很大，对于这类需求，词云特有的展示方式深得人心。词云以词语为基本单元,根据其在文本中出现的频率设计不同大小以形成视觉上的不同效果，形成“关键云层”或“关键词渲染”，从而使用读者只要“一瞥”即可领略文本的主旨。这种展示方式已经成为文本展示的样板。Wordcloud库是专门用于根据文本生成词云的Python第三方库，十分常用且有趣。提示:词去能够将文本转变成词云，也是一种必备能力。有关wordcloud库的详细介绍可访问 cloud&#x2F;安装wordcloud库在 Windows的cmd命令行使用如下:10.7wordcloud库与可视化词云在生成词云时，wordcloud默认会以空格或标点分隔符对目标文本进行分词处理。对于中文文本，分词处理需要由用户来完成。一般步骤是先将文本分词处理，然后以空格拼接，再调用wordcloud库函数,处理中文时还需要指定中文字体。例如,选择了微软雅黑( msyh.ttc）作为显示效果,需要将该字体文件与代码存放在同一目录下或在字体文件名前加上完整路径。 Wordcloud库的核心是 WordCloud类，所有的功能都封装在 WordCloud类中。使用时需要实例化一个 WordCloud类的对象，并调用其 generate(text)方法将text文本转化为词云。WordCloud在创建时有一系列可选参数，用于配置词云图片。font_path指定字体文件的完整路径，默认Nonewidth生成图片宽度，默认400像素height生成图片高度，默认200像素mask词云形状，默认None，即方形图min_font_size词云中最小的字体字号，默认4号font_step字号步进间隔，默认1max_font_size词云中最大的字体字号，默认None，根据高度自动调节max_words词云图中最大词数，默认200stopwords被排除词列表，排除词不在词云中显示background_color图片背景色，默认黑色WordCloud类的常用方法generate(text)由text文本生成词云to_file(filename)将词云图保存为名为filename的文件wordcloud可以生成任何形状的词云，为了获取形状，需要提供一张形状的图像。"},{"title":"第六章  第三方生态","date":"2022-07-25T11:35:57.397Z","url":"/posts/python06/","categories":[["Python","/categories/Python/"]],"content":"numpy是Python的一种开源数值计算扩展第三方库，用于处理数据类型相同的多维数组，简称”数组”。这个库可用来存储和处理大型矩阵，比Python语言提供的列表结构要高效得多。numpy提供了许多高级的数值编程工具，如矩阵计算、矢量处理、N维数据变换等。PIL库是Python语言在图像处理方面的重要第三方库，支持图像存储、处理和显示，它能够处理几乎所有的图片格式，可以完成对图形的缩放、剪裁、叠加以及向图像添加线条、图形和文字等。PIL库可以完成图像归档和图形处理两方面功能需求。Python语言中Web开发框架第三方库有：Flask、Django、Pyramid，而mayavi是python语言中数据可视化方向的第三方库。Python网络爬虫领域的第三方库：scrapy和request。numpy是Python语言中数据分析方向的第三方库，openpyxl是python语言中文本处理方向的第三方库，PyQt5是Python语言中用户图形界面方向的第三方库。Python语言中数据分析方向的第三方库：numpy、scipy、pandas，而PIL第三方库可以完成图像归档和图形处理两方面功能需求。pandas用于数据分析属于机器学习领域：PyTorch，MXNet，TensorflowAracde是图形库scrapy是Python语言中网络爬虫方向的第三方库，而numpy、scipy和pandas是Python语言中数据分析方向的第三方库，matplotlib是数据可视化方向的第三方库，也属于数据分析领域Python语言中第三方库有三种安装方式：pip工具安装、自定义安装、文件安装，而pygame、PyQt5、pyinstaller是python语言中的第三方库。Python语言中机器学习方向的第三方库有Tensorflow、Theano、scikit-learn，而numpy、pandas是数据分析方向的第三方库，pygame是游戏开发方向的第三方库。Python语言中开发用户界面方向的第三方库：PyQt5、wxPython、PyGTK，而turtle库是python的标准库之一。Python语言中数据分析方向的第三方库：numpy、scipy、pandas。SeabornPython语言中数据可视化析方向的第三方库：matplotliB、TVTK、mayavi。mxnet是Python语言中深度学习方向的第三方库。Python语言中Web开发框架第三方库有Flask、Django、Pyramid，而scrapy是python网络爬虫方向的第三方库。Beautifulsoup4库，也称为Beautiful Soup库或bs4库，用于解析和处理HTML和XML。random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。于计算机视觉领域：OpenCV是一个强大的图像和视频工作库。它提供了多种程序接口，支持跨平台（包括移动端）应用。除了对图像进行基本处理外，还支持图像数据建模，并预制了多种图像识别引擎，如人脸识别PyQt5库是Python语言当前最好的GUI（用户图形界面）第三方库，它可以在Windows、Linux和MacOS X等操作系统上跨平台使用。人工智能领域：mxnet，keras，pytorchDjango：Web开发方向NLTK：自然语言处理工具包Luminoth：计算机视觉工具包redis-py：数据存储网络爬虫领域：Scrapy、Requests、PySpider。SnowNLP用于处理中文文本内容。Web开发方向：Tornado、Pyramid、Django。Python语言中Web开发框架第三方库有Flask、Django、Pyramid。pandas是数据分析的一个核心框架，集成了数据结构化和数据清洗以及分析的一些方法。pandas在numpy的基础上新增了三个数据类型，Series、DataFrame、Panel。可以进行高效的时间序列分析以及金融数据分析。 Pyinstaller命令的常用参数：-h，–help：查看帮助–clean：清理打包过程中的临时文件-D，–onedir：默认值，生成dist目录-F，–onefile：在dist文件夹中只生成独立的打包文件-i&lt;图标文件名.ico&gt;：指定打包程序使用的图标（icon）文件 第11章Python第三方库纵览11.1网络爬虫方向网络爬虫是自动进行HTTP 访问并捕获HTML页面的程序。Python语言提供了多个具备网络爬虫功能的第三方库。11.1.1requestsrequests库是一个简洁且简单的处理HTTP请求的第三方库，其最大优点是程序编写过程更接近正常URL访问过程。这个库建立在Python语言的urllib3库基础上，类似这种在其他函数库之上再封装功能提供更友好函数的方式在Python语言中十分常见。在Python生态圈里，任何人都有通过技术创新或体验创建新发表意见和展示才华的机会。Requests库支持非常丰富的链接访问功能，包括国际域名和URL获取、HTTP长连接和连接缓存、HTTP会话和 cookie 保持、浏览器使用风格的SSL 验证、基本的摘要认证、有效的键值对cookie记录、自动解压缩、自动内容解码、文件分块上传、HTTP(S）代理功能、连接超时处理、流数据下载等。有关requests库的更多可访问安装语法为: python35 -m pip install requests -i  –trusted-hostpypi.douban.comrequests库提供了7个函数，用来表示对一个网页的HTTP请求，requests库的常用函数：requests.request()：构造一个请求，支撑以下各方法的基础方法requests.get()：获取HTML 网页的主要方法，对应于HTTP的GETrequests.head()：获取HTML 网页头的主要方法，对应于HTTP的HEADrequests.post()：向HTML 网页提交POST请求的方法，对应于HTTP的POSTrequests.put()：向HTML网页提交PUT请求的方法，对应于HTTP的PUTrequests.patch()：向HTML 网页提交局部修改请求，对应于HTTP的PATCHrequests.delete()：向HTML页面提交删除请求，对应于HTTP的DELETE 11.1.2scrapyScrapy是Python开发的一个快速的、高层次的 Web获取框架。不同于简单的网络爬虫功能，scrapy框架本身包含了成熟网络爬虫系统所应该具有的部分共用功能，它是一个半成品,任何人都可以根据需求方便地利用框架已有功能经过简单扩展实现专业的网络爬虫系统。Scrapy用途广泛，可以应用于专业爬虫系统的构建、数据挖掘、网络监控和自动化测试等领域。Scrapy提供URL队列、异步多线程访问、定时访问、数据库集成等众多功能，基于它构建的爬虫系统可以7*24运行，具备产品级运行能力。有关scrapy库的更多介绍可以访问 pip install scrapy-i  pypi.douban.comScrapy框架结构，通过扩展函数完善功能后，可以利用这套框架实现对 Web页面不间断的获取。由于scrapy框架质量很高，可以用于产品设计和开发。scrapy架构原理图 11.2 数据分析方向数据分析是PYthon的一个优势方向，具有大批高质量的第三方库11.2.1numpyNumpy是 Python的一种开源数值计算扩展第三方库，用于处理数据类型相同的多维数组(ndarray)简称“数组”。这个库可用来存储和处理大型矩阵，比 Python语言提供的列表结构要高效很多。Numpy提供了许多高级的数值编程工具，如矩阵运算、矢量运算、N维数据变换等。Numpy内部是c语言编写，对外采用Python语言进行封装。因此,在进行数据运算时，基于numpy的 Python程序可以达到接近c语言的处理速度。Numpy也成为Python数据分析方向各其他库的基础依赖库，已经成了科学计算事实上的“标准库”。有关numpy库的更多介绍可访问: 安装语法：python35-m pip install numpy -i  pypi.douban.com11.2.2scipyScipy是一款方便、易用、专为科学和工程设计的 Python 工具包，它在是numpy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。它包括统计、优化、整合、线性代数、傅立叶变换、信号分析、图像处理、常微分方程求解等众多模块。顾名思义，scipy主要用于科学和工程计算。有关scipy库的更多介绍可访问:htts:&#x2F;&#x2F;scipy.org安装语法:python35-m pip install scipy -i  –trusted-host pypi.douban.com11.2.3pandaspandas是基于numpy扩展的一个重要第三方库,它是为了解决数据分析任务而创建的。pandas提供了一批标准的数据模型和大量快速便捷处理数据的函数和方法，提供了高效地操作大型数据集所需要的工具。Pandas最初被作为金融数据分析工具而开发，因此，pandas为时间序列分析提供了很好的支持。Pandas的名称来自面板数据(panel data）和 Python数据分析(data analysis)。Panel data是经济学中关于多维数据集的一个术语。Pandas 提供两种最基本的数据类型:Series和 DataFrame ,分别代表一维数组和二维数组类型。有关scipy库的更多介绍可访问:安装语法:python35-m pip install pandas -i  pypi.douban.com 11.3文本处理方向Python语言非常适合处理文本，因此，在这个方向也形成了大量有价值的第三方库。常用的有pdfminer、penpyxl、python-docx、beautifulsoup4。11.3.1pdfminerpdfminer是一个可以从PDF 文档中提取各类信息的第三方库。与其他PDF相关的工具不同，它能够完全获取并分析PDF的文本数据。pdfminer能够获取 PDF中文本的准确位置、字体、行数等信息，能够将PDF 文个把转为HTML及文本格式。pdfminer包含两个重要的工具: pdf2txt.py和dumppdf.py。pdf2txt.py能够从PDF 文件中提取所有文本内容。dumppd.py能够把PDF文件内容变成XML格式，并进一步提取其中的图片。在关pdfminer 库的更多介绍可访问安装语法:python35-m pip install pdfminer -i  –trusted-hostpypi.douban.com11.3.2openpyxlOpenpyxl是一个处理Microsoft Excel文档的Python第三方库，它支持读写Excel的xls、xlsx、xlsm、xltx、xltm等格式文件，并进一步能处理Excel文件中的工作表、表单和数据单元。有关openpyxl库的更多介绍可访问安装语法:python35 -m pipinstall openpyxl -i  –trusted-hostpypi.douban.com11.3.3python-docxPython-docx是一个处理Microsoft Word文档的 Python第三方库，它支持读取、查询以及修改doc、docx等格式文件，并能够对Word常见样式进行编程设置，包括字符样式、段落样式、表格样式、页面样式等，进一步可以使用这个库实现添加和修改文本、图像.样式和文档等功能。有关python-docx库的更多介绍可访问安装语法:python35 -m pip install python-docx -i  –trusted-hostpypi.douban.com11.3.4beautifulsoup4beautifulsoup4库，也称为Beautiful Soup库或bs4库，用于解析和处理HTML和XML。需要注意,它不是BeautifulSoup库。它的最大优点是能根据HTML和 XML语法建立解析树，进而高效解析其中的内容。HTML建立的Web页面一般非常复杂，除了有用的内容信息处，还包括大量用于页面格11.4数据可视化方向数据可视化是指根据数据特点将其展示为易于理解的图形的过程。Python语言在数据可视化方面具有较强的优势。常用的有matplotlib、TVTK、mayavi。11.4.1matplotlibMatplotlib是提供数据绘图功能的第三方库，主要进行二维图表数据展示，广泛用于科学计算的数据可视化。使用这个库可以利用Pyhton程序绘制超过100种数据可视化效果。有关matplotlib库的更多介绍可访问安装语法:python35 -m pip install matplotlib -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple –trusted-hostpypi.douban.com11.4.2TVTKTVTK库是在标准的VTK库之上用Traits库进行封装的Python第三方库。视觉工具函数库(Visualization Toolkit，VTK）是一个开源、跨平台、支持平行处理的图形应用函数库，它是专业可编程的三维可视化工具。TVTK在Python生态系统中被等同于VTK。windows平台不能使用pip命令安装，可以通过文件安装，其他平台可以11.4.3mayavi虽然VTK 3D可视化软件包功能强大，Python的TVK封装使用方便简洁，但是要用这些工具快速编写实用的三维可视化程序仍然需要花费不少精力。Mayavi基于TVK开发，完全用Python 编写，提供了一个更为方便实用的可视化软件，可以简洁地嵌入到用户编写的Python程序中，或者直接使用其面向脚本的API快速绘制三维可视化图形。值得注意的是mayavi也被称为,mayavi2。有关mayavi’*库的更多介绍可访问库在 Windows平台上暂时不能使用pip命令安装，建议使用文件安装，在其它平台可使用pip命令安装。11.5用户图形界面方向Python标准库内置了一个GUl库—Tkinter，这个库基于Tcl&#x2F;Tk开发，然而这个库十分陈旧，提供的开发控制也很有限、编写出来的GUI风格与现代程序GUI风格相差甚远，从用户体验角度说，Tkinter库并不成熟。常用的3个高质量的用户图形界面Python生态库:PyQt5、wxPython、PyGTK11.5.1PyQt5PyQt5是Q5应用框架的Python第三方库,它有超过620个类和近6000个函数和方法。它是Python中最为成熟的商业级GUI第三方库。这个库是Python语言当前最好的GUI第三方库，它可以 Window、Linux和 MacOSx等操作系统上跨平台使用。PyQt5采用“信号-槽”机制将事件和对应的处理程序进行绑定。简单说，信号就是事件、槽是事件的处理程序。例如，鼠标点击操作是信号，处理鼠标点击的程序是槽。一个信号可以连接多个槽，也可以不连接槽。信号可以连接其他信息。PyQt5窗体有很内置信息，也可以自定义信号。有关PyQt5库的更多介绍可访问 安装语法:python35-m pip install pyqt5 -i  –trusted-host pypi.douban.com11.5.2wxPythonwxPython是 Python语言的一套优秀的GUI图形库，它是跨平台GUI库 wxWidgets的Python封装，可以使用Python程序员能够轻松地创建健壮可靠、功能强大的图形用户界面的程序。其中, wxWidgets使用C++语言编写,C&#x2F;C++语言编写的功能库进行二次封装是Python语言的重要特点之一。有关wxPython库的更多介绍可访问安装语法:python35 -m pip install wxPython -i  –trusted-hostpypi.douban.com11.5.3PyGTKPyGTK是基于GTK+的Python语言封装，它提供了各式的可视元素和功能，能够轻构创建具有图形用户界面的程序。PyGTK具有跨平台性，利用它编写的代码能够不加修改地稳定运行在各操作系统中，如Windows、MacOS、Linux 等。有关PyGTK库的更多介绍可访问安装语法:python35-m pip install pygtk-i  –trusted-host pypi.douban.com11.6机器学习方向机器学习是人工智能领域的一个重要分支，Python 语言也是机器学习和人工智能的重要基础语言。常用的三个高质量的机器学习框架: scikit-learn、TensofFlow、Theano。11.6.1scikit-learnscikit-learn是一个简单且高效的数据挖掘和数据分析工具，它基于NumPy、SciP和matplotplib构建。 scikit-learn项目最早由数据科学家David Cournapeau在2007年组织开发，它是Python语言中专门针对机器学习应用而发展起来的一款开源框架。scikit-learn的基本功能主要包括6个部分:分类、回归、聚类、数据降维、模型选择和数据预处理。scikit-learn也被称为sklearn。有关scikit-learn库更多的介绍可访问安装语法:python35 -m pipinstall scikit-learn -i  –trusted-hostpypi.douban.com11.6.2TensorFlowTensorFlow是谷歌公司基于DistBelief进行研发的第二代人工智能学习系统，也是用来支撑著名AlphaGo系统后台框架，其命名来源于其自身的运行原理。Tensor(张量)指N维数组，Flow（流）指基于数据流图的计算，TensorFlow描述张量从流图的一端流动到另一端的计算过程。TensorFlow的应用十分广泛，从语音识别或图像识别到机器翻译或自主跟踪等，既可以运行在数万台服务器的数据中心，也可以运行在智能手机或嵌入式设备中。有关TensorFlow库的的更多介绍可访问为执行深度学习中大规模神经网络算法的运算而设计，擅长处理多维数组Theano开发始于2007年，可以理解它是一个运算数学表达式的编译器，并可以高效运行在GPU或CPU上。Theano是一个偏向底层开发的库,更像一个研究平台而单纯的深度学习库。有关Theano 库的更多介绍可访问安装语法:python35-m pip install theano-i  –trusted-host pypi.douban.com11.7Web开发方向Web开发是Python语言流行的一个重要方向，主要用于服务器后端开发。根据 PythonWeb开发框架的复杂程序。常用的 Python第三方生态度有:Django、Pyramid、Flask。11.7.1DjangoDjango是Python生态中最流行的开源Web应用框架。Django采用模型(Model&gt;、模板（Template）和视图(Views）的编写模式，称为MTⅣ模式。其中，模型即数据存取层，用于处理与数据相关的所有事务，包括如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等;模板即表现层，用于处理与表现相关的功能，通过模板方式定义页面风格;视图即业务逻辑层，用于存取模型及调取恰当模板的相关逻辑，是模型与模板的桥梁。Django中提供了开发网站经常用到的模块，Django 的开发理念是DRY (Don’t Repeat Yourself)，用于鼓励快速开发、进而减少程序员建立一个高性能 Web 应用所花费的时间和精力，形成一种一站式解决方案。有关Django库的更多介绍可访问安装语法:python35-m pip install django-i  –trusted-host pypi.douban.com11.7.2PyramidPyramid是一个通、开源的Python Web应用程序开发框架。它主要的目的是让Python开发者更简单地创建Web应用。相比 Django，Pyramid是一个相对小巧、快速、灵活的开源PythonWeb框架。与Django一样，Pyramid仍然面向较大规模的Web应用，但它更关注灵活性，开发者可以灵活选择所使用的数据库、模板风格、URL结构等内容。有关Pyramid 库的更多介绍可访问安装语法:python35 -m pip install pyramid -i  –trusted-hostpypi.douban.com11.7.3FlaskFlask是轻量级 Web应用框架，相比Django和 Pyramid，它也被称为微框架。使用Flask开发 Web应用十分方便，甚至几行代码即可建立一个小型网站。Flask核心十分简单，并不直接包含诸如数据库访问等的抽象访问层，而是通过扩展模块形式来支持。有关Flask 库的更多介绍可访问安装语法:python35-m pip install flask -i  –trusted-host pypi.douban.com11.8游戏开发方向游戏开发是一个有趣的方向，在游戏逻辑和功能实现层面，Python已经成为重要的支撑性语言。有Python中有三个常用的生态库:Pygame、Panda3D、cocos2d。11.8.1PygamePygame是在SDL库基础上进行封装的、面向游戏开发入门的Python第三方库，除了制作游戏外，还用于制作多媒体应用程序。其，中 sDL (Simple DirectMedia Layer）是开源、跨平台的多媒体开发库，通过 OpenGL和 Direct3D底层函数提供对音频、键盘、鼠标和图形硬件的简洁访问。Pygame是一个游戏开发框架，提供了大量与游戏相关的底层逻辑和功能支持，非常适合作为入门库理解并实践游戏开发。有关Pygame 库的更多介绍可访问安装语法:python35 -m pip install pygame -i  —trusted-hostpypi.douban.com11.8.2Panda3DPanda3D是一个开源、跨平台的3D渲染和游戏开发库，简单说，它是一个 3D游戏引擎，由迪士尼和卡耐基.梅隆大学娱乐技术中心共同开发。Panda3D支持 Python和C++两种语言，但对Python支持更全面。Panda3D支持很多当代先进游戏引擎所支持的特性，如法线贴图、光泽贴图、HDR、卡通渲染和线框渲染等。有关Panda3D库的更多介绍可访问安装语法:python35 -m pipinstall panda3d -i  –trusted-hostpypi.douban.compython35 -m pipinstall panda3d -i  –trusted-hostpypi.douban.com11.8.3cocos2dCocos2d是一个构建2D游戏和图形界面交互式应用的框架,它包括C++、JavaScript .Swift、Python等多个版本。Cocos2d基于OpenGL进行图形渲染，能够利用GPU进行加速。Cocos2d引擎采用树形结构来管理游戏对象，一个游戏划分为不同场景，一个场景又分为不同层，每个层处理并响应用户事件。11.9更多第三方库Python语言有十几万个第三方库，覆盖信息技术几乎所有领域。即使在每个方向，也会有大量的专业人员开发多个第三方库来给出具体设计。除了本章所提到的方向外，还有以下几个第三方库也是比较常用的。 11.9.1PILPIL库是Python语言在图像处理方面的重要第三方库，支持图像存储、处理和显示，它能够处理几乎所有的图片格式，可以完成对图像的缩放、剪截、叠加以及向图像添加线条、图像和文字等操作。使用Python语言处理图像相关的程序，首选PIL库。PIL库主要可以完成图像归档和图像处理两方面功能需求。图像归档:对图像进行批处理、生成图像预览、图像格式转换等。图像处理:图像基本处理、像素处理、颜色处理等。有关PIL库的更多介绍可访问安装语法:python35 -m pip install pillow -i  –trusted-hostpypi.douban.com11.9.2SymPySymPy是一个支持符号计算的Python第三方库，它是一个全功能的计算机代数系统。SymPy代码简洁、易于理解、支持符号计算、高精度计算、模式匹配、绘图、解方程、微积分、组合数学、离散数学、几何学、概论与统计、物理学领域的计算和应用。 有关SymPy库的更多介绍可访问:安装语法:python35-m pip install sympy -i  pypi.douban..com11.9.3NLTKNLTK是一个非常重要的自然语言处理Python第三方库，它支持多种语言，尤其对中文支持良好。NLTK可以进行语料处理、文本统计、内容理解、情感分析等我种应用，具备非常可靠的应用价值。有关NLTK的更多介绍可访问是一个微信公众号开发框架，也称为微信机器人框架。WeRoBot可以解析微信服务器发来的消息，并将消息转换成Message或者Event类型。其中，表示用户发来的消息，如文本消息、图片消息:Event则表示用户触发的事件，如关注事件、扫描二维确事件。在消息解析、转换完成后。WeRoBot 会将消息转交给Handler进行处理，并将Handler 的返回值给微信服务器，进而实现完整的微信机器人功能。有关 WeRoBot库的更多介绍可访问安装语法:python35 -m pipinstall werobot -i http;&#x2F;&#x2F;pypi.douban.com&#x2F;simple –trusted-hostpypi.douban.com11.9.5MyQRMyQR是一个能够产生基本二维码、艺术二维码和动态效果二维码的Python第三方库。有关MyQR库的更多介绍可访问安装命令:python35-m pip install myqr-i  pypi.douban.com"},{"title":"『SQL Server』考三","date":"2022-07-19T11:19:20.836Z","url":"/posts/sqlserver3/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第一套 性能优化设某全国性的运输企业创建了大型OLTP系统，并在该系统之上创建了数据仓库。OLTP系统和数据仓库中有以下数据表：运输明细表(运输单ID，发送站ID，终到站ID，货物ID，货物重量，运输价格，发货日期)汇总表1(发送站ID，终到站ID，货物ID，发货日期，总重，总运价)汇总表2(发送站ID，终到地区ID，货物ID，发货日期，总重，总运价)汇总表3(发送站ID，终到站ID，货物ID，发货月份，总重，总运价)汇总表4(发送地区ID，终到地区ID，货物类别ID，发货日期，总重，总运价)该企业管理的货运站约有100个，货物约有500种共10类，各汇总表都建有主码，且各表有合理的维护策略，在每次维护后数据能保持一致。设有视图V，该视图的访问频率很高，其查询结果模式为(发送地区ID，终到站ID，发货月份，总重，总运价)，该视图现以汇总表1为计算数据源。经监控发现，汇总表1的被访问频率太高，致使系统总体性能降低，而其它汇总表被访问频率较低。在不增长汇总表和索引的状况下，请给出一个改善系统服务性能的优化方案，并简要说明理由。 【解题思路】 计算机系统中存在着两类不同的数据处理工作：操作型处理和分析型处理，也称作OLTP(联机事务处理)和OLAP(联机分析处理)。操作型处理也叫事务处理，是指对数据库联机的日常操作，通常是对一个或一组纪录的查询或修改，例如火车售票系统、银行通存通兑系统、税务征收管理系统等。这些系统要求快速响应用户请求，对数据的完全性、完整性以及事务吞吐量要求很高。结合本题中存在的问题，视图本身的访问量很高，而又仅仅以汇总表1为计算数据源，而其它汇总表访问率低，导致了资源利用不合理。因此本题考察了联机事务处理中的资源调度问题。【参考答案】 由于汇总表1和视图的模式访问频率都很高，而且视图的数据源来自汇总表1，又因为其他汇总表的访问率较低，所以只需要将视图的数据源绑定为汇总表3，因为汇总表3也可以满足视图的输出模式。这样不仅提升了汇总表3的数据访问率，而且降低了汇总表1的数据访问率，系统性能和服务性能得到了很大的优化。又因为货物约有500种，共10类， 可以再建立一个视图绑定数据源为汇总表4，这样就可以充分利用汇总表4的数据信息，从而可以进一步优化系统性能。 第二套 性能优化 索引在进行某学校教务管理系统的数据库设计时，数据库设计人员设计了如下几个关系模式：系(系号，系名)，系号为主码学生(学号，姓名，所在系号)，学号为主码课程(课程号，课程名，开课系号)，课程号为主码选课(学号，课程号，选课时间)，学号和课程号为主码开发人员在将关系模式实施到SQL Server 2008的“教务”数据库时，使用了如下表结构定义语句：CREATE TABLE系(系号varchar(10)NOT NULL，系名varchar(100)) CREATE TABLE学生(学号varchar(50)NOT NULL，姓名varchar(50)，所在系号varchar(10))CREATE TABLE课程(课程号varchar(50)NOT NULL，课程名varchar(100)，开课系号varchar(10))CREATE TABLE选课(学号varchar(50)NOT NULL，课程号varchar(50)NOT NULL，选课时间datetime)在执行如下查询语句时发现执行效率很低：SELECT *FROM选课JOIN学生0N学生.学号&#x3D;选课.学号JOIN系ON系.系号&#x3D;学生.所在系号JOIN课程0N课程.课程号&#x3D;选课.课程号WHERE系.系号&#x3D;ˊ012 ˊAND convert(vvarchar(10)，选课时间，120)&gt;&#x3D;ˊ2010-01-01ˊ(1)在查找原因时发现建表语句有问题。请指出问题并说明该问题是否会影响此查询语句的执行效率。(4分)(2)设已在“选课”表的“选课时间”列及“学生”表的“所在系号”列上建立了索引。请问这两个索引是否能够提高该查询语句的执行效率?如果不能，请说明原因。(4分) 4、建表时没有设置主键，也没有说明外键，但不会影响此查询语句的执行效率。[解析]本题中查询语句的功能是得到12系全体学生在2010年1月1日后的选课情况的汇总表。在每个数据表的定义时都必须严格定义表中的完整性约束条件，包括主键的设置，否则之后会出现主键有相同值的情况，破坏了数据的完整性。5、”选课”表的”选课时间”可以建立索引，从而提高查询效率，而”学生w表的”所在系号w建立索引不会提高查询效率。索引的意义就是将记录按目标关键字顺序排列，这样查找某个目标关键字的对应值的位置就缩小了查找范围。”选课时间”的重复率低，所以可以作为索引，而学生”所在系号”的重复率太高，则不会提高查询效率。[解析]”选课”表的”选课时间”列上建立了索引，从而能够提高执行效率。经常出现在where子句中的字段，特别是大表的字段，应该建立索引。索引的作用就类似于书的目录，即会按照章节的顺序排列。因此如果在一本数百页的书里面查找某个章节位置的时候，就可以只扫描书的目录。扫描的范围缩了n倍，查询的效率自然就会提高。另外，在sQL Server内存够用的情况下，索引会被放到内存中，在内存中查找自然又会提高效率，所以必须合理利用索引。 第三套 性能优化某商场商品经营管理系统使用SQL Server 2008数据库管理系统，此系统上线运行1年后，业务人员使用某统计功能（此功能每月使用一次)时发现速度很慢。该统计功能主要执行的SQL语句如下:SELECT商品号,SUM(销售数量销售价格)销售额FROM销售明细GROUP BY商品号;该销售明细表的建表语句如下:CREATE TABLE销售明细(序列号intlIDENTITY(1,1) NOT NULL,商品号intNOT NULL,销售日期datetime NULL,销售数量intNOT NULL,销售价格intNOT NULL);并在销售明细表上建有如下索引:CREATE index ix_销售明细_商品号on销售明细(商品号);某技术人品提出涌过执行下述语句以提高此杳询的运行效率:CREATE VIEW商品销售额视图WITH SCHEMABINDINGASSELECT商品号,SUM(销售数量销售价格)销售额,COUNT_BIG(*) cntFROM dbo.销售明细GROUP BY商品号;CREATE UNIQUE CLUSTERED INDEX ix_商品销售额ON商品销售额视图(商品号);(10分)(1）请分析该技术人员给出的语句功能以及对原有查询语句的性能影响，并给出原因。(2）此商场的销售量很大，每天有大量数据插入到销售明细表中。请从数据库整体性能角度分析，此技术人员提出的优化方法是否合适，并给出原因。 语句功能:建立包含(商品号，销售额，该商品表中出现次数)带索引的视图，并建立按商品号对应销售额UNIQUE聚簇排序的索引，大大缩小」含询语可的食诩汇围，提高了查询效率。原因:税图中将间按相大周2小了推索空间，同时建商品号，销售数量，销售价格）转换成了目标属性列，减少了搜索空间;同时建立UNIQUE CLUSTERED索引，使查询商品号的数据记录唯一，降低了搜索范围，提高了搜索效率。 不合适，每天大量的插入操作使得在修改表的同时也要对视图进行修改，增加了系统的负担，然而该统计功能一个月才用一次，这样导致系统的利用率也较为低下。 第四套 性能优化某教务管理系统使用SQL Server 2008数据库管理系统，数据库软硬件配置信息如下：Ⅰ．数据库运行在两路Intel Xeon E5-2609 2.4GHz CPU(每路CPU4核心)，128GB内存、2块300GB 15000转SAS硬盘(RAID 1)的服务器上；Ⅱ．服务器操作系统为Windows 2003 32位企业版，安装SP2补丁；Ⅲ．数据库为SQL Server 2008 Enterprise(32 位)，数据库中总数据量近130GB。近一个学期以来，用户反映系统运行缓慢，经程序员定位，确定为数据库服务器响应缓慢，需要进行调优。 根据SQL Server 2008数据库的特性以及题目中的条件，综合给出以下的调优方案。(1）表结构优化:重新优化数据库设计结构，规范数据库逻辑设计;设计主键和外键;设计合适大小的字段。(2）硬件优化:购买一块同样大小的硬盘，将硬盘做成RAID5,用以提高数据库读写速度;增加服务器CPU个数;扩大服务器的内存。(3）索引优化:采用对经常作为条件查询的列设计索引，在查W中经吊尺到的入操作的表不要建立过多的繁进行范围查询、排序、分组的列上建立.策族索引，对了有从系选i索引。(4)采用视图:合理使用视图和分区视图，在需要更新和刎陈探作个夕、亘闲抹止十从乐PB长向拉一的再句兹(5)sQL语句优化:选择运算应尽可能先做，开仕X问一个衣应1多件想出数据较小的信息，再在这些信息在前面，较弱的选择条件写在后面，这样就可以无根伯权加充询，把子奋询转换成联结来实现。字段中根据后面较弱的条件得到满足条件的信息。应避免使用相关子查询，把子查询转换成联结来实现。字段提取按照”需多少，提多少”的原则，避免”SELECT *”，”SELECT *”需要数据库返回相应表的所有列信息，这对于一个列较多的表无疑是一项费时的操作，采用存储过程，使用存储过程提高数据处理速度。 第五套 性能优化某采购中心采购了一套商品批发查询管理系统，此系统采用SQL Server 2008数据库管理系统，该系统需要经常处理百万级以上的数据查询。同时该系统提供了第三方人员开发的SQL接口，第三方人员可以根据自己的需要开发自己的应用程序来访问数据库中的相关数据。(1)系统在使用的过程中，业务人员反应系统操作速度很慢。经过工程师检查测试后，数据库系统本身及网络传输过程中存在着一些问题，请给出针对数据库系统本身及网络传输过程中可能的一些调优方案。(2)工程师在完成数据库系统本身和网络问题的优化后，发现第三方开发人员的SQL查询语句存在很多没有优化的问题，请从第三方开发人员角度给出一些优化方案。 ①把数据、日志、索引放到不同的I&#x2F;0设备上，增加读取速度，数据量（尺寸)越大，提高I&#x2F;0越重要。②纵向、横向分割表，减少表的尺寸。③升级硬件，扩大服务器的内存 ,Windows 2000和SQL Server 2000能支持4-8G的内存。配置虚拟内存，虚拟内存大小应基于计算机上并发运行的服务进行配置。增加服务器CPU个数。分布式分区视图可用于实现数据库服务器联合体。联合体是一组分开管理的服务器，但它们相互协作分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层Web 站点的处理需要。⑤重建索引: DBCC REINDEX ,DBCC INDEXDEFRAG;收缩数据和日志:DBCC SHRINKDB,DBCC SHRINKFILE。设置自动收缩日志，对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。优化锁结构。2)①对查询进行优化，尽量避免全表扫描，首先应考虑在where 及 order by 涉及的列上建立索引。②应尽量避免在 where子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。③任何地方都不要使用select * from进行全表扫描，用具体的字段列代替”*”，不要返回冗余字段。④避免频繁创建和删除临时表，以减少系统表资源的消耗。⑤尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。⑥尽量避免大事务操作，提高系统并发能力。 第六套 恢复 性能优化某网上商城因为业务发展，原有的系统不能很好的满足需要，因此采用了一套新的经营管理系统，此系统使用SQL Server 2008数据库管理系统。此系统上线运行前，需将商场原有的数据导入到新系统中。原有系统使用SQL Server 2000，数据结构与新系统不完全一致。因此需要把数据从SQL Server 2000导入到SQL Server 2008中，为了保证数据一致性，数据导人过程中要求暂停业务且必须在3小时内完成。(1)在原有数据导入新系统的过程中，实施人员发现原有数据量很大，导人数据需要四小时，业务无法接受。经分析某工程师认为，数据导入过程中的数据库I／O很高，但导人数据的程序本身对系统资源占用率很低。该工程师建议将数据导人过程中的数据恢复模式从“完整”模式改为“简单”模式以提高数据导入速度；而另一位工程师则认为此方法未必能提高数据导人速度，而且还可能导致数据丢失，不建议使用此方法。请分析此方法是否能够提高数据导入速度并给出理由，同时分析此操作的数据丢失风险。(2)在成功导入历史数据后，此系统顺利上线运行。在上线运行的第一周，发现数据库服务器的CPU使用率很高，达到近90％，高峰期间达到100％，且系统内存占用率达到90％，但系统I／O很轻。业务人员反应系统操作速度很慢。为了提高系统运行速度。在不修改应用程序的前提下，两位工程师提出了不同的解决办法：Ⅰ 为服务器增加2颗CPU，缓解CPU使用率很高的问题；Ⅱ 为服务器增加一倍内存，缓解内存使用率很高的问题。考虑成本，现阶段只能按照一种方案实施。请指出在现有情况下，哪种方案更合理并给出理由。 (1）此方法能够提高数据导入速度。原因:此系统I&#x2F;o很高，修改恢复模式后，系统最大限度减少日志开销，可提高导入速度。由于仅在数据导入过程中修改恢复模式，所以并无数据丢失风险。(2）第一种方案比较合理。原因:SQL Server 2008采用将数据缓冲在内存的方式，因此内存的使用率比较高是正常情况，且现阶段Ⅰ&#x2F;O并不存在问题，表明内存满足需求。此阶段CPU使用率很高，表明CPU计算资源不足，因此增加CPU数量对解决问题有效。 第八套 性能优化设某超市经营管理系统使用SQL Server 2008数据库管理系统，此数据库服务器有2颗CPU、16GB内存、2TB磁盘。上线运行1年后，用户在生成每天每个销售人员及每个收银台的总销售额报表时速度缓慢。经技术人员分析，发现速度缓慢的原因为销售单据表和销售单据明细表数据量合计已经达到60GB。已知这两个表结构如下：销售单据表(销售单据编号，销售时间，销售人员编号，收银台编号)销售单据明细表(销售单据编号，商品编号，单价，数量)在进行此报表计算时数据库服务器CPU消耗非常高。为了优化此操作，某工程师建议在销售单据表中增加”付款总金额”属性，取值由触发器自动计算。请从磁盘空间使用、销售操作时对数据库服务器的影响、数据一致性以及对总销售额计算速度影响方面分析此方案优劣。请判断此方案是否可行，并从时空代价和优化效果方面分析原因。 此方案不可行。①触发器可以通过数据库中的相关表进行层叠更改，这比直接把代码写在前台的做法更安全合理，保证了数据的一致性，但同时增加了磁盘空间的消耗。在超市经营中要批量操作、多次触发的情况下，触发器的效率低，因为它相当于每次都执行一段SQL语句，使CPU的消耗更高。因而从时空代价角度来说并不能达到优化的效果。②在数据单据表中增加”付款总金额”不是正确的优化方法，应该在数据单据明细表中增加”付款总金额”，这样才能提高查询效率【解题思路】在数据库设计阶段，主要强调的是高效率利用存储空间，减少数据的冗余，减少数据的不一致性，这个过程也就是规范化的过程。但是在数据库运行阶段要考虑到高效率的进行数据处理。完全规划化的数据库会产生很多表，对于一个频繁使用的查询，如果它要求操作多个相关表中的数据，则每次为生成需要的查询结果而在连接多个表中相关行时，数据库管理系统就会消耗更多的计算资源，因为连接操作非常耗时。而反规范化是将规范化的关系转换为非规范化的关系的过程，目的是提高查询的效率。常见的方法有增加派生冗余列，增加冗余列，重新组表，分割表和新增汇总表等方法。该题解决的方式就是增加派生冗余列–”付款总金额”。派生性冗余列是指表中增加的列由表中的一些数据项经过计算而成，它的作用是查询时减少连接操作，避免使用聚合函数。例如销售单据明细表（销售单据编号，商品编号，单价，数量)中增加”付款总金额”，因为付款总金额&#x3D;单价*数量得到，说明”付款总金额”是派生性冗余列。如果不要该字段，那么每次使用总价时，都要先执行代码计算后才能使用，如果商品数量较多，而且要频繁使用”付款总金额”时，计算”付款总金额”时执行的次数也会随着增加，这显然会影响数据库的执行效率。若增加”付款总金额”这个派生性冗余字段，虽然破坏了规范化原则，但只要执行一次计算”付款总金额”就可以把商品金额存在数据库中，以后不管什么时候使用”付款总金额”字段，只需要提取其值就可以了，不必在执行代码了。因此增加”付款总金额”，虽然提高了磁盘空间的使用，但是可以提高系统执行的效率，达到以空间换时间的目的。 第十一套 性能优化3.设某超市经营管理系统(C&#x2F;S结构)使用SQL Server 2008数据库管理系统。系统上线运行1年后，用户反映系统运行速度不稳定，不定期会出现速度变慢的问题。数据库管理员在数据库服务器上采集了一段时间系统运行状态数据，情况如下：CPU最高使用率：30%内存最高使用率：80%磁盘IO很低同时，数据库管理员在客户端使用ping命令对数据库服务器进行测试，结果如下192.168.1.100 的Ping统计信息： 数据包：已发送&#x3D;100，已接收&#x3D;90，丢失&#x3D;10往返行程的估计时间（以毫秒为单位）： 最短&#x3D;10ms，最长&#x3D;502ms，平均&#x3D;100ms(5分)请根据以上数据，判断最有可能的问题，并给出判断的理由。在以上问题解决后，用户反映每日的定时统计汇总SQL语句仍然速度比较慢。数据库管理员在系统无任何人员使用时运行该语句，同时在数据库服务器上采集系统运行状态数据，情况如下：CPU最高使用率：12.5%(CPU配置：2路4核，共8核，关闭超线程)内存最高使用率：80%(内存配置：128GB磁盘IO很低(磁盘配置：5块300GB磁盘，RAID5)(5分)请分析在进行统计汇总时，数据库服务器最有可能的瓶颈是CPU、内存还是磁盘，并给出判断的理由。 【参考答案】(1）产生掉线的最有可能的原因是网络产生问题。因为通过ping命令测试，发现丢包率达到10%。而CPU，内存、磁盘I&#x2F;O使用率没有达到100%，说明还是有—定的富余，引起网络掉线的可能性较小。(2）数据库服务器最有可能的瓶颈是内存。因为内存的使用率在无任何操作的情况下达到80%，使用率较高。说明内存容量不足以完全支持服务器活动。对于一台数据库服务器来说，如果其在业务空闲时使用率超过90%，说明服务器缺乏CPU资源;如果高峰时CPU使用率仍然很低，则说明服务器CPU资源充足。据此，可以判断一个数据库系统CPU的使用情况。本题中CPU的最高使用率只有12.5%，说明CPU不可能是数据库服务器的瓶颈。磁盘&#x2F;O很低，说明也不可能是服务器的瓶颈。【解题思路】数据库系统运行需要依赖服务器、操作系统、存储、网络等多种因素。当这些数据库环境出现瓶颈时就会导致数据库运行变慢，甚至是无法完成正常业务。一般情况下，数据库访问代价模型由四部分组成:CPU处理数据的时间(即CPU代价)，磁盘读取的时间(即I&#x2F;O代价)，查询的内存开销(即内存代价)，对于网络中的数据库还要加上数据在网络上传输的时间(即通信代价)。因此数据库访问的代价模型是:总代价&#x3D;CPU代价+l&#x2F;O代价+内存代价+通信的代价。(1) CPU。当数据库操作对CPU性能的要求超过数据库服务器的CPU性能时，数据库性能就会受到CPU的限制。对于一台数据库服务器来说，如果其在业务空闲时使用率超过90%，说明服务器缺乏CPU资源;如果高峰时CPU使用率仍然很低，则说明服务器CPU资源充足。据此，可以判断一个数据库系统CPU的使用情况。解决的方法是为服务器适当增加CPU的数量或者终止需要许多资源的进程。(2）数据库性能优劣的一个重要度量是响应时间，而I&#x2F;O时间是响应时间的最大组成部分。因此，可以通过令I&#x2F;O时间最小化，减少磁盘上的文件竞争带来的瓶颈等方法来改善数据库系统的性能。(3)通过调整相关参数控制数据库的内存分配，也可以在很大程度上改善数据库系统的性能。(4)大量的SQL数据在网络上传输会导致网速变慢。网卡、交换机、集线器等网络设备的性能对网络的影响很明显，所以，通过调整网络设备，也可以在—定程度上提高数据库系统的性能。 第十三套 性能优化设某学校选课系统使用SQL Server 2008数据库管理系统，在学生选课期间，用户反映速度缓慢，大部分时间内，学生无法正常选课（选课学生近1万人）。经技术人员分析，发现速度缓慢的原因为数据库服务器响应缓慢。在选课期间，数据库服务器CPU使用率为100%，内存使用率95%，磁盘IO占用10%，网络带宽占用20%。在进—步分析后发现，学生在选课过程中需要在每次选定课程前校验相关课程的成绩信息，而校验成绩的SQL语句在业务不繁忙时仍需要1-2分钟才能执行完成。现有服务器硬件情况如下:CPU:两颗英特尔至强处理器E5-2640 2.50GHz内存:128GB，主频1600MHz 磁盘:6块600GB 15000转6Gbps SAS硬盘，RAID5网卡:千兆网卡为了保证系统稳定运行，现有如下优化方案:(1)将CPU更换为两颗英特尔至强处理器E5-2690 2.90GHz。(2）将内存提高到256GB，主频1600MHz。(3）将磁盘更换为6块800GB读取密集型MLC 6Gpbs硬盘，保持RAID5。(4）将网卡更换为万兆网卡。(5)优化校验成绩SQL语句并建立相关索引，校验完成时间降低到1秒。根据题目描述，请从是否能解决选课运行速度缓慢问题的角度逐个评价以上5个方案并给出原因。 【参考答案】(1)）提高CPU的主频，可以稍微缓解选课速度慢的问题。因为CPU主频提高，单位时间内处理的数据多一些，但不能根本解决服务器响应慢的问题。本题中的CPU在选课期间使用率达到100%，增加CPU的频率不能从根本解决问题。大量的SQL数据在网络上传输可能会导致网速变慢。(2)内存提高，可以改善选课速度慢的问题，内存的增加可以从一定程度上提高数据处理的效率。本题中，选课期间内存使用率达到95%，说明内存没有完全使用，因此内存容量不是产生服务器响应慢的原因。(3) SAS的特点是成本高、容量小、速度快，而MLC的特点是容量大、成本低,但是速度慢。因此替换原有的SAS硬盘不能提高数据存取的速度，不能解决选课运行速度慢的问题。(4）更换网卡不能解决选课运行速度慢的问题，因为本题中网络带宽的使用率占用20%，说明网络问题不是选课慢的主要原因。(5）可以从根本上解决选课慢的问题。原有校验成绩的SQL语句需要1-2分钟才能执行完成，当大量的学生选课时，CPU和内存主要用于处理SQL语句，大量的资源被消耗，引起服务器反应减慢。本题中，SQL语句的效率低下，是产生服务器响应慢的根本原因，应当对SQL语句优化。一般来说，效率低下的SQL语句常常是系统效率不佳的主要原因。【解题思路】数据库系统运行需要依赖服务器、操作系统、存储、网络等因素。当这些数据库环境出现瓶颈时会导致数据库运行缓慢，甚至无法完成业务。一般来说，可以从外部环境、调整内存分布、调整磁盘&#x2F;O、调整资源竞争等几方面来改变数据库的参数，提高其性能。(1)外部调整包括CPU调整和网络调整。当数据库操作对CPU性能的要求超过数据库服务器的CPU性能时，数据库性能就受到CPU的限制，使数据库操作变慢。(2)通过调整相关参数控制数据库的内存分配，也可以在很大程度上改善数据库系统的性能。(3）调整磁盘&#x2F;O。数据库性能优劣的一个重要度量是响应时间，而I&#x2F;O时间是响应时间的最大组成部分。因此，可以通过令I&#x2F;O时间最小化，减少磁盘上的文件竞争带来的瓶颈等方法来改善数据库系统的性能。(4)调整竞争。多个进程对相同的资源发出申请时，导致了竞争的发生，从而引起服务器的反应缓慢。(5）效率低下的SQL语句常常是系统效率不佳的主要原因。因此采用高效率的SQL语句，可以显著减少服务器的反应时间，提高服务器处理的速度。本题中，SQL语句的效率低下是产生服务器响应慢的根本原因，提高SQL语句的执行效率，可以有效提高服务器的响应速度。 第十四套 索引 性能优化在数据库中存在销售单据明细表，其建表语句为:CREATE TABLE销售单据明细表 (销售单据编号 varchar(20),商品编号 varchar(8),单价 money,数量 int,总价 money);为了保持数据一致性，此表中存在如下触发器：CREATE TRIGGER AutoCountSumON 销售单据明细表 FOR INSERT,UPDATEASDECLARE @UnitPrice money,@Quantity int,@Amount moneySELECT @UnitPrice &#x3D; 单价,@Quantity &#x3D; 数量 FROM insertedSET @Amount&#x3D;@UnitPrice * @QuantityUPDATE 销售单据明细表 SET 总价&#x3D;@AmountWHERE 销售单据编号&#x3D;(SELECT 销售单据编号 FROM inserted)AND 商品编号&#x3D;(SELECT 商品编号 FROM inserted)在系统运行一段时间后，此表中有近千万条数据，此时发现对此表以“销售单据编号”和“商品编号”为条件，对其他字段进行修改时操作速度很慢。请分析原因，并在不改变硬件和SQL语句的前提下，给出优化方法。在解决了①中的问题系统平稳运行3年后，用户反映系统速度很慢，管理员考虑更换硬件。经过一段时间的监控，系统资源使用情况如下:CPU使用率一般不超过70%内存使用率95%磁盘IO使用率高峰期90%-95%，主要为读操作请根据以上数据，说明在此次更换硬件过程中，应该着重提高哪方面硬件性能，并给出原因。 (1）对字段修改时操作速度很慢的原因是大量数据的查询速度慢，从而引起修改慢。优化的方法是在“销售单据编号”和“商品编号”上建立索引。(2）更换硬件时应该提高内存容量，磁盘在经济条件许可的条件下才有RAID10磁盘阵列。 (1）索引技术是一种快速数据访问技术，建立索引的目的就是为了提高查询的效率。查询的性能在很大程度上取决于存在什么样的索引来加快选择和联接的处理。对于大星数据，只有快速的定位、减少查询的时间就会增加修改的速度。(2)对于CPU、内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。本题中，内存和磁盘的使用率都高于90%，而CPU的使用率不高于70%，说明内存、硬盘的资源匮乏，需要调整，而CPU的资源充足不需要调整。因此在硬件调整时，应提高内存的容量和硬盘的访问效率。使用RAID时，可以将基本表和建立在表上的索引分别放在不同的磁盘上，这样访问基本表时，存放数据和存放索引的磁盘驱动器并行工作，可以得到较快的文件读写速度;类似的，日志文件与数据对象（表、索引等)也可分别存放在不同磁盘上以改善系统的I&#x2F;O性能。在RAID中，RAID10是一个RAIDO与RAID1的组合体，它继承了RAIDO的快速和RAID1的安全，同时读写速度均提高。 第十五套 分区 性能优化某学校网络计费系统使用SQL Server 2008作为数据库管理系统，系统中需保存每个用户的每次登录和退出时间，该表的结构如下：CREATE TABLE 登录日志表( 序列号 int identity(1,1), 帐号 varchar(8), 登录时间 datetime, 退出时间 datetime, 本次上网费用 real);在系统运行一段时间后，此表中有近5千万条数据。此时，用户按照登录时间查询自己近期上网情况时速度缓慢。为了提高用户体验，某工程师提出建议对此表进行分区，请分析其建议合理性（若合理请给出最优的分区方案），并说明原因。在解决了①中的问题系统平稳运行3年后，管理员考虑升级硬件。经过监控，系统资源使用情况如下：•CPU使用率一般不超过50%•内存使用率90%•磁盘IO使用率高峰期90%-95%，主要为读操作某工程师给出两种升级后的硬件配置方案：•配置一：2颗处理器，6核心，主频2.4GHz；64GB内存；300GB 10K转SAS硬盘，3块，RAID0•配置二：2颗处理器，6核心，主频1.9GHz；128GB内存；800GB 固态硬盘 SAS 读取密集型 MLC，2块，RAID1请根据以上数据，在不考虑费用因素的前提下，说明哪种配置更合理，并给出原因。 【参考答案】(1）因为操作仅限于查询，建立分区表可以有效的提高查询效率。对登录日志表中在登录时间列上以月为单位创建右侧分区函数，将登陆日志表分成12个分区，每个分区对应一年中一个月的值。(2）采用方案2。对于内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。本题中，内存和磁盘的使用率都高于90%，而CPU的使用率不高于50%，说明内存、硬盘的资源匮乏，需要调整，而CPU的资源充足不需要调整。因此在硬件调整时，应提高内存的容量和硬盘的访问效率。RAID1相对于RAIDO来说提高了读速度，加强了系统的可靠性，但是写效率没有提高。【解题思路】本题考查的是分区表的相关知识和数据库运行环境和参数调整知识。(1）分区表是将表中的数据按照水平方式分成不同的子集，这些数据子集存储在数据库的一个或多个文件组中。合理使用分区会在很大程度上提高数据库的性能。是否创建分区表主要取决于表当前的数据星大小以及将来数据星大小，同时还取决于对表中数据进行的操作特点。通常，如果某个大型表同时满足下列条件，则比较适合于进行分区∶①该表包含(或将包含)以多种不同形式使用的大星数据，②数据是分段的，比如数据以年份分隔。然而，数据量大并不是创建分区表的唯一条件，如果表中大星的数据都是经常使用的数据，而且他们的操作方式基本是一样的，则最好不要使用分区表。而对数据的操作只涉及一部分数据而不是所有数据时，可以考虑建立分区表。(2)对于CPU、内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。对于分区表来说，如果对某表中当前分段数据，经常进行的操作是添加、修改、删除、查询，而对于其他的数据，则几乎不操作，或者操作仅限于查询，那么就可以对表进行分区。使用RAID时，可以将基本表和建立在表上的索引分别放在不同的磁盘上，这样访问基本表时，存放数据和存放索引的磁盘驱动器并行工作，可以得到较快的文件读写速度;类似的，日志文件与数据对象（表、索引等)也可分别存放在不同磁盘上以改善系统的I&#x2F;O性能。RAID1相对于RAIDO来说提高了读速度，加强了系统的可靠性，但是写效率没有提高。在RAID中，如果不考虑价格因素，其实RAID10最适合的，它是一个RAIDO与RAID1的组合体，它继承了RAIDO的快速和RAID1的安全，同时读写速度均提高。但题目中主要考查的读能力，因此RAID1RAIDO更适合些。 第十七套 索引 性能优化设在SQL Server 2008某数据库中存在销售单据明细表，其建表语句为：CREATE TABLE 销售单据明细表(销售单据编号 varchar(10),商品编号 varchar(8),是否有效 varchar(4),单价 money,数量 int,总价 money)在系统运行一段时间后，此表中有近千万条数据。该系统中存在如下操作： select * from 销售单据明细表 where 销售单据编号 &#x3D; ‘135671445’ and 商品编号 &#x3D; ‘021’ and 是否有效 &#x3D; ‘是’;在系统运行中发现此操作的效率比较低，系统工程师提出如下建议：由于查询中使用了“销售单据编号”、“商品编号”和“是否有效”三个条件，因此可以分别在这三列上建立索引，提高查询效率。系统工程师建议中建立的三个索引是否能够提高查询效率？请简要说明原因。随着系统运行时间增长，系统运行速度逐渐变慢，经分析为磁盘IO不能满足数据库系统频繁读写的要求。工程师建议增加一块相同磁盘，将两块磁盘调整为RAID1模式。请从读写两方面分析，此操作是否能够改善磁盘IO问题。 【解题,思路】本题考查的是索引相关知识，如索引定义，在什么地方建立索引，建立索引的条件以及RAID1磁盘阵列的特点。(1）索引的知识索引技术是一种快速数据访问技术，它将一个文件的每个记录在某个或某些领域（或称为属性)上的取值与该记录的物理地址直接联系起来，提供了一种根据记录域的取值快速访问文件记录的机制。索引的使用要恰到好处，其使用原则一般如下:1经常在查询中作为条件被使用的列，应为其建立索引;②频繁进行排序或分组（即进行group by或order by操作）的列，应为其建立索弓3一个列的值域很大时，应为其建立索引;④如果待排序的列由多个，应在这些列上建立复合索引。(2) RAID1磁盘阵列的特点RAID1磁盘阵列级，是一种镜像磁盘阵列，其原理就是将一块硬盘的数据以相同位置指向另一块硬盘的位置。RAID1又称为Mirror或Miroring，它的宗旨是最大限度地保证用户数据的可用性和可修复性。RAID1的操作方式是把用户写入硬盘的数据百分之百地自动复制到另外一个硬盘上。由于对存储的数据进行百分之百的备份，在所有RAID级别中，RAID1提供最高的数据安全保障。同样，由于数据的百分之百备份，备份数据占了总存储空间的一半，因而，Mirror的磁盘空间利用率低，存储成本高。Mirror虽不能提高存储性能，但由于其具有的高数据安全性，使其尤其适用于存放重要数据，如服务器和数据库存储等领域。RAID1提高了读速度，加强了系统可靠性。但其磁盘的利用率低，冗余度为50%，同时写速度并未提高。RAID1经常要求保证用户数据的可用性和可修复性场所，体现系统的可靠性，而不是读写速度。RAID1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量因为另一块只是当作数据”镜像””。RAID1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAIDO磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID1磁盘阵列一般支持”热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。【参考答案】(1“销售单据编号”、“商品编号和“是否有效”都是查询的条件，因此在这三列上建立索引，可以提高查询效率。原因:经常在查询中作为条件被使用的列，应为其建立索引，可提高查询效率。(2):RAID1通常被称为Mirror，RAID中的硬盘分成相同而两组，互为镜像，当其中一块磁盘出现故障时，可以利用其镜像上的数据恢复，从而提高系统的容错能力。RAID1对数据的操作仍采用分块后并行传输方式。RAID1提高了读速度，加强了系统的可靠性。但其缺点是硬盘的利用率低，冗余度为50%，同时写速度并未提高。根据题意，磁盘IO不能满足数据库系统频繁读写的要求，如果增加一块相同磁盘，并调整为RAID1模式，能提高读的速度，但是写的速度并未提高，所以不能改善磁盘IO的问题。或者从读的方面来看：当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1可以提高读取性能，也提高了磁盘的存储空间。增加一个RAID1可以提高磁盘的存储空间，在一定程度上提高了读速度，加强了系统的可靠性。但是增加RAID1，系统变成四块硬盘，同时也就增加了系统的I&#x2F;O开销，当数据量大时，并不能很好地提高系统的读的速度。 从写的方面来看：RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。现在增加了一块RAID1磁盘阵列，相当于有四块硬盘，在写入数据时，可能会做两个备份，写入的速度更慢。 因此从读写两个方面来说，增加一块RAID1磁盘阵列不是解决问题的好的方式，这种方法不建议使用。 第十八套 性能优化 索引·复合在SQL Server 2008的数据库中存在如下两张关系表：学生表(学号，姓名，性别，身份证号，系所号)，学号为主码系所表(系所号，系所名，系所简称)，系所号为主码在数据库中执行如下T-SQL代码：DECLARE @DeptID varchar(10)DECLARE @cnt intSET @cnt&#x3D; 0DECLARE cursor1 cursor FOR SELECT 系所号 FROM 系所表 WHERE 系所名 LIKE ‘%电%’OPEN cursor1FETCH NEXT from cursor1 into @DeptIDWHILE @@FETCH_STATUS &#x3D; 0BEGIN DECLARE @temp_cnt int SELECT @temp_cnt &#x3D; COUNT() FROM 学生表 WHERE 系所号 &#x3D; @DeptID SET @cnt &#x3D; @cnt + @temp_cnt FETCH NEXT from cursor1 into @DeptIDENDCLOSE cursor1DEALLOCATE cursor1SELECT @cnt AS 学生总数执行过程中发现速度比较缓慢，为了解决性能问题，需在功能不变的情况下，将此T-SQL代码改为一条SQL语句： SELECT COUNT() FROM 学生表 JOIN 系所表 ON 学生表.系所号&#x3D;系所表.系所号 WHERE 系所名 LIKE ‘%电%’请分析此改变是否可以提高性能，并给出原因。学生表的身份证号和姓名上建有一个复合索引，索引建立语句为 CREATE INDEX idx_身份证号_姓名 ON 学生表 (身份证号,姓名)请指出如下两个查询语句能否使用此索引并说明原因。 SELECT * FROM 学生表 WHERE 身份证号 &#x3D; ‘123456789012345678’; SELECT * FROM 学生表 WHERE 姓名 &#x3D; ‘小明’; 【解题思路】本题考查的是T-SQL与SQL语句使用的区别，以及索引相关知识，如索引定入义，在什么地方建立索引，建立索引的条件等等。(1)T-SQL即Transact-SQL，是SQL在Microsoft SQL Server 上的增强版，它是用来让应用程序与SQL Server沟通的主要语言。T-SQL提供标准SQL的DDL和DML功能，加上延伸的函数、系统预存程序以及程式设计结构（例如IF和WHILE)让程式设计更有弹性。SQL是集DDL、DML、DCL为—体的标准关系数据库语言。其中DDL数据定义语言用于定义和管理SQL数据库中的所有对象的语言;DML数据操纵语言，SQL中处理数据等操作统称为数据操纵语言。SQL作为结构化查询语言，是标准的关系型数据库通用的标准语言;T-SQL是在SQL基础上扩展的SQL Server中使用的语言。(2)索引的知识索引技术是—种快速数据访问技术，它将一个文件的每个记录在某个或某些领域(或称为属性)上的取值与该记录的物理地址直接联系起来，提供了一种根据记泉域的取值快速访问文件记录的机制。索引的使用要恰到好处，其使用原则—般如下:①经常在查询中作为条件被使用的列，应为其建立索引;②频繁进行排序或分组(即进行group by或order by操作)的列，应为其建立索引;③一个列的值域很大时，应为其建立索引;④如果待排序的列由多个，应在这些列上建立复合索引。【参考答案】(1) SELECT COUNT(*)FROM学生表JOIN系所表ON学生表.系所号&#x3D;系所表.系所号WHERE系所名LIKE’%电%’性能更好。原因:T-SQL的代码需要先扫描—遍系所表，然后根据扫描得到的每个记录重新扫描—遍学生表得出结果。使用所写的SQL语句实现同样的功能，将学生表和系所表连接之后按条件过滤，只需要扫描一遍连接之后的表即可。(2）创建的复合索引对第二条语句的查询效率提高不明显，因为其是复合索引且身份证号排在前面，对查找姓名的查询效率提高不明显，而明显会提高第—条语句的查询效率。或者：[1]:能够提高性能。 原本的代码中使用了游标。游标是一种临时的数据库对象，常见用途就是保存查询结果，以便以后使用。游标的结果集是由SELECT语句产生的，如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多。 但是，题中检索的是系所名中含有”电”字的，事实上所有学生被检索的概率理论上都是相同的，此处不符合”创建一次，使用多次”的前提条件。 另外，游标使用时会对行加锁，可能会影响其他业务的正常进行。同时数据量大时，游标会导致效率低下。 还有，游标其实是相当于把磁盘数据整体放入了内存中，可能会带来巨量的内存占用的情况。 综上所述，一般情况下尽量不要使用游标，因为会降低效率影响性能。除非遇到特殊情况。游标在使用完毕后应及时释放销毁，以释放资源。[2]:第一条select语句可以使用此索引，第二条select语句无法使用此索引。 基于多个列来创建的索引是复合索引。以下列语句为例： CREATE INDEX idx_test ON 学生表 (身份证号,姓名,性别) 此索引将优先对”身份证号”排序（第一顺序），若存在身份证号相同的多名学生，则对这些学生的”姓名”排序（第二顺序），若姓名也存在相同的，则按照”性别”排序（第三顺序）。 复合abc索引中，可以查询只可以a，ab，abc 所以，题中第一条select语句是单独查询第一顺序的身份证号，可行；题中第二条select语句是单独查询第二顺序的姓名，无法使用该复合索引 第二十套 并、交、差运算 性能优化某商品经营管理系统使用SQL Server数据库。在数据库中存在销售单据表，建表语句为：CREATE TABLE 销售单据表(销售单据编号 char(20),付款总金额 money,销售日期 datetime,销售人员编号 varchar(8),收银台编号 varchar(6));由于该表数据量巨大，因此建立了销售单据历史表，将1年以前的数据从销售单据表转入销售单据历史表。销售单据历史表的建表语句如下：CREATE TABLE 销售单据历史表(销售单据编号 char(20),付款总金额 money,销售日期 datetime,销售人员编号 varchar(8),收银台编号 varchar(6));其中销售单据编号为主键，在收银台编号和销售人员编号上有索引。[1]在系统运行一段时间后，发现如下语句执行速度缓慢：SELECT 销售单据编号,付款总金额,销售日期 FROM 销售单据表 WHERE 收银台编号&#x3D; ‘001000’unionSELECT 销售单据编号,付款总金额,销售日期 FROM 销售单据历史表 WHERE 收银台编号&#x3D; ‘001000’请给出该语句执行速度缓慢的原因，并给出SQL语句的优化方案。[2]在系统运行过程中，磁盘I&#x2F;O很重，数据库数据量近200G且磁盘写入性能要求非常高。考虑对硬件进行升级，3位工程师给出了不同配置方案：•方案1：CPU保持不变，内存16G，2块300GB SAS硬盘，使用硬件RAID卡做RAID1•方案2：CPU保持不变，内存8G，4块300GB SAS硬盘，使用硬件RAID卡做RAID0•方案3：CPU保持不变，内存16G，3块146GB SAS硬盘，使用硬件RAID卡做RAID5在不考虑成本的情况下，请指出哪种方案更适合此应用并给出原因。 本题考查的是sQL语言支持对查询结果在进行并、交、差运算以及不同磁盘阵列RAID的特点。(1）并运算可将两个或多个查询语句的结果集合并为一个结果集，这个运算可以使用UNTON运算符直符实现。UNION是一个特殊的运算符，通过它可以实现让两个或更多的查询产生单一的结果集。使用UNION谓词的语法格式为:SELECT语句1UNION [ALL ]SELECT语句2UNION [ALL]…SELECT语句n其中:ALL表示在结果集中包含所有查询语句产生的全部记录，包括重复的记录。如果没有指定ALL，则系统默认是删除合并后结果集中的重复记录。UNION和UNION ALL的区别是:UNION会自动压缩多个结果集合中的重复结果，而UNION ALL则将所有的结果全部显示出来。(2）磁盘阵列RAID所采用的方法不同，可以将其分为很多级别，常见的RAID级别有RAIDO、RAID1、RAID5等。下面分别对不同级别RAID的特点进行介绍。①RAID O向RAID O写入数据时，RAID将数据分成许多块，然后并行地将它们写到RAID中各个硬盘上﹔读出数据时，RAID从各个硬盘上读取数据，把这些数据恢复为原来顺序后传给主机。RAID O的优点是采用数据分块、并行传送方式，能够提高读写速度。但RAID中存储空间没有冗余，对系统的可靠性没有任何提高，任一个硬盘介质出现故障时，数据将无法恢复。②RAID 1:RAID 1通常也被称为Mimor，RAID中的硬盘分为相同的两组，互为镜像，当其中一块磁盘出现故障时，可以利用其镜像上的数据恢复，从而提高系统的容错能力。RAID1对数据的操作仍然采用分块后并行传输方式。RAID 1提高了读速度，加强了系统的可靠性。但其缺点是硬盘利用率低，冗余度为50%，同时写速度并未提高。③RAID 5、RAID 5可以为系统提供数据安全保障，但保障程序要比RAID 1低而磁盘空间利用率要比RAID 1高。RAID) 5具有和RAID O相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息.，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低。【参考答案】(1)在执行完Union语句后，需要对表中数据逐个查询，该表数据量较大，所以执行速度缓慢。sQL语句的优化方案:SELECT销售单据编号,付款总金额,销售日期FROM销售单据表WHERE收银台编号&#x3D;’001000’Union AllSELECT销售单据编号,付款总金额,销售日期FROM销售单据历史表WHERE收银台编号&#x3D;’001000这个执行效率较高。在执行完Umion语句后，执行alti语句，根据由销售日期和销售人员编号建立的索引，直接查询，故效率较高。(2)RAID O并行读写于多个磁盘上，具有很高的数据传输率，但它只是单纯地提高性能，并没有为数据的可靠性提供保障。RAD 1高数据可靠性，通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能，但是CPU占用率同样也很高，而磁盘的利用率比较低。RAID 5是一种存储性能、数据安全和存储成本兼顾的存储解决方案。故方案3更合适。或者[1]union有一个distanct的动作，需要进行并运算的数据量越大，其操作执行越慢。只需把union改为union all，就会取消这个distanct操作，速度将会大幅增加。 [2]由于题目已提及I&#x2F;O很高，方案1的RAID1方案对于I&#x2F;O没有帮助，所以否决。 方案2的RAID0方案虽然对磁盘I&#x2F;O的提升最大，但是由于RAID0对于数据的可靠性没有任何帮助，暂时候选。 方案3采用RAID5方案。RAID5的读取性能与RAID0接近，但写入速度比单个磁盘稍慢，而数据的可靠性高于RAID0。 结合题目提及对于磁盘写入性能要求非常高，所以只能选方案2，因为方案1对读写性能没有提升，而方案3本题中十分看重的降低了写入性能。 第二十一套 索引 性能优化在SQL Server某数据库中存在销售单据明细表，其建表语句为：CREATE TABLE 销售单据明细表（销售单据编号 varchar(20),商品编号 varchar(8),单价 money,数量 int);系统运行一段时间后，此表中有近千万条数据，程序员在数据库中执行如下SQL语句：SELECT 商品编号,sum(单价*数量) FROM 销售单据明细表 WHERE 单价&gt;150 GROUP BY 商品编号1.为提高此查询的执行效率，在不改变SQL语句且不进行硬件调整的情况下，请给出提高查询执行效率的方案。2.在运行过程中，发现此系统数据库CPU使用率很高，达到近95%，高峰期间达到100%，且系统内存使用率达到90%，但系统I&#x2F;O很轻。业务人员反映系统操作速度慢。为了提高系统运行速度，在不修改应用程序的前提下，两位工程师提出了两种不同的解决方案：方案一：为服务器增加1颗CPU方案二：为服务器增加一倍内存考虑成本因素，现阶段只能选择一种方案实施。请指出在现有情况下，哪种方案更合理并给出原因。 【参考答案】(1）在不改变SQL语句且不进行硬件调整的情况下，可以为销售单据明细表“商品编号”建立一个索引来提高查询的效率。(2)方案一合理。提高数据库性能的方法，一般是从外部环境、调整内存分配、调整磁盘IO、调整竞争资源等几方面着手来改变数据库的参数。SQL Server采用将数据缓冲在内存的方式，因此在数据库系统运行的过程中会占用一定的内存，又因为IO并不存在问题, 说明内存上满足需求。CPU使用率很高，说明CPU计算能力不足，应增加CPU的数量。或者1、由于运行一段时间后，就有了近千万条数据，说明数据的写入量很大，这种情况下不能使用索引，因为写入量大，所以索引的维护开销将非常巨大，不仅无法提高效率，反而会降低性能，所以不适合查询优化。由于题目不允许改变SQL语句，所以无法使用反规范化或使用临时表的方式，以空间换取时间。题目同样不允许硬件调整，不允许进行硬件升级。本题最适合的方案是数据表的水平分割，由于商品编号有很多，所以应该按照单价区间进行水平分割2、根据题目表述，两种方案都能够提高系统运行速度。但是，即便是平峰时CPU的负载也很高，高峰时甚至达到100%，而内存使用率低于CPU使用率，迫切程度低于CPU的需求。所以在成本有限的前提下，应该选择方案1，增加一颗CPU以缓解CPU的性能压力。选择此方案所得到的效果将高于方案2。 第二十二套 索引 触发器某商品经营管理系统使用SQL Server数据库管理系统。在数据库中存在销售单据明细表，其建表语句为:CREATE TABLE销售单据明细表 (销售单据编号 varchar(20),商品编号 varchar(8),单价 money,数量 int,总价 money);为了保持数据一致性，此表中存在如下触发器：CREATE TRIGGER AutoCountSum ON 销售单据明细表 FOR INSERT,UPDATEASDECLARE @UnitPrice money,@Quantity intSELECT @UnitPrice &#x3D; 单价,@Quantity &#x3D; 数量 FROM insertedUPDATE 销售单据明细表 SET 总价&#x3D;@UnitPrice * @QuantityWHERE 销售单据编号&#x3D;(SELECT 销售单据编号 FROM inserted) AND 商品编号&#x3D;(SELECT 商品编号 FROM inserted)在系统运行一段时间后，此表中有近一千万条数据。程序员在数据库中执行如下SQL语句：SELECT 商品编号,sum(数量) FROM 销售单据明细表 WHERE 单价&gt;200 GROUP BY 商品编号为提高此查询的执行效率，在不改变SQL语句的情况下，请给出提高查询执行效率的方案并阐明理由。对此表的插入操作速度很慢，请分析插入速度慢的原因，并在不改变数据库服务器硬件、不改变表基本结构、不清理数据的情况下，说明应如何优化此表的插入操作。 【参考答案】(1）在不改变SQL语句且不进行硬件调整的情况下，可以为销售单据明细表“商品编号”建立一个索引来提高查询的效率。另外如果只针对本条select语句进行优化，那么还可以使用分区表的方式，将单价按照&lt;&#x3D;200和&gt;200的关系分为两张表，也可以提高检索效率。(2）在一个插入或更新事务处理中，新建行被同时添加到INSERTED表和触发器表中。INSERTED表中行是触发器表中新行的副本。当表中有一千万条数据时，INSERTED表中也存储着大量的数据，而触发器要在INSERTED表中进行查询，所以插入的速度会很慢。可以通过删除INSERTED表中数据的方法来优化插入的速度,不会影响数据库服务器硬件、不改变表基本结构、不清理数据的情况下。或者(2)由题可知，该触发器名叫AutoCountSum，是后触发型触发器，引发触发器执行的操作是插入（insert）和更新（update）。该触发器执行时，会定义两个变量@UnitPrice和@Quantity，分别用来存储刚刚插入的单价和数量（因为是inserted表），并将销售单据明细表中对应记录的总价更新为@UnitPrice * @Quantity ，即单价*数量的值。触发器的缺点是会消耗系统资源，如果频繁触发，对系统性能影响将会非常大。根据题中描述，系统运行一段时间后表中有近一千万条数据，说明插入操作非常频繁，所以触发器是导致插入速度慢的直接原因。只需要使用存储过程来替代触发器即可解决此问题，优化此表的插入操作 第九套 备份设某超市经营管理系统使用SQL Server 2008数据库管理系统。为了保证数据库可靠运行，数据库管理员设置了每天夜间对数据库一次全备份，备份数据保留2个月的备份策略。上线运行1年后，SQL Server数据库中数据已经达到近200GB。每天夜间要运行3个小时才能将数据库进行一次全备份，影响了夜间统计等业务正常运行。同时，备份空间也非常紧张。请解释出现此现象的原因，并提出优化的方法。(10分) 产生此现象的原因是系统采用了全备份策略，随着业务的开展，需要备份数据量逐渐增大，备份时间越来越长，占用了系统的资源，从而影响了其它业务。解决的方法是采用全备份+差异备份+日志备份组合策略备份数据库。全备份+差异备份+日志备份组合策略是指在全备份中加—些差异备份，比如每周日0:00进行一次全备份，然后每天0:00点进行一次差异备份，然后再两次差异备份之间增加一些日志备份。这样做备份和恢复的速度都比较快，而当系统出现故障时，丢失的数据也很少。备份示意图如下:目志备份1目志备份2日志备份3目志备份4全各份1差异各份1差异各份2周o:oo12:0018:00周一0:0o12:0018:00周二0:0o如果系统在周二的差异备份之前出现故障，则应首先尝试备份活动日志（(日志尾部)，然后再按顺序恢复全备份1，差异备份1，日志备份3和日志备份4，然后再恢复备份的尾部日志。如果尾部日志备份成功，则数据库可以还原到故障点。这种备份策略虽然备份频率高，但是备份时间短，占用的备份空间也小，而且不会产生数据丢失。【解题思路】全备份(Full Backup)就是对整个系统进行完全备份，包括系统和数据。这种备份方式的好处就是很直观，容易被人理解，当数据丢失时容易恢复。然而它也有不足之处:首先由于每天都对系统进行完全备份，因此在备份数据中有大量重复的，这些重复的数据占用大量的存储空间;其次，由于需要备份的数据量相当大，因此备份所需的时间比较长。差异备份(Differential Backup)就是每次备份的数据是相对于上一次全备份之后增加和修改过的数据。它以前一次全备份为基准点，备份全备份之后变化的数据文件、日志文件以及数据库中其它被修改的内容。因此，差异备份通常比全备份占用的时间小且执行速度快，带回增加备份的复杂程度。日志备份(Log Bakup) :日志备份并不备份数据库本身，它只是备份日志记录，从而只备份上次备份之后到当前备份时间发生变化的日志内容。-般情况下，日志备份比完整备份和差异备份使用的资源少，因此可以更频繁的使用日志备份，以减少数据丢失的风险。全备份+差异备份+日志备份组合策略组合了三种备份方式的优点，可以缩短备份时间、节约备份空间，提高备份的效率。 第十套设某社交网站使用SQL Server 2008数据库管理系统，上线运行1年后，用户操作速度明显变慢，数据库服务器负荷很高。经技术人员分析，发现速度缓慢的原因为用户频繁访问网站，查看自己是否有新消息。某工程师建议利用数据库复制技术将相关数据表定期（例如1分钟)分发到另外一台服务器的只读数据库中，以便用户查询使用。请从数据─致性、用户体验、可扩展性三个方面逐一分析此方案优劣。说明此方案是否可行，并简要给出理由。 优点:该方案能满足数据一致性。因为利用数据库快照复制技术，可以将相关表分发给另外一台服务器，可以满足数据的一致性。数据的更新可以采用自动更新和手动更新方式。更新时间可以在建立分发数据库时设置，设置时间小于1分钟。通过这种方式可以满足用户体验。数据库的分发只是在软件层面进行，对于已经建好的发布和定阅可以直接用delete按钮删除，然后重新进行设置，可扩展性强。缺点:增加了一台服务器的开销。对于本题，该方案可行。存放网站系统的服务器被设为发布服务器，另外一台服务器可以作为分发服务器和订阅服务器。发布服务器以事务复制的方式向分发服务器发送信息。客户端通过订阅服务器获取数据，实现信息同步更新。这种方式不会影响网站系统服务器的运行，又能保证客户端可以随时刷新信息。【解题思路】SQL Server主要采用发布、分发、订阅的方式来处理复制。源数据所在的服务器是发布服务器，复制发布数据。发布服务器把要发布的数据的所有改变情况复制到分发服务器，分发服务器包含一个分发数据库，可接收数据的所有改变，并保存这些改变，再把这些改变发给订阅服务器。SQL Server复制技术包括快照复制、事务复制和合并复制。快照复制:发布服务器会定时向订阅服务器传送数据，如果订阅服务器修改过数据，定时传递后订阅服务器的数据修改会全部丢失，全部以发布服务器为准。事务复制:发布服务器会定时检查数据是否有修改过，如果有则向订阅服务器传送数据（记录行级)。合并复制:发布服务器与订阅服务器可以独立修改，会定时合并。 【康解释】 第十二套 分割表 分区表设某超市经营管理系统使用SQL Server 2008数据库管理系统，上线运行一年后，用户反映速度缓慢。经技术人员分析，发现速度缓慢的原因为销售单据表和销售单据明细表数据量巨大，当进行这两个表相关查询时就会造成SQL语句执行缓慢。已知这两个表结构如下：销售单据表(销售单据编号，付款总金额，销售时间，销售人员编号，收银台编号)，销售单据明细表(销售单据编号，销售时间，商品编号，单价，数量，总价)从业务上看，程序经常会查询1个月内和最近6个月内销售相关数据。为了保证系统稳定运行，两位工程师分别给出了两种优化方案：甲工程师：按照销售时间将两张表分别拆分为每月一张表，在系统进行查询时按照给定条件到相关的表中直接查询，降低查询涉及到的数据。乙工程师：使用SQL Server 2008的分区功能，将两张表变为分区表，按照销售时间每年一个分区，降低查询涉及到的数据。请从程序修改的难易程度、查询1个月内数据的执行速度、查询最近6个月内数据的执行速度3个方面比较甲乙工程师方案。根据上述分析结果，请基于甲乙工程师的方案给出最合理的优化方案并说明理由。 【康解释】表分割对于所有的数据库都适用，而表分区只能用于特定的数据库;表分区属于数据库物理设计，表分割属于逻辑设计。从程序修改的难易程度：甲工程师易于实现。查询1个月内数据的执行速度：甲工程师速度快查询最近6个月内数据的执行速度：乙工程师快 采用乙工程师的优化方案比较好。因为分区表的特点是∶如果数据量大，而且数据是分段的，而且对不同段的数据使用的操作不同，则适于使用分区表。本题中对表中当前月的数据，经常进行的操作是添加、修改、删除和查询，而对于以往的数据，则几乎不需要操作，或者操作仅限于查询，那么就可以按月份对表进行分区，从而提高系统的执行效率。 第十六套 触发器 临时表某学校图书管理系统保存了能够借书的教师数据，该数据来源于人事系统(另一家开发商开发)的教师数据。现需要将教师数据自动同步到图书管理系统中，教师数据总计约1万条，每天数据修改量约20条。为了实现自动数据同步，图书管理系统新上线了一数据同步程序。在同步程序上线后，数据库管理员发现每天数据备份量大幅度增加，尤其是数据库日志大幅度增加。经核查，该数据同步程序操作为每10分钟将所有从人事系统中同步的数据删除，而后将数据重新插入。现需要对同步程序进行优化，某工程师提出了两套方案： ①在人事系统相关表中新增触发器，提取新增数据到增量数据表，同步程序每10分钟将增量数据表中数据同步至图书管理系统中。 ②在图书管理系统中新建一临时数据库，在其中新增与人事系统结构相同的表，同步程序每10分钟将人事的数据传输到图书管理系统对应表中，在图书管理系统数据库中使用SQL语句对比图书管理系统数据，获取增量后修改图书管理系统数据。请从对人事系统影响、对图书管理系统影响、系统整体运行效率、相关开发人员协调复杂度四方面比较两套方案，并给出理由。 使用方案①，如果数据量大时会影响人事系统的运行，但对图书管理系统影响不大，系统整体运行效率能提高，相关开发人员协调复杂度也小。而使用方案②会影响人事系统和图书管理系统的运行，也会增加系统的开销，相关开发人员协调的复杂度，比方案①低。总体而言，方案①优于方案②。原因是在方案①中，只有在触发器设计时需要相关人员协调，数据量大时可能会影响人事系统的运行，而方案②只有在开发人员协调的复杂度比方案①低以外，总体来说会增加图书管理系统的开销。因为新建的数据库会占用系统的开销，影响系统整体运行的效率。【解题思路】触发器是―种特殊的存储过程，其特殊性在于它不需要由用户来直接调用，而是对表中的数据进行UPDATE、INSERT和DELETE操作时自动触发执行的。触发器通常用于保证业务规则和数据完成性，其主要优点是用户可以用编程的方法来实现复杂的处理逻辑和商业规则，增强了数据完整性约束的功能。触发器通常用在下列场合:完成比CHECK约束更复杂的数据约束，为保证数据库性能而维护的非规范化数据，可实现复杂的商业规则，触发器也可以评估数据修改前后的表状态，并根据差异采取对策。在方案①中，只有在触发器设计时需要相关人员协调，数据量大时可能会影响人事系统的运行，但是总体而言是比方案②优秀的。 【康解释】 方案1，在数据量大时会影响人事系统相关表的运行，但对图书管理系统影响不大，系统的整体效率会提高，相关开发人员协调复杂度小 方案2，会影响人事系统和图书管理系统的运行，新建数据库会增加系统的开销，影响系统整体运行效率，相关人员协调的复杂度相比较方案1，更低 综上所述，方案1优于方案2.因为而方案2仅仅在开发人员协调的复杂度比方案1低 第十九套 索引 A-S架构在SQL Server 2008数据库中存在销售单据明细表，其建表语句为：CREATE TABLE 销售单据明细表( 销售单据编号 varchar(8), 商品编号 varchar(8), 单价 money, 数量 int, 总价 money);在系统运行一段时间后，此表中有近千万条数据，程序员在数据库中执行如下SQL语句： SELECT 商品编号, sum(总价) FROM 销售单据明细表 WHERE 单价 &gt; 50 GROUP BY 商品编号为提高此查询的执行效率，需在此表中建立索引，请给出建立索引的方案。为了提高系统的可靠性和性能，某工程师提出将原有单机运行的SQL Server 2008改为Active-Standby架构的数据库运行模式：在不考虑硬件性能提升因素的前提下，请分析此架构是否能够提高系统的性能和可靠性，并说明原因。 本题考查的是索引相关知识，如索引定义，在什么地方建立索引，建立索引的条件等等，以及Active-Standby架构的数据库运行模式的机制。 (1)【参考答案】CREATE UNIQUE CLUSTERED INDEX ix_商品编号on销售单据明细表(商品编号)(2)【参考答案】此架构为数据库服务器容错架构，双机热备份方案中的双机热备模式。在不考虑硬件性能提升因素的前提下，此架构是能够提高系统的性能和可靠性，原因:双机热备份技术是一种软硬件结合的较高容错应用方案。该方案是由两台服务器系统和一个外接共享磁盘阵列柜及相应的双机热备份软件组成。在这个容错方案中，操作系统和应用程序安装在两台服务器的本地系统盘上，整个网络系统的数据是通过磁盘阵列集中管理和数据备份的。数据集中管理是通过双机热备份系统，将所有站点的数据直接从中央存储设备读取和存储，并由专业人员进行管理，极大地保护了数据的安全性和保密性。用户的数据存放在外接共享磁盘阵列中，在一台服务器出现故障时，备机主动替代主机工作，保证网络服务不间断。 (2) Active-Standby架构的数据库运行模式双机热备特指基于高可用系统中的两台服务器的热备(或高可用)，因两机高可用在国内使用较多，故得名双机热备，双机高可用按工作中的切换方式分为:主-备方式(Active-sStandby方式)和双主机方式(Active-Active方式)，主-备方式即指的是一台服务器处于某种业务的激活状态(即Active状态)，另一台服务器处于该业务的备用状态(即Standby状态)。而双主机方式即指两种不同业务分别在两台服务器上互为主备状态(即Active-Standby和Standby-Active状态)。双机热备有两种实现方式，一种是两台服务器通过一个共享的存储设备（一般是共享的磁盘阵列或存储区域网SAN)，通过安装双机软件实现双机热备，称为共享方式。另一种方式是没有共享的存储设备，数据同时存放于各自服务器中，称为纯软件方式或软件同步数据方式。基于存储共享的实现方式是双机热备的最标准的方案，在主从模式工作中，两台服务器以一个虚拟的IP地址对外提供服务，服务请求发送给主服务器(active server) 承担。同时，两台服务器通过心跳线(heartbeat line)侦测另一台服务器的工作状况。一旦主服务器出.见故障，备服务器(standby server)根据心跳侦测的情况做出判断，在较短时间内完成切换，接管主机上的所有资源，成为新的主服务器。由于使用共享的存储设备，因此两台服务器使用的实际上是一样的数据，由双机或集群软件对其进行管理。"},{"title":"『SQL Server』考二","date":"2022-07-18T11:08:39.099Z","url":"/posts/sqlserver2/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"没有8，9，至10（含） 第一套商品表（商品号，商品名，单价）销售表（销售单据号，商品号，销售时间，销售数量，销售单价）。商品号，单价，销售数量，销售单价均为整型请编写查询某年某商品的销售总毛利的存储过程，毛利&#x3D;销售数量（销售单价-单价）要求商品号和年份为输入参数，总毛利用输出参数返回。CREATE PROC p_name @商品号 int,@年份 int,@毛利 int outputASDECLARE @销售量 int,@单价 int,@销售单价 intBEGINSELECT @单价 &#x3D; 单价 FROM 商品表 WHERE 商品号&#x3D;@商品号SELECT @销售单价&#x3D; 销售单价, @销售量&#x3D; sum(销售数量)FROM 销售表 WHERE@商品号&#x3D;商品号 AND 销售时间&#x3D;@年份IF @单价 IS NULL THEN &#x2F;有？&#x2F; ROLLBACK; RETURN;END IFIF @销售单价 IS NULL THEN&#x2F;卖？&#x2F; ROLLBACK; RETURN;END IFSET @毛利&#x3D;(@销售单价-@单价)@销售量end 第二套在SQL Server 2008中，设某数据库中有商品表（商品号，商品名，进货价格)，商品号为主码;销售表（商品号，销售时间，销售数量，销售价格，本次利润)，商品号和销售时间为主码，销售价格为本次销售商品的单价。现要求每当在销售表中插入前4列数据时（假设—次只插入一行数据)，系统自动计算本次销售产生的利润，并将该利润赋给销售表的第5列”本次利润”。请编写实现上述功能的后触发型触发器代码。(10分)CREATE TRIGGER tri_name ON 销售表 FOR INSERT AS DECLARE @进价 money, @销量 int,@售价 money,@利润 money SElECT @进价 &#x3D; 进货价格 FROM 商品表 SELECT @销量 &#x3D; 销售数量,@售价 &#x3D; 销售价格 FROM inserted SET @利润 &#x3D; @销量*(@售价-@进价) UPDATE 销售表 SET 本次利润 &#x3D; @利润 WHERE 商品号 IN(SELECT 商品号 FROM inserted) AND 销售时间 IN(SELECT 销售时间 FROM inserted)END 第三套设在SQL Server 2008某数据库中，已建立了四个文件组: fg1、fg2、fg3和fg4，以及一个分区函数RangePF1。RangePF1的定义代码如下:CREATE PARTITION FUNCTION RangePF1(int)AS RANGE LEFT FOR VALUES(100,200,300)(1)请基于RangePF1创建一个分区方案RangePS1，每个分区对应一个文件组。(5分)(2）请使用RangePS1创建一个分区表PartitionT(Gid, GoodName, Price)，该表基于Gid列创建分区。其中Gid: int类型，取值大于等于1; GoodName:统一字符编码可变长类型，最多可存储20个汉字;Price:定点小数类型，小数部分1位，整数部分到千位。(5分)[][创建分区方案 方案名 as 分区 函数名 to （文件组）][][CREATE TABLE tb_name （）on 方案名（Gid）]1:create partition scheme RangePS1as partition RangePF1to(fg1,fg2,fg3,fg4)2:create table orders(GID int identity(1,1) primary key,GoodName varchar(40),Price numeric(5,1))on RangePS1(GID) 第五套设有图书管理数据库，包含三张表:图书明细表(图书编号，图书类别，图书名称，作者，出版社，出版日期，定价);读者表（借书证号，姓名，系别，办证日期);借出信息表（借出编号，借书证号，图书编号，借书日期);完成下列操作:(10分)定义一个多语句表值函数，用于查询学生借书情况，只需提供参数:借书证号，就可以通过调用函数返回此学生的借书情况，若有借书籍，则返回所借书籍的编号、书籍名称、定价和借书日期;若没有在借书籍，则返回记录为空。设函数名为: f_BorrowBook(@jszh char(20))。 CREATE FUNCTION f_BorrowBook(@jszh char(20))RETURNS @jsqkb TABLE(书籍编号 char(20),书籍名称 char(50),定价 float,借书日期 datetime)ASBEGININSERT INTO @jsqkbSELECT图书明细表.图书编号,图书名称,定价,借出信息表.借书日期 FROM 借出信息表,图书明细表WHERE 借出信息表.图书编号&#x3D;图书明细表.图书编号 AND 借出信息表.借书证号&#x3D;@jszhRETURNEND 第七套BORROWER：借书证号 姓名 系名 班级12011106 张三 计算机 12-112011107 李四 计算机 12-112012113 王五 语文 12-2 LOANS??借书证号 图书馆登记号 借书日期12011106 T001001 2012.01.0212012113 T001026 2013.02.06 BOOKS??索书号 书名 作者 图书登记号 出版社 价格TP311.1 数据库 李明 T001001 人民 19.00TP311.2 二级C语言 王珊 T001026 科学 32.001.检索至少借了五本书的同学借书证号，姓名，系名，借书数量2.检索借书和王五同学所借图书的任意一本相同的学牲姓名，系名，书名和借书日期SELECT LOANS.借书证号,姓名,系名,COUNT() AS 借书数量FROM BORROWER,LOANSWHERE BORROWER.借书证号&#x3D;LOANS.借书证号GROUP BY LOANS.借书证号,姓名,系名HAVING COUNT()&gt;&#x3D;5; SELECT 姓名,系名,书名,借书日期FROM BORROWER,LOANS , BOOKSWHERE BORROWER.借书证号&#x3D;LOANS.借书证号 AND LOANS.图书馆登记号&#x3D;BOOKS.图书馆登记号AND 索书号 IN(SELECT 索书号 FROM BORROWER,LOANS,BOOKSWHERE BORROW.借书证号&#x3D;LOANS.借书证号AND LOANS.图书馆登记号&#x3D;BOOKS.图书馆登记号AND 姓名&#x3D;”王五”)group by 姓名,系名,书名,借书日期having 姓名 !&#x3D;’王五’ ??????????????????????????????????????塢?????????????????? ?洢????CREATE TABLE 商品表(商品号 char(10) PRIMARY KEY,商品名 varchar(40),类别 varchar(20),进货单价 int,销售总量 int default 0)CREATE TABLE 销售表(商品号 char(10) REFERENCES 商品表(商品号),销售时间 datetime,销售数量 int,销售单价 int,PRIMARY KEY(商品号,销售时间))9.12.创建存储过程:指定类别的每种商品今年的销售总数量 8.11.创建存储过程:指定类别的每种商品今年的销售总金额 13.创建存储过程:指定类别的每种商品去年的销售总数量 17.创建存储过程:指定日期范围每种商品的销售总数量,包括未销售的商品. 19.创建存储过程:指定商品号的商品销售总数量 14.创建存储过程:指定类别的每个商品的销售总利润,包括未销售的(值为0) 16.标量函数:指定商品号返回销售总金额 4.多语句表值函数: 返回类别参数的每种商品在2012年的销售总利润,并降序输出 10.6.多语句表值函数：统计指定年份中每个商品的销售总额 15.18.创建触发器:每当在销售表中插入一条销售记录, 修改商品表中对应商品的销售总量 第二十套CREATE TABLE 出租表(房屋号 char(10),出租日期 datetime,租期 int not null, –月数到期日期 datetime,PRIMARY KEY(房屋号,出租日期));创建触发器:每当在出租表插入一行数据(房屋号,出租日期,租期),自动计算到期日期CREATE TRIGGER tri ON 出租表 FOR insertASupdate 出租表 SET 到期日期 &#x3D; dateadd(month,租期,出租日期)WHERE 房屋号 &#x3D; (SELECT 房屋号 FROM inserted )and 出租日期&#x3D;(select 出租日期 from inserted) ?????????????? ????????洢????create table 房屋表(房屋号 char(10) primary key,房屋地址 char(20) not null,面积 int,月租金 int)create table 租贷表(房屋号 char(10),租贷日期 datetime,租贷月数 int not null,本次总租金 int,primary key(房屋号,租贷日期),foreign key(房屋号) references 房屋表(房屋号))创建触发器:每当在租贷表插入一行数据（房屋号，租贷日期，租贷月数），计算本次月租金 创建存储过程：输入房屋号，计算历史租金总和 "},{"title":"『SQL Server』第十二章  备份与恢复数据库","date":"2022-07-17T01:14:49.694Z","url":"/posts/sqlserver12/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第十二章 备份与恢复数据库1.恢复数据库:类型:介质故障恢复非介质故障恢复模式:简单恢复模式完整恢复模式大容量日志恢复模式2.备份数据库:数据库备份:完整数据库备份 钟情master,支持还原单个页,数据更改不频繁,量不大 差量数据库备份 文件备份:文件备份 差异文件备份 事务日志备份完整数据库备份:完全转储:数据库+日志 差量转储:日志备份:纯日志备份：间隔一段时间的事务日志，不包含大容量日志 不可以first备份 大容量操作日志备份，不可以进行时间点恢复 结尾日志备份：出现故障时进行，防止丢失数据，可包含上两种1.备份的T-SQL语句:backup database db_name to 设备 with init(覆盖原有内容)…事务日志备份则使用log2.恢复的T-SQL语句:restore database db_name from 设备 简单恢复模式：无日志备份。完整恢复模式：有日志备份大容量日志恢复模式：有日志备份，完整恢复模式的附加模式 BACKUP DATABASE db1 TO budb1 WITH DIFFERENTIAL,NOINIT对数据库db1进行依次差异备份，被分到budb1设备上，保留该设备已有内容"},{"title":"『SQL Server』第九章  安全管理","date":"2022-07-17T01:14:49.689Z","url":"/posts/sqlserver09/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"题1: 设 log1 是身份验证模式的数据库服务器登录账户，现在要授予该账户创建数据库的权限，请补全下列语句：EXEC sp_addsrvrolemember ‘log1’, ‘____’解析1:数据库主要的固定服务器级角色及权限如下表: bulkadmin 执行 BULK INSERT 语句 dbcreator 创建修改删除和还原数据库对象√ diskadmin 管理磁盘文件 processadmin 管理运行的进程 serveradmin 配置服务器范围 setupadmin 增删链接服务器 sysadmin 系统管理员√ securityadmin 管理服务器登陆账户 例2: 只具有修改数据库全部用户表数据权限的系统角色是____解析2: 下表是服务器级角色 db_owner 创建数据量对象; 配置,维护,删除数据库 db_accessadmin 增删用户 db_backupoperator 备份恢复数据库和日志 db_datareader 只读 db_datawriter 增删改 db_ddladmin 执行数据定义语言(DDL) db_denydatareader 不可读 db_denydatawriter 不可增删改 db_securityadmin 管理数据库角色,角色成员以及数据库中语句和对象的权限 public 默认角色 对数据的访问是通过SQL server 的权限层次结构管理的.通过以下三种语句来管理这个权限层次结构.用户 u1 在 数据库 db1 的查询表 t1 的权限, 此权限用户可以转授GRANT SELETE ON db1(t1) TO u1 WITH GRANT OPTION收回用户 u1 对表 t1 的数据更改权REVOKE UPDATE ON t1 FROM|TO u1 CASCADE拒绝用户 u1 对表 t1 的删除权限DENY DELETE ON t1 TO u1 用户 u1 在数据库 db1 中有建表权限GRANT CREATE TABLE ON db1 TO u1收回用户 u1 对数据库 db1 的创建视图权限REVOKE CREATE VIEW FROM u1美国国防部对强制存取控制的分级为:验证保护,强制保护,自主保护,最小保护,分别为ABCD级别.yqzz 有气质罪 DROP USER u1CREATE LOGIN l1 WITH PASSWORD&#x3D;’a123’DROP LOGIN l1ALTER LOGIN u1 ENABLE"},{"title":"『SQL Server』第二章  需求分析","date":"2022-07-17T01:14:49.684Z","url":"/posts/sqlserver02/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第二章 需求分析需求分析需求分析的概念与意义 概念:系统要”干什么”需求获取的方法需求分析过程需求分析方法 结构化分析与建模方法 面向对象分析与建模方法需求分析方法概述DFD需求建模方法其他需求建模方法DFD与IDEF-0比较 "},{"title":"『SQL Server』第八章  数据库后台编程技术","date":"2022-07-17T01:14:49.678Z","url":"/posts/sqlserver08/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第八章 数据库后台编程技术存储过程 创建:create proc proc_name @var type,@var1 type output as begin sql_statement end 执行:exec proc_name @var&#x3D;函数 分类:标量函数:create function fun_name(@var type) returns type as begin sql_statement endCREATE FUNCTION 表(@总价 char(10))RETURNS INT ASBEGINRETURN(SELECT…)END 表值函数:内嵌表值函数:create function fun_name(@var type) returns table as begin return(sql_statement) end 多语句表值函数:create function fun_name(@var type) returns @tb_name table(col_name) as begin sql_statement return end触发器 创建:create trigger tri_nameon tb_name&#123;for | instead of&#125; &#123;insert | update | delete&#125;asbeginsql_statementend 游标 声明:declare cur_name cursor for sql_statement 打开:open cur_name 提取:fetch first | last | next | prior | absolute n | relative nfrom cur_name into 变量名 关闭:close cur_name 释放:deallocate cur_name 全局变量:@@fetch_status create proc p1…调用:exec p1 default,20"},{"title":"『SQL Server』第一章  数据库应用系统开发方法","date":"2022-07-17T01:14:49.667Z","url":"/posts/sqlserver01/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第一章 数据库应用系统开发方法DBS:DBAS:DBAS生命周期(即数据库应用系统生命周期):规划与分析系统规划与定义 任务陈述 确定任务目标 确定范围与边界 确定用户视图可行性分析 技术, 经济, 操作可行性 开发方案选择项目规划 项目环境 项目团队 项目活动 项目成本预算 项目进度计划需求分析:第二章会涉及 系统需求 DFD:数据流(数据的流入流出)(箭头)处理(数据变换)(矩形框)数据存储(存储数据的地方)(圆角矩形框)外部项(数据的来源和去处)(圆角框) 数据需求分析 功能需求分析:数据处理&#x2F;业务规则 性能需求分析:响应时间,吞吐量,并发访问用户数,tps代价值 其他需求分析:安全:防止被非法用户攻击存储:数据总量系统设计:第三章会涉及 概念设计：自下而上的E-R图设计 逻辑设计：完成数据库关系模式的设计，设计视图和关系模式的完整性约束 物理设计：将关系模式转换成具体的关系表实现与部署: 建立数据库结构 数据装载(数据加载) 事务和应用程序的编码及测试 系统集成 测试与运行 系统部署运行管理与维护:第十章会涉及 日常维护:备份恢复,完整安全性维护,存储空间管理,并发控制 系统监控与分析 系统性能优化调整 系统进化升级 数据完整性：实体完整性：primary key参照完整性：foreign key。。。references用户自定义完整性：not null，unique，check 项目规划 需求分析 系统设计 实现和部署 运行管理与维护 项目规划： 规划与分析 ⬇ 需求分析： 数据项分析 数据流与事务分析 程序需求分析 ⬇ ⬇ 概念模式设计 系统总体设计 系统设计： ⬇ ⬇ ⬇ 逻辑模式设计 事务概要设计 程序概要设计 ⬇ ⬇ 物理模式设计 事务详细设计 程序详细设计 ⬇ 系统实现和部署： 系统实现 数据转换与加载 系统测试，部署与交付 ⬇ 系统运行管理与维护： 系统运行维护 "},{"title":"『SQL Server』第五章  UML与DBAS","date":"2022-07-17T01:14:49.661Z","url":"/posts/sqlserver05/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第五章 UML与DBAS用例模型表达了系统的(功能)需求,在外部,用例在内部用例视图: 用例视图, 描述系统的功能行为视图: 顺序图, 交互图和状态图, 描述系统的活动部署视图: 描述物理部署情况 业务流程与需求表达 活动图 用例，系统和程序模块 业务流程与需求表达 用例图 用例，系统和角色 系统内部结构 类图 类，接口和协作以及它们之间关系 系统内部结构 顺序图 用例任务流的先后执行或并列次序（消息发送和接收序列） 系统内部结构 通信图 表达一系列的对象及其之间关系，即如何链接到一起，对象在空间中如何交互 系统微观设计 对象图 类图的实例（快照）（静态视图） 系统微观设计 状态机图 发生事件后的状态变化情况 系统微观设计 时间图 时间驱动 系统宏观设计 包图 松耦合高内聚 交互概述图 活动图和顺序图嫁接 复合结构图 系统和系统的接口 系统实现与部署 组件图 源代码，可执行程序 部署图 硬软件物理配置 "},{"title":"『SQL Server』第四章  应用系统功能设计","date":"2022-07-17T01:14:49.656Z","url":"/posts/sqlserver04/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第四章 应用系统功能设计1.总体设计:确定系统总体框架DBAS体系结构设计::C&#x2F;S体系结构:B&#x2F;S体系结构:表示层应用服务器端:业务规则数据库服务器端:事务处理软件体系结构设计:OS,DBMS,开发环境,中间件,应用软件(事务和应用程序)软件硬件选型与配置设计:合理选择,初步配置(存储备份方案,开发语言工具,中间件及软件选型)业务规则初步设计:(业务流程图)2.概要设计:表示层:业务逻辑层:梳理业务.存储过程:数据访问层:提取数据操作事务:数据持久层:数据的组织存储3.详细设计"},{"title":"『SQL Server』第十章  数据库运行管理与维护","date":"2022-07-17T01:14:49.651Z","url":"/posts/sqlserver10/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第十章 数据库运行管理与维护及其优化1.运行维护工作:日常维护:数据库转储与恢复,数据库安全性完整性控制：新建数据库用户,存储控空间管理,并发控制系统监控与分析系统性能优化调整系统进化升级数据库的重组和重构2.运行状态监控:构架体系(即数据库存储空间管理) 性能:数据库运行环境:外部调整:CPU和网络 内存 磁盘I&#x2F;O 减少竞争 参数调整 模式调整:反规范化:(派生)冗余,组新表,分割表,增汇总表 存储优化:建立索引视图和聚集 查询优化:使用:索引,临时表,存储过程 避免:排序,顺序存取,避免正则表达式,外连接,游标,大事务 实现死锁检测的是什么图? (事务等待)图事务的acid特性:原子性：保持一致性，要么做，要么不做，必须全部反映与否一致性：没有其他并发执行的事务，不做就好像从未发生过 隔离性:其正在访问的数据却被其他进程修改持久性：已提交的事务必须能正确写入，对数据库的改变是永久的当数据库系统中存在死锁时,通常选择1个或几个死锁事务,怎么样这些事务(撤销) 一起查询的表，可以聚集文件分组排序的表，可以散列文件，不适用于范围查询 使用索引的原则：经常搜索，连接，范围搜索，排序，where子句的列主键 "},{"title":"『SQL Server』第十一章  故障管理","date":"2022-07-17T01:14:49.646Z","url":"/posts/sqlserver11/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第十一章 故障管理 数据库故障类型:事务内部故障:预期的事务内部故障:事务回滚 非预期的事务内部故障:系统自主完成系统故障:软故障,系统停止运行。undo所有已提交的事务,redo所有未提交的事务计算机病毒故障:防火墙,杀毒软件,备份介质故障:硬故障:软件容错:备份与恢复技术硬件容错:数据库镜像 数据库的恢复:数据转储:静态转储动态转储动态转储+日志文件数据转储分类:完全转储 差量转储 增量转储完全转储对所有数据进行转储，需要时间空间多差量转储只是对上次完全转储后的进行转储，需要时间和空间较之完全转储会少，增量转储对上次转储后的文件或数据块进行转储，需要的时间和空间较之差量转储更少。但增量转储的恢复需要与完全转储相配合，因此恢复时间最长登记日志文件日志文件：记录所有事务的修改操作,分为以记录为单位和以数据块为单位检查点:大幅度减少完全恢复时需要执行的日志部分，提高系统出现故障时的恢复效率 硬件容错方案数据库存储保护技术:raid,服务器容错技术,双机热备数据库镜像与容灾技术:双机热备份模式,双机互备援模式高可用,高保护,高性能操作模式 "},{"title":"『SQL Server』第十四章  数据仓库与数据挖掘","date":"2022-07-17T01:14:49.641Z","url":"/posts/sqlserver14/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第十四章 数据仓库与数据挖掘1.数据仓库(1) 特性:面向主题:设计方法集成:数据的抽取,转换,（清洗），装载不可更新随时间变化粒度:粒度与综合程度成正比元数据:技术型和业务型维护:实时延时和快照维护增量维护(2) 设计方法:自底向上,自顶向下2.OLAP:即时OLAP,全局OLTP基本操作:钻取,卷起切片和切块,旋转多维molap,关系rolap,混合 holap3.数据挖掘(1) 方法:关联规则挖掘：支持度和置信度分类挖掘:监督学习,知道怎么分,样本集,训练集,测试集,验证集:分类算法,分类器聚类挖掘:无监督学习靠系统分析分类,K-means:同一集合尽可能大,不同尽可能小时间序列分析4.知识发现步骤:数据准备,数据挖掘,结果的解释评估 目录1 基本概念2 决策支持系统(DSS)的发展2.1 基本概念2.2 基于数据仓库的决策支持系统3 数据仓库技术概述3.1 数据仓库的概念和特性3.2 数据仓库的体系结构和环境3.3 数据仓库的数据组织3.4 元数据3.5 操作型数据存储4 设计与建造数据仓库4.1 数据仓库设计的需求与方法4.2 数据仓库的数据模型4.3 数据仓库设计步骤5 数据仓库的运行与维护5.1 数据仓库数据的更新维护5.2 数据仓库监控与元数据管理6 联机分析处理(OLAP)与多维数据模型6.1 基本概念6.2 多维分析的基本操作6.3 OLAP的实现方式7 数据挖掘技术7.1 数据挖掘的步骤7.2 常见的数据挖掘任务1 基本概念数据仓库技术所解决的问题是如何更合理和更有效的组织企业的数据体系，以更好地满足企业信息型应用对数据的要求，降低对企业的数据管理、数据获取和数据集成的成本，提高数据系统响应速度，提高数据质量和数据的一致性。数据挖掘技术所解决的问题是如何针对具体的分析对象和分析需求，尝试通过智能和自动化的手段把数据转换为有用的信息和知识2 决策支持系统(DSS)的发展2.1 基本概念 操作性数据是指由企业的基本业务系统所产生的数据，操作性数据及相应数据处理所处的环境，即用于支持企业基本业务应用的环境使用DSS的目的是为了增加决策的有效性，而不是为了提高做出决策的效率2.2 基于数据仓库的决策支持系统 这种体系结构以数据仓库为核心，数据仓库将企业决策支持所需的数据集成在一起，构成一个集成的、一致而稳定的数据源 存在两类数据 原始数据 一般来自于企业操作性系统，因此也可以称之为操作型数据 导出数据 为了提高数据查询和管理效率，根据操作型数据计算得到的数据，常用于支持分析型应用3 数据仓库技术概述3.1 数据仓库的概念和特性 建立数据仓库的主要目的是根据决策需求对企业的数据采取适当的手段进行集成，形成一个综合、面向分析的数据环境，用于支持企业的信息型、决策型的分析应用 四个特征 主题性 集成性 不可更新性 时间特性3.2 数据仓库的体系结构和环境 数据仓库的体系结构 操作型数据 操作型数据存储 数据仓库 数据集市 个体层临时数据 体系的功能 数据处理 数据管理 数据应用3.3 数据仓库的数据组织 数据分级别 早期细节级 当前细节级 轻度综合级 高度综合级 粒度 一般将综合级别称为粒度，粒度越大、表示综合程度越高，粒度越小，综合程度越低 粒度是一个重要的设计问题，它影响到数据仓库的数据量以及系统能回答的查询的数据类型 数据分区 数据分区问题是数据仓库的另一个重要问题，为了提高数据管理和查询的效率，分区是有效的办法 分区的方式 系统层分区 应用层分区3.4 元数据 是数据仓库中的重要数据，是关于数据的数据，或者叫做描述数据的数据 描述存储操作型数据的关系数据库的结构、位置、表的结构、表间关系及各种视图等的数据都是元数据 建立元数据的目的是主要在于让用户能更快地找到所需的数据，让前台工具和管理员更好地理解和管理数据 分类 技术型元数据 业务型元数据3.5 操作型数据存储 目的：为了支持一些特殊的应用功能 即时OLAP应用 全局型OLTP应用 在作为数据源的操作型系统与数据仓库之间存在着一个称为操作型数据存储的(ODS)的数据层 分类 ODS I第一类 数据更新频率是秒级 ODS II 第二类 数据更新频率是小时级 ODS III第三类 数据更新频率是天级 ODS IV第四类 不仅仅包括来自操作型环境的数据，也包括由数据仓库层和数据集市层的应用反馈给ODS的一些决策结果和一些报表信息4 设计与建造数据仓库4.1 数据仓库设计的需求与方法 数据仓库的设计 数据体系的设计 应用体系的设计 企业建立数据仓库的目的 实现大量的以数据仓库各层数据为基础的基本信息处理功能 设计方法 数据仓库的设计过程是按照一定的题域分别设计 数据仓库的设计过程是按逐个主题逐步建立的过程，那么就需要进行主题域选择 数据仓库系统设计目标主要在于建立主题数据环境，强调的是数据的集成性，目标在于建立一个全局的一致的数据环境，建立企业的信息资源体系结构的数据核心，并在此基础上，建立基本的觉得支持分析应用4.2 数据仓库的数据模型 概念模型 是用于描述客观世界中的对象及其属性的一种概念性工具 逻辑模型 物理模型4.3 数据仓库设计步骤 概念模型设计 技术评估与环境准备工作 逻辑模型设计 物理模型设计 数据生成与应用实现 数据仓库运行与维护5 数据仓库的运行与维护5.1 数据仓库数据的更新维护 维护的基本思路 根据某种维护策略，在 一定条件下出发维护操作 维护操作捕捉到数据源中的数据变化 通过一定策略对数据仓库中的数据进行相应的更新操作 维护策略 实时维护 延时维护 捕捉数据源的变化的方法 触发器 修改数据源应用程序 通过日志文件 快照比较法 导出数据的维护方法 一是根据维护对象的数据源对齐进行重新计算 二是根据数据源的变化量在维护对象原有数据的基础上进行数据添加和修改，即增量式维护5.2 数据仓库监控与元数据管理 数据仓库监控 元数据管理6 联机分析处理(OLAP)与多维数据模型6.1 基本概念 OLAP主要用于支持复杂的分析操作，侧重对觉得人员和高层管理人员的决策支持 数据的多维分析是针对数据仓库中以多维形式组织起来的数据，从多个角度、不同层次、采用各种数据分析技术、对数据进行剖析，以使用户能从不同角度和不同层次观察和分析数据6.2 多维分析的基本操作 钻取 切片 旋转6.3 OLAP的实现方式 MOLAP基于多维数据库的OLAP ROLAP基于关系数据库的OALP HOLAP混合型的OLAP7 数据挖掘技术7.1 数据挖掘的步骤 数据准备 数据挖掘 结果解释评估7.2 常见的数据挖掘任务 分类 估计 预测 相关性分组 关联规则 聚类 描述"},{"title":"『SQL Server』第十三章  大规模数据库架构","date":"2022-07-17T01:14:49.636Z","url":"/posts/sqlserver13/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第十三章 大规模数据库架构1.分布式数据库:物理上分散,逻辑上集中目标:本地自治,非集中式管理,高可用性(最基本特征) 位置独立性,分片独立性,复制独立性(分布透明性) 分布式查询,事务管理(复杂性) 数据分布:数据分片:水平,垂直,导出,混合 数据分配:集中,分割(更新事务),全复制(事务更新少,数据少),混合 体系结构:全局外模式 全局概念模式 分片模式 分配模式 局部概念模式 局部内模式 局部数据库2.并行数据库:结构:共享内存结构 共享磁盘结构 无共享结构 层次结构 数据划分与并行计算:合理划分可以使响应速度变化,处理性能更优数据划分:一维数据划分:轮转法:整个关系 散列法:点查询,连接查询,散列函数选择是关键点 范围划分法:范围查询,点查询数据分布不均匀 多维数据划分:MAGIC多维划分法 CMD多维划分法 BERD多维划分法 并行算法:并行排序 并行连接:划分连接,分片-复制连接 其他的关系操作:选择,除重,投影,聚集3.云数据库:服务类型:IaaS:将基础设施作为服务 PaaS:将平台作为服务SaaS:将软件作为服务 分布式查询:导致数据传输量大的主要原因是数据间的连接操作和 并 操作,半连接操作可用减少场地之间的数据传输量分布式事务管理:恢复控制:基于 两 阶段 的提交协议,协调者与参与者 并发控制:封锁协议:三级封锁协议 为了保证全局事务的原子性，参与事务执行的所有场地或者全部提交，或者全 回滚 &#x2F; 撤销 。两阶段封锁协议保证事务的调度可串行性第二节：并行数据库共享内存, 共享磁盘, 无共享, 层次结构数据划分与并行计算:合理划分可以使响应速度变化,处理性能更优:一维数据划分多维数据划分 轮转法；整体扫描 散列划分：根据A属性划分 范围划分：根据B属性取值区间第三节：云计算数据库架构云计算通过集中所有的计算资源，采用硬件 虚拟化 技术，为使用者提供强大的计算能力、存储和宽带等资源。第四节 ：XML数据库"},{"title":"『SQL Server』第三章  系统设计","date":"2022-07-17T01:14:49.629Z","url":"/posts/sqlserver03/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第三章 系统设计数据模型三个要素:数据结构:关联关系数据操作:增删改查数据完整性约束:完整性关系数据库的试图提供了逻辑数据独立性在衡量数据库应用系统的性能指标中,???指的是系统在单位时间内可以完成的数据库事务数量答案:系统吞吐量"},{"title":"『SQL Server』第七章  高级数据库查询","date":"2022-07-17T01:14:49.624Z","url":"/posts/sqlserver07/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第七章 高级数据库查询select [distinct top 3 [percent] with ties] col_nameinto ntb_nameform tb_namewheregroup byhavingorder bycompute函数:选择函数:case when then…else end日期函数:排名函数:rank:1 2 2 4 4 4 7dense_rank:1 2 2 3 3 3 4row_number:ntile:运算:union intersect except子查询:where col_name not in (select col_name…)where col_name not exists (select *…)any all开窗函数:over (partition by col_name)共用表表达式 with…as 自连接与外连接SELECT DISTINCT TOP 3 WITH TIES col_nameINTO new_tb_name FROM tb_nameWHERE…GROUP BY… HAVING…ORDER BYCOMPUTE"},{"title":"『SQL Server』第六章  数据库及其对象.md","date":"2022-07-17T01:14:49.618Z","url":"/posts/sqlserver06/","categories":[["SqlServer","/categories/SqlServer/"]],"content":"第六章 数据库及其对象数据库 分类:系统数据库:master:数据库系统信息 msdb:数据库作业信息 model:数据库模板信息 resource:只读数据库且不可见 tempdb:临时数据库 用户数据库:数据文件:主要数据文件:.mdf 次要数据文件:.ndf 日志文件:事务日志文件:.ldf 创建:create database db_name on primary (&lt;filespec&gt;) log on (&lt;filespec&gt;) 对&lt;filespec&gt;的解释:name=db_name_data, filename=&#39;C:\\db_name_data.mdf&#39;, size=3MB, maxsize={50MB|unlimited}, filegrowth={1MB|10%}要插入的表已存在: insert into t2 select * from t13. 修改:alter database db_name add file add log file modify name= modify file remove file4. 分离:exec sp_detach_db &#39;db_name&#39;,&#39;true&#39;5. 附加:6. 自增标识列:identity 架构(构架)(模式) 创建: create schema sc_name 可以共享分区表 创建:例:在分区列colA_name(int)上创建左侧分区函数. (1)创建分区函数:create partition function pf_name(int) as range left for values(1,10,100） (2)创建分区方案:create partition scheme ps_name as partition pf_name to (test1,test2,test3,test4) (3)使用分区建表:create table tb_name (col_name type… on ps_name(colA_name) 索引 创建:create [unique | [non]clustered] index idx_name on tb_name(col_name) [with fillfactor=x] 重复小列在前主索引为主键索引,辅索引提高查询效率,位图索引用于范围查询，哈希索引用于精确查询视图 索引视图来源必须是基本表,不适合建立在大量更新写操作高基数度的数据聚合(group by) 讲一起使用的公共列值的多个表的数据行存储在一起的方法称为聚集 设商品表有下列查询:SELECT 商品号,商品名,单价FROM 商品表 WHERE 类别 IN(‘食品’,’家电’)ORDER BY 商品号现建立索引:CREATE INDEX idx1 ON 商品表(商品号) # create unique index idx_name on tb_name(列名)INCLUDE(商品名,单价) # include(属性)WHERE 类别&#x3D;’食品’ OR 类别&#x3D;’单价’ # where 约束条件 将 t1 表的 c1 列 (int 类型)定义为标识列,初量和增量均为1CREATE TABLE t1(c1 INT IDENTITY(1,1),…) 直接增加已有文件的大小是扩大数据库空间的一种方法ALTER DATABASE db1 MODIFY FILE(NAME&#x3D;db_datafile,SIZE&#x3D;200MB) 数据库的分类分为系统数据库和用户数据库。系统数据库分为master，msdb，tempdb，model，resource，其分别保存系统信息，作业信息，临时信息，模板，只读，无法看到将数据库以文件形式保存。分为数据文件和日志文件。数据文件分为主要数据文件（mdf只要一个，≥3）和次要数据文件（ndf，n个）日志文件（ldf，≥1）数据库存储空间的分配：文件组：主文件组和用户文件组 一、创建及维护数据库1. SQL Server五个数据库 2 组成（1）数据文件 主要数据文件拓展名.mdf,要求不能小于3M，大于model数据库的大小次要数据文件拓展名.ndf（2）日志文件拓展名.ldf（3）数据库存储空间的分配在SQLServer中，数据的存储分配单位是数据页，一页是一块8KB&#x3D;（8060B+132B，8060是存放数据，132存放系统信息）的连续磁盘空间 3 数据库文件组（1）主文件组（2）用户定义文件组通过create DataBase 或 Alter DataBase 语句中使用Filegroup 关键字指定的任何文件组 4 数据库文件的属性 5 T-SQL创建数据库Create Database database_nameON Primary%指定主文件组(Name &#x3D;主文件名FileName &#x3D;操作系统物理文件名Size &#x3D; 文件的初始大小Maxsize &#x3D; 文件最大值FileGrowth &#x3D;指定文件的自动增量)LOG %指定日志文件(Name &#x3D;FileName &#x3D;Size &#x3D;Maxsize &#x3D;FileGrowth &#x3D;)FileGroup(Name &#x3D;FileName &#x3D;Size &#x3D;Maxsize &#x3D;FileGrowth &#x3D;) 6 修改数据库（1）扩大数据库空间 添加数据文件Alter DataBase database_nameADD File(Name &#x3D;FileName &#x3D;Size &#x3D;Maxsize &#x3D;FileGrowth &#x3D;)添加日志文件Alter DataBase database_nameADD LOG File(Name &#x3D;FileName &#x3D;Size &#x3D;Maxsize &#x3D;FileGrowth &#x3D;)指定要修改的文件Alter DataBase database_nameModify File(Name &#x3D;FileName &#x3D;Size &#x3D;Maxsize &#x3D;FileGrowth &#x3D;)（2） 收缩数据库空间 收缩整个数据库大小DBCC ShrinkDatabase(DataBase_name,20)20表示20%收缩指定文件大小DBCC ShrinkFIle(DataFIle_name,4)4表示4M（3）添加和删除数据库文件 添加文件(和创建数据库相同)ALter DataBase删除文件Alter DataBase database_nameRemove File datafile_name 7 分离和附加数据库1）分离数据库 Exec sp_detach_db ‘Database_name’,’True’True表示跳过更新统计信息（2）附加数据库Create DataBase database_nameON(FIlename&#x3D;’’For Attach) 二、架构1 概念是数据库下的一个逻辑命名空间，可以存放表、视图等数据库对象，是一个数据库对象的容器 2 定义架构Create Schema schema_name Authorization user_name 3 删除架构Drop Schema schema_name Cascade|RestrictCascade：删除架构的同时将架构中的所有架构对象一起全部删除Restrict：如果被删除的架构中包含架构对象，则拒绝删除 三、分区表1 概念是将表中的数据按水平方式划分成不同的子集，这些数据子集存储在数据库的一个或多个文件组中。使用分区可以快速且有效地管理和访问数据子集，从而使大型表或索引更易于管理 2 创建分区表（1）条件 如果表中有大量的数据都是经常使用的数据，而且她们的操作方式基本一样的，则最好不要使用分区表如果数据量大，而且数据是分段的，并且对不同段的数据使用的操作不同，则适用于使用分区表（2）步骤创建分区函数Create Partition Function partition_function_name(input_type)AS Range [ Left |Right] For Values(1,100,1000)12最后的数值表示分区指定边界值，表示四个分区 创建分区方案Create Partition Schema partition_schema_name As Partition partition_function_name [All] To (test1fg,test2fg,test3fg,test4fg)1使用分区方案创建表Create Partition Function myRangePF1(int)AS Range Left For Values(1,100,1000)GoCreate Partition Schema myRangePS1 As Partition myRangePF1 To (test1fg,test2fg,test3fg,test4fg)GOCreate Table PartitionTable(coll int,col2 char(10))ON myRangePS1(col1); 四、索引1 创建索引Create [Unique][Clustered |NonClustered ] INDEX index_nameON[Include ]指定要添加到非聚集索引叶级别的非键列[Where][ON {partition_shema_name}指定分区方案{filegroup_name}]为指定文件组创建索引 举例（1）创建非聚集索引，要求索引键值Cname升序，CardID降序排序 Create Index Comp_index ON Table_customer(Cname ASC,CardID DESC)1（2）创建分区索引，在TransHistory表和ReferOrderID列上为现有分区方案TransactionsPS1创建非聚集分区索引 Create NonClustered INDEX index_nameON TransHistory(RefreOrderID)ON TransactionsPS1(TransactionDate); 2 删除索引Drop INDEX Index_name 五、索引视图1 基本概念标准视图也成虚拟表，因为这种视图所返回的结果集的格式与基本表基本相同，都是由列和行组成，而且在SQL语句中索引视图的方式也与索引基本表的方式相同。标准视图的结果集并不永久地存储在数据库中，每次通过标准视图查询数据时，数据库管理系统都会在内部将视图的定义替换为对基本表的查询语句，然后再对基本表进行查询 2 适合建立索引视图的场合 3 定义索引视图 举例首先创建一个视图，并未该视图创建一个唯一聚聚索引，然后是一个使用该索引视图查询语句 Create VIew Slaes,vOrdersWith SchemaBindingAs….%定义索引视图GoCreate Unique Clustered INDEX Idx_V1ON Sales.vOrders (OrderDate,ProductID);Go…查询语句，不用From 索引视图"},{"title":"第某章  random 库","date":"2022-07-07T10:05:43.706Z","url":"/posts/pythonrdom/","categories":[["Python","/categories/Python/"]],"content":"点击显/隐函数的定义与调用 时针).import randombrandlist &#x3D; [‘华为’, ‘苹果’, ‘诺基亚’, ‘oppo’, ‘小米’]random.seed(0)name &#x3D; brandlist[random.randint(0, 4)]print(name) random.seed()改变随机生成器的种子，使得每次生成的随机数相同 random.random()生成0~1之间的随机浮点数 random.uniform（a, b）指定范围内的随机浮点数 random.randint(a, b)[a, b]内的随机整数 random.randrange(start, stop, step)有梯度的序列中随机取一个随机数 random.shuffle()打乱列表————————————————版权声明：本文为CSDN博主「我是小杨我就这样」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"第一章  程序基本结构","date":"2022-07-07T09:43:22.039Z","url":"/posts/py01/","categories":[["Python","/categories/Python/"]],"content":"程序的基本结构是分为顺序结构, 分支结构与循环结构这三种的.关于分支结构, 为 if…elif…else 的程序解释和三目运算符.关于循环结构, 会阐遍历循环 for 和无限循环 while 这两者.不过在此之前, 用少量的篇幅简要地介绍下数据的类型等. 1. 数据类型数据类型分为数字类型, 字符类型与组合类型. 数字类型数字类型有两种, 为整数与小数, 在 Python 中称为整数与浮点数数字类型的操作: +-*&#x2F; 依次为加减乘除, 另有三个需要注意下: &#x2F;&#x2F; 获取整数商, % 获取余数, ** 次幂另有一些内置函数: abs() 求绝对值, round() 四舍五入, pow() 与 ** 等同. 字符串类型字符串是用引号括起来的有限序列. 中文和英文都算作一个字符, 这是 Python 不同于其他语言的地方.字符串的操作可分为公共操作与独有操作, 其中公共操作可参阅第三章的序列类型, 独有操作如下:lower() 与 upper() 函数分别表示所有字符小写与大写. replace() 函数可替换字符或字符串. 1. 分支结构if…elif…else 语法结构如下: , 有关于三目运算符, 可参阅 “异常处理语法代码” . 例 1: 身体质量指数 BMI:BMI, 顾名思义, 是求身体质量指数.具体指标如下: 分类 国际值 (kg&#x2F;m²) 国内值 (kg&#x2F;m²) 偏瘦 &lt;&#x3D; 18.5 &lt;&#x3D; 18.5 正常 18.5 ~ 25.0 18.5 ~ 24.0 偏胖 25.0 ~ 30.0 24.0 ~ 28.0 肥胖 &gt;&#x3D; 30.0 &gt;&#x3D; 28.0 BMI 的计算方式如下: BMI &#x3D; weight (kg) &#x2F; height² (m²) 点击显/隐代码 2. 循环结构1) 遍历循环 forfor i in range(5) : 遍历5次可使用 range(N) 函数来遍历 N 次, 或遍历序列类型的每一个字符,以及文件的每一行在 for…else… 中, else 可在循环正常结束后执行 例 2: 重量计算. 月球上物体是地球的16.5％ 倍, 现有一人体重为 50kg, 该人在地球上每年增长 0.5kg, 求改人十年后在地球与月球上的体重. 点击显/隐重量计算 & 遍历 N 次的代码 例 3: 统计出现次数. 输入一串字符, 分别统计大小写, 数字空格和其他字符的个数. 点击显/隐遍历序列类型的每一个字符 2) 条件循环 while用于无法确定循环次数的情况, 也可以与 else 连用, 同样为当循环正常结束时执行. 例 4: 最大公约数与最小公倍数的计算. 要求: 两个整数. 点击显/隐最大公约数与最小公倍数的代码 3. 异常处理通常, 异常处理只用在用户输入的合规性以及文件打开是否成功.异常处理的相关语法如下: 点击显/隐异常处理语法 4. random 库主要用于生成各式各样的随机数. 点击显/隐各式各样的随机数 5. 综合案例 田字格输出. 如图所示. — — — — + — — — — + | | | | | | | | | | | | — — — — + — — — — + | | | | | | | | | | | | — — — — + — — — — + 点击显/隐田字格输出的代码 下面以猜数游戏三个版本来依次展现 “分支, 条件循环结构的基础版本” , “加上随机数的版本” 以及 “加上异常处理结构” 的代码.a. 猜数游戏 1.0 : 在程序中预设一个数 5, 用户通过键盘输值开始猜数 (限制猜数范围为 0 ~ 10 ) , 若猜大显示 “猜得过大了” , 反之, 显示 “猜的过小了” , 直至猜中, 显示 “恭喜第 N 次猜中了” , 其中 N 是用户所猜次数. 点击显/隐猜数游戏 1.0 b. 猜数游戏 2.0 : 在猜数游戏 1.0 的基础上, 将键盘预设数字改为随机数 点击显/隐猜数游戏 2.0 c. 猜数游戏 3.0 : 在猜数游戏 2.0 的基础上, 若用户输入非法字符或超出 范围的数字时, 提示: “请输入整数! (0 ~ 10) “ , 并让用户重新输入. 点击显/隐猜数游戏 3.0 回文数判断. 回文数是指正着读与反着读都一样的数字, 如 12321, 38583 等. 请设定一程序, 使其能判断该 5 位数字是否为回文数. 点击显/隐回文数判断代码 羊车门问题. 羊车门问题描述: 有3扇关闭的门, 一扇门后停着汽车, 另外两扇门后是山羊, 主持人知道每扇门后是什么. 参赛者首先选择一扇门, 在开启它之前, 主持人会从另外两扇门中打开一扇门, 露出门后的山羊. 此时, 允许参赛者更换自己的选择. 请问, 参赛者更换选择后, 能否增加猜中汽车的机会? 点击显/隐羊车门问题代码"},{"title":"第一章  操作基础","date":"2022-07-06T08:18:20.447Z","url":"/posts/linux01/","categories":[["Linux","/categories/Linux/"]],"content":"1.请写出进入管理员账户的命令。解: su &lt;注&gt;在本分类中，以后均在管理员账户下进行。 1. Linux 关机方法立即关机重启: shutdown -r now立即关机: shutdown -h now设定 10 分钟后挂机, 并发送信息给登录的 Linux 用户: shutdown +10 &quot;10 分钟后要关机了各位&quot; 2. Linux 命令1) pwd 命令: 查看目录&#x2F;文件所处位置2) ls, ll 命令: 显示当前目录下子项长列表 ll 所显示的 drwxr-xr-x. 2 koinl koinl 6 Apr 2 04:58 Desktop 按空格分隔, 依次为权限, 所含文件数, 属主, 属组, 文件大小, 修改日期, 文件名.ls -a 显示隐藏目录 3) cd 命令: 改变目录touch 命令: 创建文件4) mkdir 命令: 创建目录3.请分别写出创建目录file1、集联创建目录&#x2F;file2&#x2F;test2、创建目录file3的同时给用户、组以及其他人均赋予读写权限的命令。解: mkdir file1; mkdir -p file2/test2; mkdir -m 666 file3 5) cp 命令: 复制目录或文件选项 -r 目录添加cp 源文件 目录文件7.请写出将第（1）题所创建的目录file1复制到目录file2中的命令。解:cp -r file1 file2 6) mv 命令: 移动 &#x2F; 改名 目录或文件8.请写出将第（1）题所创建的目录file2移动到目录file3中的命令。 解:mv file2 file3 7) rm 命令: 删除目录或文件选项 -r 目录添加 8) vi(m) 命令: 文本编辑器1.使用vim 编辑器创建文件num并在文件中写入如下内容：applestudentnoYes解: vi num 添加 2.请写出统计文件num中单词数、行数以及字符数的命令。解: wc num, 结果 4 4 21 num; 表示单词 4 个, 行数 4 个, 字节数 21 个. 2.5.查看文件.解: cat num. 3.请写出将num中单词数、行数以及字符数重定向到文件num1中的命令。解: wc num&gt;num2, -wlc 也可以加, 分别表示单词行与字节, 字符可用用m 4.请写出将num中单词数、行数以及字符数追加到文件num2中的命令。解: wc num&gt;&gt;num2 5.请写出创建文件&#x2F;num3,并写出查找&#x2F;num3的命令。解: 创建文件: touch /num3, 查找文件: find / -name /num3 使用该行代码后会进入全屏幕文本编辑器中,按 e 进入编辑模式, 待编辑完成后,按 esc 退出该模式, :wq! 含义是: 强制 (! ) 保存 (w) 退出 (q) , 可拆卸 9) targzip hello.txt-d 解压缩 10) chmod 命令: 修改权限（2）为文件file设置权限，使其他用户对此文件可以进行写操作。解: 设置其他用户的写权限: chmod o+w file（3）用数字设定法为file文件设置权限，所有者可读、可写、可执行，所属组只有读和执行的权限，其他用户没有权限。解: 自己全操作, 组和他人读与执行: chmod 750 file （2）把目录test及其下所有文件的所有者改为om,所属组改为student。 chown om test # 改变 test 的属主为 omchgrp student test1chown -R om:student test 8.请写出查看当前系统时间的命令，并将当前时间修改为”20220501 18:25:25”解: 查看时间: date. 修改时间: date -s &quot;2022-05-01 18:25:25&quot;"},{"title":"第十章 Shell 脚本","date":"2022-06-16T02:33:31.300Z","url":"/posts/linux08/","categories":[["Linux","/categories/Linux/"]],"content":"该脚本使用步骤如下： 创建文件：解释器，注释体，程序体 需要对其进行可执行权限赋予：chmod u+x XX.sh 进行执行：.&#x2F;XX.sh 如若使用sh XX.sh下面对“创建文件”做相关解释。 一、Shell 脚本文件一个标准的文件如下： 第一、二、三行分别为解释器，注释体，程序体。其中，注释体非必需。解释器在每个文件的最上方都需要注明。下面来看程序体： 1. 程序体程序体，顾名思义就是写程序的地方。有顺序结构，分支结构与循环结构。 1）顺序结构点击显/隐 2）分支结构a. if 分支点击显/隐 b. case 分支点击显/隐 3）循环结构a. for 循环点击显/隐 b. while 循环点击显/隐 3. until 循环点击显/隐 条件测试0成立，1没有文测试类型：件，整数，字符串，逻辑类型。 文件测试test -e filename-d 是否为目录-f 是否为文件-d，-w，-x可读？可写？可执行？ echo $?"},{"title":"第一章  排序","date":"2022-06-10T10:55:03.841Z","url":"/posts/dsa04/","categories":[["Data Structure and Algorithm","/categories/Data-Structure-and-Algorithm/"]],"content":"排序是应用广泛的数据处理方法，本章详细地介绍了插入排序、交换排序、选择排序和归并排序。最后从时间空间以及稳定性能上面对排序方法进行了总结。其中，插入排序分为直接插入排序，折半插入排序和希尔排序。其中，交换排序分为冒泡排序和快速排序。其中，选择排序分为简单选择排序和堆排序。其中，归并排序 一. 插入排序1. 直接插入排序例：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9]解：第一轮：12 对比 59，需要交换。交换完成的矩阵为[12, 59, 77, 64…第二轮：77 对比 12，不动；77 对比 59，不动。矩阵不变。第三轮：64 对比 12，不动；64 对比 59，不动；64 对比 77，需要交换。交换完成的矩阵为[12, 59, 64, 77, 72, 69, 46, 89, 31, 65, 9]。依此类推。 2. 折半插入排序例：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9]解：第一轮：12对比59，需要交换。交换完成的矩阵为[12, 59, 77, 64…第二轮：与上一轮数组相比，77与59，77大，故77在59右边，矩阵不变。第三轮：与上一轮数组相比，64与59，64大，故64在59右边，与77相比…第四轮：与上一轮数组相比，72与64相比，大，右，与77相比，小，故 第n轮：设区域首元素为low，尾元素为high。将待插入区域的首元素设置为a[low],末元素设置为a[high]，则比较时将待插入元素与a[m],其中m&#x3D;(low+high)&#x2F;2相比较。do{ if(新元素&lt;a[m]) 选择a[low]到a[m-1]为新的插入区域(即high&#x3D;m-1) else 选择a[m+1]到a[high]为新的插入区域（即low&#x3D;m+1)}while(low&gt;high)3、将此位置之后所有元素后移一位，并将新元素插入a[high+1]。 这里假定排序为[12,46,31,59,64,69,72,77,89,65,9]，以65为例，下标为9，mid&#x3D;(0+9)&#x2F;2&#x3D;4.5≈4，故将65与64比较，在右，故65必定在5-9下标内，mid&#x3D;(5+9)&#x2F;2&#x3D;7，故将65与77比较，在左，故65必定在5-6下标内，mid&#x3D;(5+6)&#x2F;2&#x3D;5，故将65与69比较，在左，故65会在下标为5的位置。 3. 希尔排序例：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9]解：第一轮：以步长为 5 开始分组，分组情况如下：|59,12,77,64,72||69, 46, 89, 31, 65||9|。分组结果如下：|9,12,77,64,72||59, 46, 89, 31, 65||69|。第二轮：以步长为 3 开始分组，分组情况如下：|9, 12, 77||64, 72, 69||46, 89, 31||65, 9|。分组结果如下：|9, 12, 77||46, 72, 69||64, 89, 31||65, 9|。第三轮：以步长为 1 开始分组，此时是简单插入排序。 二. 交换排序1. 冒泡排序例：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9]解：第一轮：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9][12, 59, 77, 64, 72, 69, 46, 89, 31, 65, 9][12, 59, 77, 64, 72, 69, 46, 89, 31, 65, 9][12, 59, 64, 77, 72, 69, 46, 89, 31, 65, 9][12, 59, 64, 72, 77, 69, 46, 89, 31, 65, 9][12, 59, 64, 72, 69, 77, 46, 89, 31, 65, 9][12, 59, 64, 72, 69, 46, 77, 89, 31, 65, 9][12, 59, 64, 72, 69, 46, 77, 89, 31, 65, 9][12, 59, 64, 72, 69, 46, 77, 31, 89, 65, 9][12, 59, 64, 72, 69, 46, 77, 31, 65, 89, 9][12, 59, 64, 72, 69, 46, 77, 31, 65, 9, 81]第二轮：[12, 59, 64, 72, 69, 46, 77, 31, 65, 9, 81] 2. 快速排序例：[59, 12, 77, 64, 72, 69, 46, 89, 31, 65, 9]解：选定基准值 key&#x3D;arr[0]&#x3D;59 为分界点。初始状态：start&#x3D;0, end&#x3D;10, key&#x3D;59。第一轮：从右向左找到 a[end] 小于 key 的值：end&#x3D;10, a[end]&#x3D;9；从左向右找到 a[start] 大于 key 的值：start&#x3D;2, a[start]&#x3D;77。将他俩进行交换。交换完成的矩阵为：[59, 12, 9, 64, 72, 69, 46, 89, 31, 65, 77]第二轮：从右向左找到 a[end] 小于 key 的值：end&#x3D;8, a[end]&#x3D;31；从左向右找到 a[start] 大于 key 的值：start&#x3D;3, a[start]&#x3D;64。将他俩进行交换。交换完成的矩阵为：[59, 12, 9, 31, 72, 69, 46, 89, 64, 65, 77]第三轮：从右向左找到 a[end] 小于 key 的值：end&#x3D;6, a[end]&#x3D;46；从左向右找到 a[start] 大于 key 的值：start&#x3D;4, a[start]&#x3D;72。将他俩进行交换。交换完成的矩阵为：[59, 12, 9, 31, 46, 69, 72, 89, 64, 65, 77]第四轮：从右向左找到 a[end] 小于 key 的值：end&#x3D;4, a[end]&#x3D;46；此时 end&#x3D;start&#x3D;4，故本轮循环结束，key 与 end进行交换。交换完成的矩阵为：[46, 12, 9, 31, 59, 69, 72, 89, 64, 65, 77]以 59 为分界点，左边的序列为 [46, 12, 9, 31]；右边的序列为 [69, 72, 89, 64, 65, 77]； 三. 选择排序1. 简单选择排序基本思想如下：1）找到最小的数，与第一个数进行交换。2）除去该数，找到最小的数，与第二个数进行交换。3）以此类推，会进行n-1轮。 例：[5,2,1,8,3,4,6,7]解：第一轮：找到最小数1，与第一个数交换第二轮：找到除1的最小数2，与第二个数进行交换&#x2F;原位，不用交换第三轮：找到除1，2的最小数3，与第三个数进行交换… 2. 堆排序堆排序是一种完全二叉树，分为大根堆和小根堆。小根堆中最小元素出现在堆顶，根节点的值小于或等于其孩子结点；大根堆中最大元素出现在堆顶，根节点的值大于或等于孩子结点；如：序列[2,5,8,16,30,16,20,45,60]为小根堆，[90,50,80,16,30,60,70,10,2]是大根堆。 四. 归并排序例：[9,4,6,2,1,7]第一轮：分裂，[9,4,6] 和 [2,1,7]。第二轮：分裂，[9,4] 和 [6]，[2,1] 和 [7]。第三轮：分裂，[9]，[4] 和 [6] 与 [2] 和 [1]，[7]。第四轮：合并，[4,9] 和 [6]，[1,2] 和 [7]。第五轮：合并，[4,6,9] 和 [1,2,7]。第六步：合并，[1,2,4,6,7,9]。 核心思想：分治。对半分，对半分，对半分，分到不可再分为止。逐层归并。如[9,4,6,]分为[9,4]和[6]；[9,4,6,8] 可以分为[9,4]和[6,8]。 五. 排序总结"},{"title":"第六章  用户管理","date":"2022-06-09T03:20:14.821Z","url":"/posts/linux05/","categories":[["Linux","/categories/Linux/"]],"content":"使用rpm 安装 rpm -ivh name 卸载 -e使用yam -install name 卸载 -remove linux软件包管理一、软件包管理——rpm命令管理1、linux软件安装2、RPM包管理-rpm命令管理3、RPM安装、升级与删除rpm -ivh 包全名rpm -Uvhrpm -e 包名4、RPM包校验5、RPM文件提取二、软件包管理——yum在线管理1、 IP地址配置和网络yum源2、yum命令查询yum list 查询所有可用软件包列表 yum search 关键字 搜索服务器上所有和关键字相关的包 ②安装yum -y install 包名 install 安装-y 自动回答yes ③升级yum -y update 包名 update ——升级-y——自动回答yes0 ④卸载（尽量不要卸载，避免系统错误）yum -y remove 包名 remove——卸载-y——自动回答yes 2）yum软件组管理命令① yum group list 列出所有可用软件组列表 ② yum groupinstall 软件组名 安装指定软件组，组名可以由grouplist查询如果组名中有空格号，软件组名需要用双引号括起来 ③ yum groupremove 软件组名 卸载指定软件组———————————————— 3、光盘yum源搭建4、源码包的安装管理5、软件的脚本安装包(通常是源码包)"},{"title":"第四章  用户和组管理","date":"2022-06-09T03:18:08.001Z","url":"/posts/linux04/","categories":[["Linux","/categories/Linux/"]],"content":"用户信息一般保存在 &#x2F;etc&#x2F;passwd 与 &#x2F;etc&#x2F;shadow 中; 组信息一般保存在 &#x2F;etc&#x2F;group 与 &#x2F;etc&#x2F;gshadow 中. 其中, UID 的 koinl:x:1000:1000:koinl:/home/koinl:/bin/bash 分别表示 用户名:密码:UID:GID:用户描述信息:用户主目录:用户默认登录 Shell ;其二, GID 的 koinl:x:1000: 分别表示 组名:密码:GID:组成员. 在 UID 与 GID 中, 0 表示超级用户 root, 系统用户 UID 的数字范围为 1499, 普通用户的数字范围为 49965535. 在下述中, 会阐述下关于增删改用户与组的命令以及修改用户密码的命令. 一. 用户管理1. 查看用户通常情况下，使用 id u1 就可以揽大部分情况，其中uid=1234(u1) gid=1000(koinl) groups=1000(koinl)分别表示 UID、GID、组名。若需要更精确的信息，可以使用cat /etc/passwd | tail -5。 1. 创建用户useradd om,-u 选项可以指定 UID; -g 选项可以指定 GID 或属组;-G 选项可以指定附属组, -d 选项可以指定主目录. 点击显/隐创建用户代码[root@localhost koinl]# useradd -u 1234 -g koinl u1[root@localhost koinl]# id u1uid&#x3D;1234(u1) gid&#x3D;1000(koinl) groups&#x3D;1000(koinl)可以得到创建后的信息: uid=1234(u1) gid=1000(koinl) groups=1000(koinl) 2. 修改用户usermod om,-l 选项仅修改名称 (主目录名称不会改变); -g 选项可以修改 GID; -u 选项可以修改 UID-G 选项可以指定附属组, -d 选项可以指定主目录. 点击显/隐修改用户代码已知旧用户信息: uid=1202(koi) gid=1202(koi) groups=1202(koi)[root@localhost koinl]# usermod -l KOI -g u1 -u 1220 koi[root@localhost koinl]# id KOIuid&#x3D;1220(KOI) gid&#x3D;1200(u1) groups&#x3D;1200(u1)可以得到修改后的信息: uid=1220(KOI) gid=1200(u1) groups=1200(u1) 3. 删除用户userdel om,-r 选项连同主目录一起删除 4. 修改密码passwd [om],-d 选项可以设置成为无密码 点击显/隐[root@s7 ~]# passwd wuhsChanging password for user wuhs.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully. 二. 组管理1. 创建组groupadd student,-g 选项可以指定 GID; 2. 修改组groupmod student,-n 选项可以修改名称; -g 选项可以修改 GID; 点击显/隐修改组代码已知旧组信息: STUDENT:x:1349:[root@localhost koinl]# groupmod -n stu -g 1299 STUDENT[root@localhost koinl]# cat &#x2F;etc&#x2F;group | tail -1stu:x:1299:可以得到修改后的信息: stu:x:1299: 3. 删除组groupdel student, 组中必须无用户 4. 查看组与查看用户信息类似, 同样使用 cat /etc/group | tail -5即可. 小背诵:用户 user 组 group,增删改 add del mod,用户中, u g 定改 ID, l 改名组中, g 定改 ID, n 改名 "},{"title":"第三章  存储和逻辑卷管理","date":"2022-06-09T03:18:06.712Z","url":"/posts/linux03/","categories":[["Linux","/categories/Linux/"]],"content":"新建完分区后，需重新读取内核。另，若挂载则需先进行格式化对于一个硬盘，最多可以设置四个主分区。三个主分区，一个扩展分区fdisk &#x2F;dev&#x2F;sda p查看临时盘信息 n创建 d删除 t修改id w保存Linux 83Linux lvm 8eLinud swap 82 一. 存储管理1. 磁盘分区1) 查看磁盘分区fdisk -llsblk -f(设备挂载情况） 2) 添加分区fdisk &#x2F;dev&#x2F;sda，n，p，4，↲，+512M，w，partprobe 3) 删除分区fdisk &#x2F;dev&#x2F;sda，d，2，w，partprobe 2. 磁盘挂载与卸载1) 磁盘挂载注：所挂载目录需存在mkfs -t ext4 &#x2F;dev&#x2F;sda4mount &#x2F;dev&#x2F;sda4 &#x2F;sta&#x2F;knl 2) 磁盘卸载umount &#x2F;dev&#x2F;sda4 二. 交换分区fdisk &#x2F;dev&#x2F;sda，n…，t 82 w，partprobemkswap &#x2F;dev&#x2F;sda6swapon &#x2F;dev&#x2F;sda6vi &#x2F;etc&#x2F;fstab&#x2F;dev&#x2F;hda6 swap swap defaults 0 0mount -a or dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;opt&#x2F;swapfile bs&#x3D;1M count&#x3D;1000 (bs blocksize ，每个块大小为1M.count&#x3D;2048。则总大小为2G的文件。创建一个1G的文件作为交换分区使用)mkswap &#x2F;opt&#x2F;swapfileswapon &#x2F;opt&#x2F;swapfilevi &#x2F;etc&#x2F;fstab&#x2F;opt&#x2F;swapfile swap swap defaults 0 0mount -a 二、逻辑卷管理LVM 是 Logical Volume Manager 的简称，中文就是逻辑卷管理。 4.删除 任务 PV VG LV 创建 create 删除 remove 显示详细属性 display 扫描列表 s 显示简单信息（不常用） scan 扩展 - extend 缩减 - reduce "},{"title":"第二章  进程管理","date":"2022-06-09T03:17:59.012Z","url":"/posts/linux02/","categories":[["Linux","/categories/Linux/"]],"content":"6.请写出静态查看系统所有进程的命令，同时输出前两行。解: ps -aux | head -2 7.请写出动态查看系统进程的命令。解: top1.设置 at 调度, 要求在两天后上午 9 点创建目录 &#x2F;test.第一步: at 9am + 2 days第二步: mkdir /test第三步: Ctrl + D 退出. 明天下午18把 把日期追加打印到 &#x2F;var&#x2F;spool&#x2F;at&#x2F;date.txt [root@ShenLangBo at]# at 18:00 tomorrowwarning: commands will be executed using &#x2F;bin&#x2F;shat&gt; date &gt;&gt; &#x2F;var&#x2F;spool&#x2F;at&#x2F;date.txtat&gt; job 8 at Sat Nov 27 18:00:00 2021[root@ShenLangBo at]# lltotal 8-rwx—— 1 root root 2901 Nov 26 23:26 a0000801a09118-rw-r–r– 1 root root 168 Nov 26 23:17 resutl1.txtdrwx——. 2 root root 6 Nov 26 23:17 spool2.设置 cron 调度, 要求在每周一的 8 点执行关机操作.第一步: crontab -e第二步: 0 8 * * 1 shutdown -h now1,2,3以及1-5, 分时日月星期在12月内，每天早上6点到12点，每隔20分钟把日期追加到 &#x2F;home&#x2F;mycal 文件中*&#x2F;20 6-12 * 12 * date &gt;&gt; &#x2F;home&#x2F;mycal1每月每天的午夜0点20分，2点20分，4点20分…显示当前时间20 0-23&#x2F;2 * * * date 常用选项： -e：执行文字编辑器来设定时程表，内定的文字编辑器是 vi-r：删除目前的时程表-l：列出目前的时程表-u user：只有root用户可以指定他人的时间表"},{"title":"安全管理","date":"2022-06-09T02:50:03.545Z","url":"/posts/linux07/","categories":[["Linux","/categories/Linux/"]],"content":"SELinux 模式共分为 3 种：强制模式：Enforcing：0许可模式：Permissive：1禁用模式：Disabled：2 可以使用 getenforce 来显示安全增强型Linux系统的模式。可以在其后追加 0、1、2 来修改其模式，不过由于其未对配置文件修改的方式，重启后会失效而在配置文件 vi /etc/sysconfig/selinux 中修改后，重启依然有效 当然也可以只显示某一端口的模式，这里以 http 服务端口为例：semanage port -l | grep http ，格式为：semanage port -a -t 端口名 -p 端口类型 所添加端口号，例 semanage port -a -t http_cache_port_t -p udp 8888。 点击显/隐"},{"title":"第六章  网络基础","date":"2022-06-02T02:17:29.587Z","url":"/posts/linux06/","categories":[["Linux","/categories/Linux/"]],"content":"&lt;注: 网卡设备均以设备 ens33 举例子&gt;关于 Linux 的网络配置, 可分为配置网络 IP 临时 [ifconfig, ip] 与 永久 [nmcli, 网络链接配置文件]。临时本篇暂且不论，只论永久。网络配置文件仅作为了解性内容，重点在于 nmcli 的处理。 网络配置文件: vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-网卡设备名（ens33等） 网卡设备本身 网卡的连接配置nmcli 分为对设备和连接的设置，多个连接可以应用到同一个设备上面，但同一时间只能启用一个连接 对设备的设置查询设备状况当查询设备简略时，使用 nmcli device status 就足矣。若要查询所有设备的具体信息，使用 nmcli device show。当然，若在其后加上具体名称，则仅仅查询该设备的信息另外，你还可以将设备进行断连或连接状态。 对连接的设置查询连接情况简要查询全部信息，使用 nmcli conncetion show，查询某一详细信息，在其后追加其名称。当然，也可以禁用或启用它。 用法 描述 nmcli device status 设备状况 nmcli device show ens33 显示 ens33 状态 nmcli d disconnect &#x2F; connect ens33 ens33 设备禁 &#x2F; 启用 nmcli connection show 显示连接 nmcli connection show ens33 显示 ens33 网络连接 nmcli connection down &#x2F; up ens33 禁 &#x2F; 启用连接配置 对连接配置的修改对于修改，无非就是增删改，下面通过例子来说明： 例1：- 创建名为 conn2 的连接配置, 指定静态 ip 地址, 不自动连接. (分配，类型，地址，网关)nmcli c a ifname ens33 con-name conn2ipv4.method manual type Ethernet ipv4.addresses 192.168.85.136/24 gw4 192.168.85.2autoconnect no 经查看, 可知 conn2 连接已存在, 但未关联到某个设备上.nmcli c s 例2：等，见表格下 nucli 参数 配置文件参数 描述 ipv4.method manval &#x2F; auto BOOTPROTO&#x3D;none or static &#x2F; dhcp 动态分配 IP ifname ens33 DEVICE&#x3D;ens33 指定网卡名称 ipv4.addresses 192.168.100.100&#x2F;24 IPADDR&#x3D;192.168.100.100’&#x2F;n’PREFIX&#x3D;24 IP 地址与掩码位数 gw4 192.168.100.1(2?) GATEWAY&#x3D;192.168.100.1 设置网关 ipv4.dns 8.8.8.8 DNS0&#x3D;8.8.8.8 设置 DNS 服务器 ipv4.dns-search example.com DOMAIN&#x3D;example.com 域名 connection.autoconnect yes ONBOOT&#x3D;yes 开机自动连接 查看 配置文件 conn2cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-conn2 首先禁用 ens33 连接, 再启用 conn2 连接. 这就是 两个网络情况下切换网络的方法.nmcli c d ens33nmcli c u conn2 可通过查看连接状态了解详情.nmcli c s 查看 ens33 设备的状态.nmcli d snmcli d show ens33 修改 conn2 的连接配置, IP为 , DNS 为 , 并设置开机自动启用连接.nmcli c m conn2 ipv4.addresses 192.168.85.59&#x2F;24 ipv4.dns 192.168.85.1 connection.autoconnect yes 查看 ifcfg-conn2配置文件的内容cat -n &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-conn2 重启网络服务, 使新配置生效.systemctl restart network 将网络恢复原先状态nmcli c d conn2 配置文件的修改实际上就是修改连接配置 点击显/隐查看网卡设备 ens33 的配置文件参数 systemctl 命令systemctl start 服务名stop,status,restart,enable,disable 主机名hostnamehostname new_name pingping -c 3 www.baidu.com检测 IP 连通性 traceroutetraceroute -q 4 www.38.com ipip a show ens33"},{"title":"第某章  PIL 库","date":"2022-05-31T11:30:45.877Z","url":"/posts/py0nnnpillow/","categories":[["Python","/categories/Python/"]],"content":"点击显/隐函数的定义与调用 安装: pip install pillow -i  --trusted-host mirrors.aliyun.com PIL 库 Image 类1. 图像读取 2. 图像常用属性 4. 图像转换与保存 5. 图像缩放, 旋转与翻转resize: 缩放;rotate: 旋转 (逆时针). 6. 图像像素与通道处理 二. PIL 库 ImageFilter 类ImageFilter 类提供了一些预定义图像过滤方法, 这里仅以 “图像的浮雕效果” 举例子, 其他方法详见表. 方法表示 描述 三. PIL 库 ImageEnhance 类ImageEnhance 类提供了一些图像增强与滤镜方法, 这里仅以 “调整图像对比度” 举例子, 方法其他方法详见表. 方法表示 描述 "},{"title":"第三章  图","date":"2022-05-25T10:53:09.766Z","url":"/posts/dsa03/","categories":[["Data Structure and Algorithm","/categories/Data-Structure-and-Algorithm/"]],"content":"关于图的存储方式分为邻接矩阵和邻接表两种;关于图的遍历方式分为深度优先遍历和广度优先遍历;对于无向图, 其所有生成树里面必有一颗边所加权值最小的树, 称为最小生成树. 最小生成树的实现算法有克鲁斯卡尔和普利姆算法, 其英文分别为 Kruskal, Prim.迪杰斯特拉和弗洛伊德算法, 其英文分别为 Dijkstra, Floyd. 图的存储邻接矩阵 &amp; 邻接表对于无向图, 有直接连线为 1, 无连线为 0.对于有向图, 自身为 0, 可到达为 1, 不可到达为 ∞ 点击显/隐代码 邻接表点击显/隐代码 邻接矩阵与邻接表的转换点击显/隐代码 图的遍历深度优先遍历 &amp; 广度优先遍历点击显/隐代码 广度优先遍历最小生成树最小生成树是指对于有 n 个节点的无向连通图, 一颗边的权值总和最小的生成树. 点击显/隐算法思路 在本题中, 克鲁斯卡尔算法的思想如下:寻找最小边长, 得’3’,连接 1 与 4; # [1, 4, 3]再度寻找最小边长, 得’4’,连接 4 与 5; # [4, 5, 4]再度寻找最小边长, 得’5’,连接 5 与 0; # [5, 0, 5]再度寻找最小边长, 得’6’,连接 2 与 3; # [2, 3, 6]再度寻找最小边长, 得’7’,但不可连接 1 与 0, 因为会成为闭环.再度寻找最小边长, 得’8’,连接 3 与 4; # [3, 4, 8]每个顶点均已连接到.z 最小生成树生成. 在本题中, 普利姆算法的思想如下:从最小顶点开始, 得 0, 连接顶点0中所有边 (7, 5) 的最小边’5’所在的顶点, 即 5. # [0, 5, 5]再度从这俩顶点开始, 连接顶点 0,5 中对于4,1,3,2的所有边(7, 4, 10) 的最小边’4’所在的顶点, 即 4. # [5, 4, 4]再度从这仨顶点开始, 连接顶点 0,5,4 中对于1,3,2的所有边(7, 3, 8, 10) 的最小边’3’所在的顶点, 即 1. #[4, 1, 3]再度从这伵顶点开始, 连接顶点 0,5,4,1 中对于3,2的所有边(9, 8, 10) 的最小边’8’所在的顶点, 即 3. #[4, 3, 8]再度从这伍顶点开始, 连接顶点 0,5,4,1,3 中对于2的所有边(9, 6) 的最小边’6’所在的顶点, 即 2. # [3, 2, 6]每个顶点均已连接到.z 最小生成树生成. 点击显/隐代码 最短路径点击显/隐算法思路 在本题中, 迪杰斯特拉算法的思想如下:首先选取一个顶点, 自拟0, 顶点0距离未到达的顶点 (1,2,3,4,5,6) 距离分别为 (2,3,∞,∞,∞,∞), 2距离最小, 故添加顶点 1;已添加 [0,1], 顶点0距离未到达的顶点 (2,3,4,5,6) 距离分别为 (3,11,7,∞,∞), 故添加顶点 2;已添加 [0,1,2], 顶点0距离未到达的顶点 (3,4,5,6) 中顶点4可以经过顶点1或3, 距离分别为 2+5或3+1, 故添加顶点4, 其为从顶点0出发, 经过顶点2到达顶点4.已添加 [0,1,2,4], 顶点0距离未到达的顶点 (3,5,6) 中到达3的最小距离为3+1+6, 到达5的最小距离为3+7, 故随便选一个, 添加顶点 3, 经过顶点2与4到达顶点3.已添加 [0,1,2,4,3], 顶点0距离未到达的顶点 (5,6) 中到达5的最小距离为3+7, 故添加顶点 5, 其经过顶点2到达顶点5.已添加 [0,1,2,4,3,5], 顶点0距离未到达的顶点 (6) 中到达6的最小距离为3+1+15, 故添加顶点 6, 其经过顶点2,4到达顶点6. 点击显/隐代码 关键路径在AOE网中，从源点到汇点的带权路径长度最大的路径为关键路径，关键路径上的活动为关键活动。如何确定关键路径，首先要确定Ve[j], Vl[j], e[i], l[i]。 Ve[j] ：表示事件j 的最早发生时间，ETV（Earliest Time Of Vertex)，考查入边，弧尾ve+入边最大值VI[j]： 表示事件j 的最迟发生时间，LTV（Latest Time Of Vertex)，考查出边，弧头vl−出边最小值。e[i]：表示活动ai的最早开始时间，ETE(Earliest Time Of Edge)，弧尾的最早发生时间。l[i]：表示活动ai的最迟开始时间，LTE(Lastest Time of Edge)，弧头的最迟发生时间减去边值。 如该图，该图的Ve与Vl如下：|V|v1|v2|v3|v4|v5|v6|v7|v8|v9||ETV|0|6|4|5|7|7|16|14|18||LTV|0|6|6|8|7|10|16|14|18| |V|v1|v2|v3|v4|v5|v6|v7|v8|v9||ETE|0|0|0|6|4|5|7|7|7|16|14||LTE|0|2|3|6|6|8|7|7|10|16|14|"},{"title":"第某章  turtle 库","date":"2022-05-11T00:40:37.079Z","url":"/posts/py0nnn/","categories":[["Python","/categories/Python/"]],"content":"点击显/隐函数的定义与调用 首先, 熟悉几个辅助操作 (美化效果, 非必要): setup(800, 350, 200, 200) 窗口宽度, 窗口高度, 若值小数, 表示比例; 窗口与屏幕的左侧距离, 窗口与屏幕顶部的距离, 若值 None, 位于中央 penup(); fd(-300) 画笔在中央, 向左移动一些距离更美观 hideturtle(); done() 隐藏画笔的形状且不自动关闭 pensize(5) 含义为画笔尺寸为 5. pencolor(&quot;red&quot;) 含义为画笔颜色为红色. speed(0) 控制绘制速度 操作函数与方法 别名 描述 pendown(), penup() pd(), pu(); down(), up() 画笔落下，画笔抬起 forword() fd() 画笔前进一段距离 left(), right 画笔旋转 setup() 窗宽, 窗高, 与屏左距离, 屏顶距离 hideturtle() 结束绘制隐藏画笔 done() 结束不自动关闭 点击显/隐函数的定义与调用turtle.fd(distance) 沿当前画笔方向画distance的距离turtle.bk(distance) 沿当前画笔相反方向画distance的距离turtle.right(degree) 画笔沿顺时针旋转degree度turtle.left(degree) 画笔沿逆时针旋转degree度turtle.seth(d)t.goto(x0,y0) 点击显/隐函数的定义与调用 点击显/隐函数的定义与调用 点击显/隐函数的定义与调用 4. jieba 库中文分词库，第三方库需要安装。 常用的函数有两个，“cut(s, [cut_all&#x3D;True])” 与 “cut_for_search(s)”，分别为精确 [全] 模式与搜索引擎模式。 但使用 cut 直接输出得到的结果是内存地址，因此使用 lcut[_for_search](s) 会好很多。其本质可见代码第 5 行。 点击显/隐代码"},{"title":"⌊手机篇⌉ 将手机投屏到电脑","date":"2022-05-02T10:52:21.668Z","url":"/posts/EDp-scrcpy/","categories":[["电子设备","/categories/%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87/"]],"content":"您需要准备: 1 部手机, 1 部电脑, 1 根数据线. 您需要保证: a. 电脑和手机处在同一 wifi 下; b. 手机与电脑使用数据线连接起来; c. 打开手机的开发者模式, 在其中已经找到 USB 调试并已经打开它. 首先, 您需要在电脑上下载 scrcpy, 再将下载后的资源解压缩到您喜欢的路径. 其次, 打开 cmd 后转到您解压缩后的路径, 输入 adb tcpip 5555 回车, 再输入 adb connect 192.168.235.11:5555 回车, 若分别显示 restarting in TCP mode port: 5555 和 connected to 192.168.235.11:5555 则成功. 再次, 拔掉数据线. 最后, 在 cmd 中输入 scrcpy --shortcut-mod=lctrl,rctrl 即可. mod 键是快捷键的修饰键, 默认是左 Alt, 但在我看来变成 Ctrl 更能方便些, 因此我预备使用命令 scrcpy --shortcut-mod=lctrl,rctrl 来改变修饰键为左 Ctrl 键和右的 Ctrl 键. 操作 快捷键 全屏 mod + f 重置大小, 清除黑边 mod + g, mod + w 左右旋转屏幕 mod + ←, mod + → 上下调节音量 mod + ↑, mod + ↓ 切换应用, 返回主屏幕, 返回上一层 mod + s, mod + h, 右键 下拉, 下拉二层, 收起通知面板 mod + n, mod + n + n, mod + Shift + n 复制, 剪贴, 粘贴文本, 图片等内容 mod + c, mod + x, mod + v 关闭, 打开, 旋转设备屏幕 mod + o, mod + Shift + o, mod + r "},{"title":"第一章  操作基础","date":"2022-04-25T06:30:53.430Z","url":"/posts/linuxlianxizuoye/","categories":[["Linux","/categories/Linux/"]],"content":"3.请删除 &#x2F;dev&#x2F;sda 下的 sda2 分区.第一步: 查看系统分区与挂载情况: lsblk -f第二步: fdisk /dev/sda.第四步: d , 其中, d 删除, n添加, p 临时查看分区状态, q 退出不变更, w 保存.第五步: 2, 删除第几个号第七步: w , 保存更改第八步: lsblk 进行查看, 若fdisk已经消失, 但lsblk仍然有, 可以尝试 partprobe /dev/sda 刷新试试. 重启最好. 4.请创建一个大小为 300M 的主分区, 并将该分区挂在到 &#x2F;mnt&#x2F;data 目录下, 挂载完成后, 再对其进行卸载.解: 第一步: 使用命令 fdisk /dev/sda 对 sda 分区进行操作,选择 n 表示添加操作, 选择 p 表示添加主分区, 选择 4 表示添加 sda4 分区, 在 First… 处回车后, 在 Last 处标注 +300M 表示主分区的大小为 300M. 最后使用 w 保存修改第二步: 使用命令 partprobe /dev/sda 刷新分区, 这时查看分区状态, 可看到 sda4 已出现.第三步: 使用命令 mkfs -t ext4 /dev/sda4 格式化分区 sda4 (创建文件系统) ; 再使用命令 mount /dev/sda4 /mnt/data 挂载分区, 需提前创建目录. 这时查看分区状态, 可以看到 sda4 已经挂载完成.第四步: 使用命令 umount /dev/sda4 卸载分区, 这时查看分区状态, 可以看到 sda4 已经卸载完成. 5.请创建一个大小为 1500M 的交换分区.解: 第一步: 创建大小为 1500M 的交换文件: dd if=/dev/zero of=/swapfile bs=1024k count=1500第二步: 使用命令 mkswap /swapfile 格式化交换文件第三步: 使用命令 swapon /swapfile 启用交换分区第四步: 使用命令 swapon -s 查看交换分区 linux 第五次作业1.用户账号管理 新建一个 user1 用户, UID, GID, 主目录均为默认 新建一个 user2 用户, UID&#x3D;800. 分别将以上两个用户的密码设置为 “123456”. user2 同理. 把 user1 的用户名改成 u1, UID 改成 700 连同主目录一起删除 user2 用户. 2.组账号管理 1)建立一个标准组 group1, GID&#x3D;900 2)建立一个标准组 group2, 选项为默认 3)把 group3 组名改成 g3, GID&#x3D;1000. 4)删除 group2 组. "},{"title":"第三章  组合数据类型","date":"2022-04-16T11:04:06.832Z","url":"/posts/py03/","categories":[["Python","/categories/Python/"]],"content":"组合数据类型, 分为序列类型, 集合类型和映射类型. 序列类型序列类型有列表与集合, 列表常用操作如下: 点击显/隐代码 3. 集合因为去重, 因此使用场景: 元素去重因为无序, 不支持下标操作 点击显/隐代码 4. 字典点击显/隐代码 3. 推导式 列表推导式有句口诀: 空列表尾加法无脑列表推导式就是了 点击显/隐代码 集合推导式还是老样子, 空集合增加法无脑集合推导式就行了 点击显/隐代码 字典推导式 点击显/隐代码 4. jieba 库第三方库, 需要安装. 中文分词库 点击显/隐代码 5. 综合案例 重复元素判定. 编写一个函数, 用列表作为参数, 如果一个函数在该列表种出现了超过一次, 返回 True, 反之则反, 但不改变列表的值. 点击显/隐代码 文本词频统计. 来吧, 统计下三国演义的人物出场统计吧! 点击显/隐代码 生日悖论. 指如果一个房间里有23 或以上人，那么至少有两个人生日相同的 概率大于50%。编写程序，输出在不同随机样本数量下，23 个人中至少两个人生日相同的概率。 点击显/隐代码 点击显/隐代码"},{"title":"第二章  函数","date":"2022-04-16T06:40:48.725Z","url":"/posts/py02/","categories":[["Python","/categories/Python/"]],"content":"本章节讲了集合的格式与特点与常用操作. 酱, 点击”more”观看更多吧! 1. 函数的定义与调用 函数分为定义, 与调用两步. 点击显/隐函数的定义与调用 2. 函数的 lambda 与参数传递 当函数很简单时, 可以使用 lambda 函数来达到简化行数的目的.也借此, 来阐述关于函数的五种参数传递 (无参, 有参, 默认参数, 显示为元组以及显示为字典的参数) . 点击显/隐代码 3. 递归函数内部自己调用自己阶乘 累乘积 4. datetime 库时间处理 点击显/隐代码 5. 综合案例 在第一章里面, 练习了田字格的输出, 现请输出一个更大的田字格. 点击显/隐代码 实现 multi() 函数, 参数个数不限, 返回所有参数的乘积. 点击显/隐代码 实现 isPrime() 函数, 参数为整数, 要有异常处理. 如果整数是质数, 返回 True, 否则返回 False. 点击显/隐代码 点击显/隐代码 点击显/隐代码"},{"title":"第一章  线性表","date":"2022-03-29T11:27:50.221Z","url":"/posts/dsa01/","categories":[["Data Structure and Algorithm","/categories/Data-Structure-and-Algorithm/"]],"content":"数据结构可视化：可视化 程序, 等于数据结构与算法. 在本标签下, 会讲述有关于数据结构 (逻辑结构, 存储结构和运算) 的基本知识. 逻辑结构分为线性结构 (线性表) 和非线性结构 (树, 与图) 的讲述. 存储结构包括 (顺序存储, 链式存储, 索引存储与散列存储) . 而有关于处理这些数据的基本技术即运算则 (如查找于排序) 在算法标签下讲述. 1. 线性表线性表是指由有限个同类元素组成的, 且相邻元素之间有序偶关系. 2. 线性表的存储线性表的存储有顺序存储和链表存储两种方式.顺序存储按顺序依次存储, 列表和元组可以实现顺序表.链表存储除了原有的数据外, 还有存放后继元素地址的指针域.顺序表的操作会引起大量数据移动, 效率很低, 根本原因是数据的逻辑关系是通过物理关系来表示的; 链式存储不要求物理上相邻 (毕竟指针也不是吃干饭的) , 这就使链表相比顺序表效率更高. 3. 线性表的操作1) 顺序表操作参阅列表与元组的操作即可. 3. 单链表操作点击显/隐线性表的操作 2. 栈栈是一种增删操作都在表尾 (称栈顶) 操作的线性表. 具有先进后出的特性. 点击显/隐栈的操作 3. 队列队列经典例子是 “排队” , 但刚好与其相反. 队列的插入采用头插法, 删除采用尾删法. 点击显/隐队列的操作 4. 字符串字符串是由 n 多字符组成的有限序列. 点击显/隐字符串的操作 5. 综合案例 模式匹配 给定一个子串, 要求在字符串中找到与子串相同的所有子串, 如在 “BBC ABCDAB ABCDABCDABDE” 中找到 “ABCDABD” . a. 点击显/隐 BF 算法的代码 b. 点击显/隐 KMP 算法的代码 [未完成] 小猫钓鱼. 甲和乙在玩一个扑克游戏——小猫钓鱼。游戏规则：将一副扑克牌平均分成两份，每人拿一分。甲先拿出手中第一张扑克牌放在桌上，然后乙也拿出手中第一张扑克牌，并放在甲刚才打出的扑克牌的上面，两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，可将两张相同的牌及其中间所夹的牌全部拿走，并依次放到自己手中牌的末尾。当任意一人手中当牌出完时，游戏结束，对方获胜。 点击显/隐小猫钓鱼的代码"},{"title":"第二章  树和二叉树","date":"2022-03-29T11:27:50.221Z","url":"/posts/dsa02/","categories":[["Data Structure and Algorithm","/categories/Data-Structure-and-Algorithm/"]],"content":"在本篇中, 首先讲述了关于二叉树的相关知识, 第二讲述了关于最优二叉树 (哈夫曼树) 所建立的哈夫曼编码. 第三阐述了树与二叉树的关系与转换 二叉树的存储, 其次讲述了二叉树的四种遍历方式, 以及如何将二叉树进行翻转 二叉树的存储 顺序存储: 只适用于完全二叉树 链式存储 二叉树的遍历 分为先序遍历 (DLR) , 中序遍历 (LDR) ,后序遍历 (LRD) 和层序遍历 先序遍历: 依次从上往下访问根节点, 左子树, 右子树, 若二叉树为空返回空操作 中序遍历: 依次从上往下访问左子树, 根节点, 右子树, 若二叉树为空返回空操作 后序遍历: 依次从上往下访问左子树, 右子树, 根节点, 若二叉树为空返回空操作 层序遍历: 若二叉树为空, 则空操作返回; 否则, 从根节点从上而下逐层遍历, 同一层中顺序为从左到右 二叉树的翻转 左右翻转那种样子 二叉树的存储, 遍历与翻转的代码实现点击显/隐图片待定 点击显/隐代码 由遍历序列创建二叉树 可分为 “知先序中序求后序” , “知中序后序求先序” . 例 1 : 由先序, 中序推出后序遍历已知二叉树的先序遍历是 ABCDEF , 中序遍历是 CBAEDF , 求后序遍历. 点击显/隐思路先序遍历是先打印根节点, 故可知 A 为根节点;中序遍历是先递归左子树, 再打印根节点, 故可知 CB 为左子树节点, EDF为右子树节点.左子树判断开始:先序遍历是先打印根节点, 再递归左子树, 所以 B 是 A 的左孩子;中序遍历是先递归左子树, 再打印根节点, C 在 B 前, 所以 C 是 B 的左孩子;左子树告一段落;右子树判断开始:先序遍历是先递归左子树 BC , 再递归右子树 DEF , 所以 D 是 A 的右孩子;中序遍历是先递归左子树, 再打印根节点, 再递归右子树, D 在 EDF 的中间, 所以 E 为 D 的左孩子, F 为 D 的右孩子.右子树告一段落.现在可以得到: 根节点: A, 根节点左右孩子 BD , B 的左孩子 C , D 的左右孩子 EF.后序遍历由此可知: CBEFDA . 例 2 : 由中序, 后序推出先序遍历已知二叉树的中序遍历是 ABCDEFG , 后序遍历是 BDCAFGE , 求先序遍历. 点击显/隐思路后序遍历最后一个是根节点, 因此可知 E 为根节点.中序遍历先递归左子树, 再打印根节点, 再递归右子树, 由此可知 ABCD 为左子树, FG 为右子树.左子树判断开始:在后序遍历中, 子树的根节点是在子树的最后一个, 因此 A 为 E 的左孩子在中序遍历中, 遍历顺序为 (左根右) LDR (LeftDataRight) , 所以 BCD 全为 A 的右孩子.在后序遍历中, 遍历顺序为LRD, 所以 BD 是 C 的左右孩子.所以 D 很明显, 是 A 的右孩子.左子树告一段落;右子树判断开始:在后序遍历中, 子树的根节点是在子树的最后一个, 因此 G 为 E 的右孩子.在后序遍历中, 遍历顺序为 LRD, 所以 F 是 G 的孩子.在中序遍历中, 遍历顺序为 LDR, 所以 F 是 G 的左孩子.右子树告一段落.现在可以得到: 根节点 E , E 的左右孩子 AG , A 的右孩子 D, D 的左右孩子 BC , G 的左孩子 F .先序遍历由此可知: EACBDGF . ##哈夫曼树例 3：现有节点a，b，c，d，e，f 6个字符，其权值分别为a（9），b（12），c（6），d（3），e（5），f（15），构建哈夫曼树。 点击显/隐注：左子树的值小于右子树。进行排序，值中，最小的是d，e，因此d，e分别为左右子树，权值之和为de（8）将 de 加入后排序，最小的是 c，de，因此 c，de分别为左右子树，权值之和为 cde（14）将cde加入后排序，最小的是 a，b，因此 a，b 分别为左右子树，权值之和为ab（21）将 ab加入后排序，最小的是 cde，f，因此 cde，f分别为左右子树，权值之和为 cdef（29）只剩下ab，cdef，因此ab，cdef分别为左右子树，权值之和为 abcdef（50）。 例 4：得到上述哈夫曼树的编码。 点击显/隐从根节点出发，左子树边为0，右子树为1，进行编码。a：00；b：01；c：100；d：1010；e：1011；f：11. 可以得到1：权值越大，长度越短。可以得到2：每一个结点都是叶子结点，因此保证了译码的唯一性。 "},{"title":"应用篇-第二章  图形对用户界面设计[未完成]","date":"2022-02-21T11:42:16.559Z","url":"/posts/matlabyyp02/","categories":[["MATLAB","/categories/MATLAB/"]],"content":"本章节讲了集合的格式与特点与常用操作 应用篇-第一章 图形对象句柄 图形窗口对象hf &#x3D; figure(‘color’, [0, 1, 0], ‘position’, [1, 1, 300, 150], … ‘name’, ‘图形窗口示例’, ‘numbertitle’, ‘off’, ‘menubar’, ‘none’,… ‘keypressfcn’, ‘disp(‘’hello’’)’, ‘resize’, ‘off’, ‘pointer’, ‘topl’) 坐标轴对象 "},{"title":"第五章  数据分析与多项式计算[未完成]","date":"2022-02-20T06:51:40.511Z","url":"/posts/matlab05/","categories":[["MATLAB","/categories/MATLAB/"]],"content":"第五章 数据分析与多项式计算1.统计分析A &#x3D; [1, 3, 5, 7, 9; 8, 6, 4, 2, 0];max_value &#x3D; max(A, [], 2) % 行的最大值, min同理sum_value &#x3D; sum(A, 2) % 行的求和prod_value &#x3D; prod(A, 2) % 行的求积mean_value &#x3D; mean(A, 2) % 行的均值median_value &#x3D; median(A, 2) % 行的中值sort_value &#x3D; sort(A, 2, ‘descend’) % 行的降序排序2.多项式计算% 多项式1; x³ -2x² + 5x +3% 多项式2: 6x² -1a &#x3D; [1, -2, 5, 3];b &#x3D; [0, 6, 0, -1];sum &#x3D; a + bprod &#x3D; conv(a, b)% deconv(a,b)polyder(a)polyder(a, b)polyder(prod)polyval(a, 2)roots(a)poly(ans)4.曲线插值与曲线拟合x &#x3D; [1, 2, 3, 4, 5];y &#x3D; [3, 6, 9, 12, 15];interp1(x, y, 9,’spline’)spline(x, y, 9)x &#x3D; linspace(0, 2 * pi, 100);y &#x3D; sin(x);polyfit(x, y, 3)y1 &#x3D; polyval(ans, x)plot(x, y, x, y1)"},{"title":"第四章 绘图[未完成]","date":"2022-02-20T06:08:35.894Z","url":"/posts/matlab04/","categories":[["MATLAB","/categories/MATLAB/"]],"content":"第四章 绘图二维图形 绘制方法: ploy(x, y) 辅助操作 图形标注:标题(title), 轴说明(x, ylabel), 标记图例(legend) 坐标控制:轴范围(axis), 网格线(grid), 边框(box) 图形保持:hold 窗口分割:subplot二维图形2 极坐标图: polar 条形图: bar 饼图: pie三维图形需生成平面网格坐标meshgridploy3, mesh, surf隐函数绘图ezplot "},{"title":"第三章  程序流程控制[未完成]","date":"2022-02-20T04:01:14.702Z","url":"/posts/matlab03/","categories":[["MATLAB","/categories/MATLAB/"]],"content":"第三章 程序流程控制 顺序结构a &#x3D; input(‘请输入a值: ‘);b &#x3D; input(‘请输入b值: ‘);c &#x3D; input(‘请输入c值: ‘);d &#x3D; b * b - 4 * a * c;x &#x3D; [(-b + sqrt(d)) &#x2F; (2 * a), (-b - sqrt(d)) &#x2F; (2 * a)];disp([‘x1的值是: ‘,num2str(x(1)), ‘, x2的值是: ‘,num2str(x(2))]) 选择结构% 需求: x在19内, y &#x3D; x + 10; x在1029内, y &#x3D; x - 10; 否则, 输出错误信息x &#x3D; input(‘请输入x的值: ‘);if x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; 9 y &#x3D; x + 10; yelseif x &gt;&#x3D; 10 &amp;&amp; x &lt;&#x3D; 19 y &#x3D; x - 10; yelse disp(‘错误信息’)end 多分支结构c &#x3D; input(‘请输入一个字符’,’s’);if c &gt;&#x3D; ‘a’ &amp;&amp; c &lt;&#x3D; ‘z’ disp(upper(c))elseif c &gt;&#x3D; ‘0’ &amp;&amp; c &lt;&#x3D; ‘9’ disp([‘最终结果是: ‘,num2str(str2double(c) * 2)])end switch% 需求: n &#x2F; 10, 当结果为0, 输出零蛋; 当结果为1, 2,% 输出他们的乘4; 当结果为3, 4, 5, 输出’最终结果是: 开平方’% 当结果为5~9, 输出开根号, 当结果为10+, 输出错误信息n &#x3D; input(‘请输入想要输入的值: ‘);switch rem(n, 10) case 0 disp(‘零蛋’); case {1, 2} disp(n * 4); case {3, 4, 5} disp([‘最终结果是: ‘,num2str(sqrt(n))]); case num2cell(6:9) n &#x3D; n &#x2F; 2; otherwise disp(‘错误信息’);endn "},{"title":"应用篇-第一章  图形对象句柄[未完成]","date":"2022-02-19T11:03:06.613Z","url":"/posts/matlab09/","categories":[["MATLAB","/categories/MATLAB/"]],"content":"本章节讲了集合的格式与特点与常用操作. 应用篇-第一章 图形对象句柄 图形窗口对象hf &#x3D; figure(‘color’, [0, 1, 0], ‘position’, [1, 1, 300, 150], … ‘name’, ‘图形窗口示例’, ‘numbertitle’, ‘off’, ‘menubar’, ‘none’,… ‘keypressfcn’, ‘disp(‘’hello’’)’, ‘resize’, ‘off’, ‘pointer’, ‘topl’) 坐标轴对象 "},{"title":"小贴士~","date":"2022-02-18T04:03:56.044Z","url":"/posts/tips/","categories":[[" ",""]],"content":"WLAN密码:请确保在 英文状态下输入标点符号。密码为: 问号（?）叹号（!）分号（;）冒号（:）单引（’）双引（”）星号（*）斜杠（&#x2F;）大写（A）。总共 9 个英文标点字符。"},{"title":"第五章  文件操作","date":"2022-02-10T06:37:24.004Z","url":"/posts/python05/","categories":[["Python","/categories/Python/"]],"content":"本章节讲了文件的开关读写操作与文件备份和文件夹的一些操作. 酱, 点击”more”观看更多吧! 第五章 文件操作文件的基本操作打开openf = open(&#39;name&#39;, &#39;mode&#39;)f为文件对象name: 目标文件名的字符串或路径mode: 访问模式:只读: r, 如果文件不存在, 报错; 可省 写入: w, 文件无则创建; 追加: a, 文件无则创建;但凡带 +, 可读写; 但凡带 b, 为二进制格式 读写 read, write读: read(): f.read(num)num表读取几个字节, 未注明则全部 readlines(): f.readlines()返回为列表, 每一行为一个元素 readline(): 第 n 次读取第 n 行内容f.write(‘aaa’) 文件指针 什么是文件指针? seek(): f.seek(偏移量, 起始位置)起始位置: 0开头1当前2结尾关闭 closef.close()文件备份 文件和文件夹的操作要进行这个操作啊得借助os模块的相关功能;所以啊得进行导入: import os;然后再使用模块相关功能: os.func() 文件 重命名: os.rename(old_name,new_name) 删除: os.remove(name) 文件夹 创建: os.mkdir(文件夹名字) 删除: os.rmdir(文件夹名字) 获取当前文件目录路径: os.getcwd() 切换目录: os.chdir(新目录名) 获取目录列表: os.listdir()例: 批量修改文件名, 可添加或删除指定字符串 一二维数据的格式化和处理一二维数据数据的存储格式为 CSV 格式，后缀为 .csv。 一二维数据的表示和读写导入CSV格式到列表将二维列表美观地处理一下一维数据写入 CSV 文件二维数据写入 CSV 文件 "},{"title":"第一章  程序基本结构","date":"2022-02-06T12:14:44.986Z","url":"/posts/py01/","categories":[["Python","/categories/Python/"]],"content":"程序的基本结构是分为顺序结构, 分支结构与循环结构这三种的.关于分支结构, 为 if…elif…else 的程序解释和三目运算符.关于循环结构, 会阐遍历循环 for 和无限循环 while 这两者.不过在此之前, 用少量的篇幅简要地介绍下数据的类型等. 1. 数据类型数据类型分为数字类型, 字符类型与组合类型. 数字类型数字类型有两种, 为整数与小数, 在 Python 中称为整数与浮点数数字类型的操作: +-*&#x2F; 依次为加减乘除, 另有三个需要注意下: &#x2F;&#x2F; 获取整数商, % 获取余数, ** 次幂另有一些内置函数: abs() 求绝对值, round() 四舍五入, pow() 与 ** 等同. 字符串类型字符串是用引号括起来的有限序列. 中文和英文都算作一个字符, 这是 Python 不同于其他语言的地方.字符串的操作可分为公共操作与独有操作, 其中公共操作可参阅第三章的序列类型, 独有操作如下:lower() 与 upper() 函数分别表示所有字符小写与大写. replace() 函数可替换字符或字符串. 字符串类型的格式化print(‘{1:8&gt;5},{0:,.2f}’.format(1232,’zhk’)) # {x:n}中，x 为序号，n的顺序依次为填充字符对齐方式最大长度千分号精度类型这六个print(‘{:&#39;^30x}’.format(123456) # 单引号为特殊字符，需要进行转义，十六进制类型为 x 1. 分支结构if…elif…else 语法结构如下: , 有关于三目运算符, 可参阅 “异常处理语法代码” . 例 1: 身体质量指数 BMI:BMI, 顾名思义, 是求身体质量指数.具体指标如下: 分类 国际值 (kg&#x2F;m²) 国内值 (kg&#x2F;m²) 偏瘦 &lt;&#x3D; 18.5 &lt;&#x3D; 18.5 正常 18.5 ~ 25.0 18.5 ~ 24.0 偏胖 25.0 ~ 30.0 24.0 ~ 28.0 肥胖 &gt;&#x3D; 30.0 &gt;&#x3D; 28.0 BMI 的计算方式如下: BMI &#x3D; weight (kg) &#x2F; height² (m²) 点击显/隐代码 2. 循环结构1) 遍历循环 forfor i in range(5) : 遍历5次可使用 range(N) 函数来遍历 N 次, 或遍历序列类型的每一个字符,以及文件的每一行在 for…else… 中, else 可在循环正常结束后执行 例 2: 重量计算. 月球上物体是地球的16.5％ 倍, 现有一人体重为 50kg, 该人在地球上每年增长 0.5kg, 求改人十年后在地球与月球上的体重. 点击显/隐重量计算 & 遍历 N 次的代码 例 3: 统计出现次数. 输入一串字符, 分别统计大小写, 数字空格和其他字符的个数. 点击显/隐遍历序列类型的每一个字符 2) 条件循环 while用于无法确定循环次数的情况, 也可以与 else 连用, 同样为当循环正常结束时执行. 例 4: 最大公约数与最小公倍数的计算. 要求: 两个整数. 点击显/隐最大公约数与最小公倍数的代码 3. 异常处理通常, 异常处理只用在用户输入的合规性以及文件打开是否成功.异常处理的相关语法如下: 点击显/隐异常处理语法 4. random 库主要用于生成各式各样的随机数. 点击显/隐各式各样的随机数 5. 综合案例 田字格输出. 如图所示. — — — — + — — — — + | | | | | | | | | | | | — — — — + — — — — + | | | | | | | | | | | | — — — — + — — — — + 点击显/隐田字格输出的代码 下面以猜数游戏三个版本来依次展现 “分支, 条件循环结构的基础版本” , “加上随机数的版本” 以及 “加上异常处理结构” 的代码.a. 猜数游戏 1.0 : 在程序中预设一个数 5, 用户通过键盘输值开始猜数 (限制猜数范围为 0 ~ 10 ) , 若猜大显示 “猜得过大了” , 反之, 显示 “猜的过小了” , 直至猜中, 显示 “恭喜第 N 次猜中了” , 其中 N 是用户所猜次数. 点击显/隐猜数游戏 1.0 b. 猜数游戏 2.0 : 在猜数游戏 1.0 的基础上, 将键盘预设数字改为随机数 点击显/隐猜数游戏 2.0 c. 猜数游戏 3.0 : 在猜数游戏 2.0 的基础上, 若用户输入非法字符或超出 范围的数字时, 提示: “请输入整数! (0 ~ 10) “ , 并让用户重新输入. 点击显/隐猜数游戏 3.0 回文数判断. 回文数是指正着读与反着读都一样的数字, 如 12321, 38583 等. 请设定一程序, 使其能判断该 5 位数字是否为回文数. 点击显/隐回文数判断代码 羊车门问题. 羊车门问题描述: 有3扇关闭的门, 一扇门后停着汽车, 另外两扇门后是山羊, 主持人知道每扇门后是什么. 参赛者首先选择一扇门, 在开启它之前, 主持人会从另外两扇门中打开一扇门, 露出门后的山羊. 此时, 允许参赛者更换自己的选择. 请问, 参赛者更换选择后, 能否增加猜中汽车的机会? 点击显/隐羊车门问题代码"},{"title":"第四章  类与对象","date":"2022-01-29T09:16:49.203Z","url":"/posts/java-lydx/","categories":[["java","/categories/java/"]],"content":"哈哈大家好啊~点击more一起阅读吧! 类类,是对对象的抽象,是创建对象的模板类的修饰符只能是公共,抽象,终态这四个公共类可以被任意包使用抽象类终态类不能被继承定义类的格式: 类中成员分为两种:成员变量和成员函数 对象对象,是事物的抽象,有对象标识,属性和方法.是类的实例如何创建对象?下述第一+二步:声明引用变量+创建对象 第三步:初始化对象有三种方法实现:默认初始化原则;赋值语句;构造方法 构造方法类的方法中方法名和类名相同的类方法.构造方法的修饰符只能是公共,保护,私有这四个. 封装机制对该类的访问限制以类修饰符来体现.1.无修饰符:包中类2.public:所有类(包外类import引入)3.final:不能被继承4.abstract 数据成员 成员方法"},{"title":"封装机制与访问控制","date":"2022-01-29T07:01:53.798Z","url":"/posts/java-fzjzyfwkz/","categories":[["java","/categories/java/"]],"content":"1.封装机制关于类的定义[类修饰符] class 类名 [extends 父类名] [implements 接口列表] &#123; 数据成员 成员方法 &#125; 类修饰符类修饰符是用来说明对它的访问限制.当一个类前无修饰符,则只能被包中其他类使用.当一个类前public符,则可被所有包使用,用import引入其他包.当一个类前final符,则该类不能被继承.当一个类前abstract符,见第五章 属性和方法修饰符属性和方法修饰符分为访问控制修饰符和非访问控制修饰符两大类.访问控制符 |类前修饰符|属性和方法前修饰符|||||—–|—–|| |缺省|公共|私有|保护||缺省|包中其他类|包中其他类|当前类本身|包中其他类||公共|包中其他类|所有类|当前类本身|包中其他类及其子类| 若一个属性前用static符,任何对象访问到的数值都相同; 可以通过引用变量或类名加点访问它.若一个属性前用final符,其值不可改变.若一个方法前用static符,可以通过引用变量或类名加点访问它;只能访问static属性和方法,但非static方法可以访问所有属性和方法;不能被覆盖."},{"title":"消息, 继承与多态","date":"2022-01-29T03:20:11.856Z","url":"/posts/java-xxjcydt/","categories":[["java","/categories/java/"]],"content":"本篇讲述了消息,多态与继承两种机制,抽象类接口与包. 重点内容 什么是消息?什么是公有消息和私有消息? 什么是多态机制?重载与覆盖有什么区别? 什么是继承机制?它的特征是什么? 什么是抽象类?使用时要注意哪些问题? 什么是接口?使用时要注意哪些问题? 什么是包?包的作用是哪些? 消息消息就是属性与方法的引用.当有一批消息同属于一个对象时,由外界发送给对象的消息称为公有消息;由对象发送给自身的消息称为私有消息,外界不必了解它. 多态机制多态指同名而不同内容的方法共存的情况.当在同一类中定义,称为重载.当在父子类中定义,称为覆盖. 继承机制继承使子类具有父类(超类,基类)的全部或部分的属性和方法.继承提供了软件复用功能与多重继承(接口)机制.属性的继承,方法的继承属性的隐藏,方法的覆盖this用来访问当前对象,super用来访问当前对象的直接父类对象. 抽象类1.声明抽象类注意事项:不能与final修饰一个类2.定义抽象类注意事项:抽象类的属性, 构造方法, 和非抽象方法与类相同;抽象类的抽象方法前须修饰符;且只能修饰public.protected3.类实现抽象方法注意事项:必须实现构造方法和抽象方法 接口1.定义接口注意事项:接口的属性默认终静态;接口的所有方法是公共抽象方法.无构造方法;2.类实现接口注意事项:方法必须显式使用public符. 代码演示 实现方法的重载. 实现方法的覆盖. 实现属性的隐藏. 实现抽象类, 多重继承机制.方法重载 抽象类 "},{"title":"递归调用","date":"2022-01-29T02:59:28.554Z","url":"/posts/java-dgdy/","categories":[["java","/categories/java/"]],"content":"递归调用使用递归算法求解累加和 使用递归算法求解累乘积"},{"title":"第六章  数组","date":"2022-01-27T03:07:03.856Z","url":"/posts/java-sz/","categories":[["java","/categories/java/"]],"content":"第六章 数组一维数组 打印一维数组元素的值 二维数组 打印二维数组元素的值 创建数组对象创建对象:类名 引用变量 =new 类名(&quot;李华&quot;,&quot;男&quot;);创建数组对象: 类名 引用变量[]&#x3D;new 类名[length]; 引用变量[0]&#x3D;new 类名(“李华”,”男”); 引用变量[1]&#x3D;new 类名(“张三”,”男”); 数组元素排序 一维冒泡法排序 一维查找最大数 二维查找最大数 4.二分查找程序 class CommonBinarySearch { int commonBinarySearch(int[] arr,int key){ int low &#x3D; 0; int high &#x3D; arr.length - 1; int middle &#x3D; (low+high)&#x2F;2; &#x2F;&#x2F;定义middle if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high){ return -1; } while(low &lt;&#x3D; high){ middle &#x3D; (low + high) &#x2F; 2; if(arr[middle] &gt; key){ &#x2F;&#x2F;比关键字大则关键字在左区域 high &#x3D; middle - 1; }else if(arr[middle] &lt; key){ &#x2F;&#x2F;比关键字小则关键字在右区域 low &#x3D; middle + 1; }else{ return middle; } } return -1; &#x2F;&#x2F;最后仍然没有找到，则返回-1 } }"},{"title":"程序流程控制","date":"2022-01-26T12:08:32.902Z","url":"/posts/java-cxlckz/","categories":[["java","/categories/java/"]],"content":"程序流程控制选择结构程序设计 if()…else… 2.switch() {case 0:…;break;default:…;} 循环程序结构设计递归调用示例程序1:Fibonacci数列的前38个数.解:package p_name; public class c_name { public static void main(String args[]) { FibonacciRecursion f&#x3D;new FibonacciRecursion(); for(int i &#x3D; 1;i&lt;&#x3D;38&#x2F;2;i++) { System.out.println(f.fiborecur(i)); } }}class FibonacciRecursion { int fiborecur(int n) { if(n&#x3D;&#x3D;1) return 1; else if(n&#x3D;&#x3D;2) return 1; else return fiborecur(n-1)+fiborecur(n-2); } }"},{"title":"键盘输值","date":"2022-01-26T04:21:12.288Z","url":"/posts/java-wjyl/","categories":[["java","/categories/java/"]],"content":"键盘输值package p_name;import java.io.*;public class c_name { public static void main(String args[])throws IOException { BufferedReader keyin&#x3D;new BufferedReader(new InputStreamReader(System.in)); int y&#x3D;Integer.parseInt(keyin.readLine());"},{"title":"本篇用于测试样式","date":"1998-12-31T16:00:00.000Z","url":"/posts/This-article-is-used-to-test-the-style/","categories":[["测试区","/categories/%E6%B5%8B%E8%AF%95%E5%8C%BA/"]],"content":"模板更新2 折叠 摘要1自定义正文 折叠摘要2自定义正文 圈i 蓝底 注释有以下几点 圈! 绿底 清新要注意的是 灯泡 紫底 提醒不容忽视的是 三角中间感叹 黄底 警告需要提醒的是 火 红底 错误严重的是 "},{"title":"404","date":"2022-08-16T09:02:39.348Z","url":"/404.html","categories":[[" ",""]]},{"title":"友链","date":"2022-08-30T00:56:13.138Z","url":"/page_friends/index.html","categories":[[" ",""]]},{"title":"主页","date":"2022-08-16T11:59:28.771Z","url":"/page_home/index.html","categories":[[" ",""]]},{"title":"搜索","date":"2022-08-16T09:02:25.148Z","url":"/page_search/index.html","categories":[[" ",""]]},{"date":"2022-09-11T03:43:39.488Z","url":"/%E6%9C%AA%E7%A6%BB%E7%9A%84%E5%B0%8F%E7%99%BE%E7%A7%91/%E6%9C%AA%E7%A6%BB%E7%9A%84%E8%AF%8D%E5%85%B8.html","categories":[[" ",""]],"content":"验证校验和"},{"title":"锦鲤未离的博客开发日志","date":"2022-09-23T14:00:00.000Z","url":"/development_log/index.html","categories":[[" ",""]],"content":"2022 年 09 月 23 日记录 [添加]： 在轮播图中添加了“开发日志”图片，为轮播图中第一张。 在分页流中添加了“开发日志”超链接，其缀在最后。 [修改]： 延申了搜索框的长度，在手机版上体验更佳！ 纠正了点击“分类流”中某分类无法跳转至该分类的问题。 纠正了打开“联系我”后第四个图标最先出现的问题。 2022 年 09 月 22 日（含）前已不可考证于 2022 年 01 月 16 日创建"}]