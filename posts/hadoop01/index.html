<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  
  <title>第一章  分布式文件系统（HDFS）概述 | 锦鲤未离</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <link rel="stylesheet" href="/css/hlight-main.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>document.title = `第一章  分布式文件系统（HDFS）概述`</script>
<meta name="generator" content="Hexo 6.1.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <!-- <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div> -->
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"⌊手机篇⌉ 将手机投屏到电脑","path":"posts/EDp-scrcpy/"},{"title":"⌊电脑篇⌉ 电脑声音无法出现","path":"posts/EDc-sound/"},{"title":"Hello World","path":"posts/3eeb/"},{"title":"小贴士~","path":"posts/tips/"},{"title":"数据库实训-Eclipse 连接 MySQL","path":"posts/EconnectM/"},{"title":"考试---可视化","path":"posts/考试---可视化/"},{"title":"第三章  程序流程控制[未完成]","path":"posts/matlab03/"},{"title":"应用篇-第一章  图形对象句柄[未完成]","path":"posts/matlab09/"},{"title":"第五章  数据分析与多项式计算[未完成]","path":"posts/matlab05/"},{"title":"应用篇-第二章  图形对用户界面设计[未完成]","path":"posts/matlabyyp02/"},{"title":"第四章 绘图[未完成]","path":"posts/matlab04/"},{"title":"程序流程控制","path":"posts/java-cxlckz/"},{"title":"消息, 继承与多态","path":"posts/java-xxjcydt/"},{"title":"第六章  数组","path":"posts/java-sz/"},{"title":"键盘输值","path":"posts/java-wjyl/"},{"title":"封装机制与访问控制","path":"posts/java-fzjzyfwkz/"},{"title":"第四章  类与对象","path":"posts/java-lydx/"},{"title":"递归调用","path":"posts/java-dgdy/"},{"title":"『SQL Server』第一章  数据库应用系统开发方法","path":"posts/sqlserver01/"},{"title":"『SQL Server』第七章  高级数据库查询","path":"posts/sqlserver07/"},{"title":"『SQL Server』第三章  系统设计","path":"posts/sqlserver03/"},{"title":"『SQL Server』第九章  安全管理","path":"posts/sqlserver09/"},{"title":"『SQL Server』第二章  需求分析","path":"posts/sqlserver02/"},{"title":"『SQL Server』第五章  UML与DBAS","path":"posts/sqlserver05/"},{"title":"『SQL Server』第八章  数据库后台编程技术","path":"posts/sqlserver08/"},{"title":"『SQL Server』第六章  数据库及其对象.md","path":"posts/sqlserver06/"},{"title":"『SQL Server』第十一章  故障管理","path":"posts/sqlserver11/"},{"title":"『SQL Server』第十三章  大规模数据库架构","path":"posts/sqlserver13/"},{"title":"『SQL Server』第十四章  数据仓库与数据挖掘","path":"posts/sqlserver14/"},{"title":"『SQL Server』第十二章  备份与恢复数据库","path":"posts/sqlserver12/"},{"title":"『SQL Server』第十章  数据库运行管理与维护","path":"posts/sqlserver10/"},{"title":"『SQL Server』第四章  应用系统功能设计","path":"posts/sqlserver04/"},{"title":"『SQL Server』考三","path":"posts/sqlserver3/"},{"title":"『SQL Server』考二","path":"posts/sqlserver2/"},{"title":"三级考试(数据库篇)错题整理(选择题, 填空题篇)","path":"posts/sqlservers/"},{"title":"第一章  操作基础","path":"posts/linux01/"},{"title":"第二章  进程管理","path":"posts/linux02/"},{"title":"第三章  存储和逻辑卷管理","path":"posts/linux03/"},{"title":"第四章  用户和组管理","path":"posts/linux04/"},{"title":"第六章  用户管理","path":"posts/linux05/"},{"title":"第六章  网络基础","path":"posts/linux06/"},{"title":"安全管理","path":"posts/linux07/"},{"title":"第十章 Shell 脚本","path":"posts/linux08/"},{"title":"第一章  操作基础","path":"posts/linuxlianxizuoye/"},{"title":"第八章  计算生态","path":"posts/python08/"},{"title":"第九章  标准库概览","path":"posts/python09/"},{"title":"第七章  文件和数据格式化","path":"posts/python07/"},{"title":"第十章  第三方库概览","path":"posts/python10/"},{"title":"第一章  程序基本结构","path":"posts/py01/"},{"title":"第一章  程序基本结构","path":"posts/py01/"},{"title":"第三章  组合数据类型","path":"posts/py03/"},{"title":"第某章  random 库","path":"posts/pythonrdom/"},{"title":"第某章  PIL 库","path":"posts/py0nnnpillow/"},{"title":"第某章  turtle 库","path":"posts/py0nnn/"},{"title":"第二章  函数","path":"posts/py02/"},{"title":"第五章  文件操作","path":"posts/python05/"},{"title":"第六章  第三方生态","path":"posts/python06/"},{"title":"第一章  排序","path":"posts/dsa04/"},{"title":"第一章  线性表","path":"posts/dsa01/"},{"title":"第二章  查找","path":"posts/dsa05/"},{"title":"第三章  图","path":"posts/dsa03/"},{"title":"第二章  树和二叉树","path":"posts/dsa02/"},{"title":"绪论  聊聊需要的软件","path":"posts/hadoop00/"},{"title":"第一章  分布式文件系统（HDFS）概述","path":"posts/hadoop01/"},{"title":"第二章  磁盘I/O操作","path":"posts/hadoop02/"},{"title":"第三章  MapReduce基础","path":"posts/hadoop03/"},{"title":"第一章  数据计算（NumPy）","path":"posts/DPaA01/"},{"title":"第二章  数据分析（Pandas）","path":"posts/DPaA02/"},{"title":"第三章  数据可视化（Matplotlib）","path":"posts/DPaA03/"},{"title":"第四章  数据预处理","path":"posts/DPaA04/"},{"title":"第 4 章  抽样推断","path":"posts/as04/"},{"title":"第一章 待补充...","path":"posts/DM01/"},{"title":"第1章  时间序列分析","path":"posts/Time-Series_Analysis_ALL/"},{"title":"配置hadoop","path":"posts/This-article-is-used-to-test-the-style/"},{"title":"第4章  Spark SQL结构化数据文件处理","path":"posts/spark_04/"},{"title":"第3章  Spark RDD弹性分布式数据集","path":"posts/spark_03/"},{"title":"第5章  HBase 分布式数据库","path":"posts/spark_05/"},{"title":"第6章  Kafka分布式发布订阅消息系统","path":"posts/spark_06/"},{"title":"第7章  Spark Streaming","path":"posts/spark_07/"},{"title":"第1章  Scala语言基础.","path":"posts/spark_01/"},{"title":"第8章  Spark MLlib机器学习算法库","path":"posts/spark_08/"},{"title":"第1章  点云图","path":"posts/NPJS_2303_03/"},{"title":"第1章  深度卷积神经网络分析","path":"posts/DCNN_ALL/"},{"title":"机器学习-代码复习","path":"posts/asdasdasdasdasdsa/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <style>

      </style>
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">KoiNL.</p>
        <div class="main-left--tags" style="text-align: right;">
          <span class="main-left--tag">愿世间美好</span>
          <span class="main-left--tag">温柔以待</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“锦鲤握运，未离我韵”</p>
        <p>“愿好运常在”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/koinl"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>18</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>0</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>16 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>84 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>522天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v3.0.0</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <style>
/* 代码块复制按钮 */
.highlight {
    /* 方便copy代码按钮（btn-copy）的定位 */
    position: relative;
}
.btn-copy {
    display: inline-block;
    cursor: pointer;
    background-color: #eee;
    background-image: linear-gradient(#fcfcfc, #eee);
    border: 1px solid #d5d5d5;
    border-radius: 3px;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-appearance: none;
    font-size: 13px;
    font-weight: 700;
    line-height: 20px;
    color: #333;
    -webkit-transition: opacity .3s ease-in-out;
    -o-transition: opacity .3s ease-in-out;
    transition: opacity .3s ease-in-out;
    padding: 2px 6px;
    position: absolute;
    right: 5px;
    top: 5px;
    opacity: 0;
}
.btn-copy span {
    margin-left: 5px;
}
.highlight:hover .btn-copy {
    opacity: 1;
}

pre::-webkit-scrollbar {
  width: 5px;
  height: 10px;
  background-color:#F5F5F5;
}
/*定义滚动条轨道
内阴影+圆角*/
pre::-webkit-scrollbar-track {
  background-color:#F5F5F5;
}
/*定义滑块
内阴影+圆角*/
pre::-webkit-scrollbar-thumb {
  background-color: rgb(69, 83, 100);
}

pre:active {
  background-color: rgb(81, 95, 116);
}
pre {
  width: 100% !important;
	    float: left !important;
	    overflow: hidden !important;
	    text-overflow: ellipsis !important;
	    /* white-space: normal !important; */
}


</style>

<div class="article-container">
  <div class="article">
    <h1 class="article-title">第一章  分布式文件系统（HDFS）概述</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            <a class="category-link" href="/categories/Hadoop/">Hadoop</a>
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            
          </div>
          
          <p class="article-info--date">创建日期：2022-09-07 12:18:31</p>
        </div>
        <img src="https://t7.baidu.com/it/u=3652245443,3894439772&fm=193&f=GIF" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content">
      <p>HDFS 是一个支持海量数据存储的分布式文件系统，是存储大数据文件的重要载体。本章主要介绍了 HDFS 的体系结构、运行机制、工作流程和基本操作。</p>
<h2 id="一、HFDS-概述"><a href="#一、HFDS-概述" class="headerlink" title="一、HFDS 概述"></a>一、HFDS 概述</h2><h3 id="1-HDFS-的设计目标和不足"><a href="#1-HDFS-的设计目标和不足" class="headerlink" title="1. HDFS 的设计目标和不足"></a>1. HDFS 的设计目标和不足</h3><blockquote>
<p>设计目标：</p>
<ol>
<li>支持超大文件存储</li>
<li>采用一次写入多次读取（write-once-read-many）访问模型</li>
<li>具有故障检测和快速自动恢复功能</li>
<li>采用流式数据访问</li>
<li>支持移动计算</li>
</ol>
</blockquote>
<blockquote>
<p>不足：</p>
<ol>
<li>不适合处理低延迟数据访问</li>
<li>无法高效存储大量小文件</li>
<li>不支持多用户写入和任意修改文件</li>
</ol>
</blockquote>
<h3 id="2-HDFS-的体系结构"><a href="#2-HDFS-的体系结构" class="headerlink" title="2. HDFS 的体系结构"></a>2. HDFS 的体系结构</h3><p>HDFS 是一个<strong>主&#x2F;从（master&#x2F;slave）</strong>架构的系统，即一个 HDFS 集群由一个 <strong>NameNode</strong> 和若干 <strong>DataNode</strong> 组成。它俩也是 HDFS 的<strong>核心组件</strong>，其中，NameNode 被称为“<strong>元数据节点</strong>”、另一个被称为“<strong>数据节点</strong>”。</p>
<h4 id="3-数据块（block）"><a href="#3-数据块（block）" class="headerlink" title="3. 数据块（block）"></a>3. 数据块（block）</h4><p>磁盘数据块是磁盘读写的最小单位，也只能读写块整倍大小的数据。HDFS 的默认数据块大小为 <strong>128MB</strong>。</p>
<blockquote>
<p>通常为512B，那为什么设置这么大？<strong>数据块越大，寻址开销越小</strong>。当然，盲目过大也不行，MapReduce 中的 Map 一次只处理一个块的内容，<strong>过大会导致整体任务量变少</strong>，进而影响数据的<strong>并行</strong>处理速度。</p>
</blockquote>
<blockquote>
<p>优点：<br>可以存储任意大小的数据文件，只要物理切片就可以。<br>简化了存储系统的管理：元数据信息和文件数据信息分开管理。<br>有利于实现分布式文件系统的容错性：一个节点出故障，其他块读取副本。<br>有利于实现负载军和并提高集群可靠性：某个数据节点的剩余空间低于临界点，就将这个数据节点移动到其他的数据节点上；此外，数据块的副本被安排在不同的机架上，即使丢失某台机架，读取副本即可，大大提高了集群的可靠性。与此同时，Hadoop 的故障检测和快速自动回复功能就可以及时将这些块副本数量恢复到正常水平。</p>
</blockquote>
<h4 id="4-NameNode-和-SecondaryNameNode"><a href="#4-NameNode-和-SecondaryNameNode" class="headerlink" title="4. NameNode 和 SecondaryNameNode"></a>4. NameNode 和 SecondaryNameNode</h4><h5 id="1-元数据节点（NameNode）"><a href="#1-元数据节点（NameNode）" class="headerlink" title="1) 元数据节点（NameNode）"></a>1) 元数据节点（NameNode）</h5><p>管理 HDFS 文件系统的命名空间（namespace）。其实就是 HDFS 的目录结构，用户可以进行增删改重命名等 HDFS 文件。</p>
<blockquote>
<p>所存储的元数据信息：</p>
<ol>
<li>文件名、目录名与层次关系</li>
<li>文件目录的属主和权限</li>
<li>每个文件由哪些数据块组成</li>
<li>数据块到数据节点的映射信息</li>
</ol>
</blockquote>
<p>元数据信息被持久化的存到本地磁盘的两个文件中：<strong>fsimage（元数据镜像文件）</strong>和 <strong>edits（事务日志文件）</strong>。</p>
<p>元数据节点正常运行时，所有更新操作被写入 edits 文件中，如果直接写入元数据镜像文件，逐渐一段时间后，过大会导致系统运行速度变慢。即 edits 文件越来越大，不会对系统有明显影响，但是元数据节点的重启过程会越来越慢。</p>
<h5 id="2-SecondaryNameNode（辅助者-·-元数据节点）"><a href="#2-SecondaryNameNode（辅助者-·-元数据节点）" class="headerlink" title="2) SecondaryNameNode（辅助者 · 元数据节点）"></a>2) SecondaryNameNode（辅助者 · 元数据节点）</h5><p>解决掉 edits 文件过大的问题。是对 元数据镜像文件和事务日志文件进行定期合并。由于合并时需要消耗内存，因此通常这俩<strong>没在一个节点</strong>上面。</p>
<blockquote>
<p>优点：</p>
<ol>
<li>提升了集群性能，保存了元数据节点的元数据信息，一定程度上提高了元数据的安全性和可靠性。</li>
</ol>
</blockquote>
<h5 id="3-数据节点（DataNode）"><a href="#3-数据节点（DataNode）" class="headerlink" title="3) 数据节点（DataNode）"></a>3) 数据节点（DataNode）</h5><p>一个数据节点有多个数据块，每个数据块会在多个数据节点上存储副本，但一个数据节点只能有一个副本。</p>
<blockquote>
<p>作用：<br>负责向<strong>客户端</strong>或<strong>元数据节点</strong>提供数据的检索和读写服务，并通过<strong>心跳机制</strong>定期向元数据节点发送自己的块列表信息。<br>一般情况下，数据节点会从磁盘中读取数据块，但如果某个块被频繁访问，系统会将其存放在数据节点的内存中。</p>
</blockquote>
<h6 id="从现有集群里面动态增加一个数据节点，怎么破？"><a href="#从现有集群里面动态增加一个数据节点，怎么破？" class="headerlink" title="从现有集群里面动态增加一个数据节点，怎么破？"></a>从现有集群里面动态增加一个数据节点，怎么破？</h6><p>—索引眼：<em>增加数据节点<strong>增加一个数据节点</strong>增加一个DataNode<strong>增加DataNode</strong>hadoop04**Hadoop04</em>—</p>
<h2 id="二、数据错误与恢复"><a href="#二、数据错误与恢复" class="headerlink" title="二、数据错误与恢复"></a>二、数据错误与恢复</h2><p>HDFS 的主要目标有一条是“具有故障检测和快速自动恢复功能”，这就要求即使再出错的情况下也要保证数据存储的可靠性。常见的出错情况包括block 损坏、NameNode 和 DataNode 的错误。</p>
<h3 id="1-block-损坏处理"><a href="#1-block-损坏处理" class="headerlink" title="1. block 损坏处理"></a>1. block 损坏处理</h3><p><strong>网络传输错误</strong>和<strong>机器硬件故障</strong>等因素会造成数据损坏。<br>客户端在读取文件时会对每个读取的块进行校验，如果出错，就会读取其他数据节点上的数据块，并将错误块报告给元数据节点，元数据节点随后会重新复制。<br>此外，每一个数据节点都会开启一个<strong>块扫描进程</strong>，来定期验证块的正确性，不正确会报告给元数据节点进行处理。</p>
<h3 id="2-NameNode-和-DataNode-错误处理"><a href="#2-NameNode-和-DataNode-错误处理" class="headerlink" title="2. NameNode 和 DataNode 错误处理"></a>2. NameNode 和 DataNode 错误处理</h3><h4 id="1-NameNode-错误处理"><a href="#1-NameNode-错误处理" class="headerlink" title="1) NameNode 错误处理"></a>1) NameNode 错误处理</h4><p>NameNode 上保存了元数据信息，仅此一份独一无二，因此必须确保该安全。</p>
<blockquote>
<p>容错方式有以下三种：</p>
<ol>
<li>元数据信息持久化到本地磁盘并同步到 NFS 中，但会因网络带宽等原因造成元数据丢失。</li>
<li>运行 SecondaryNameNode。但由于该备份的元数据信息滞后于 NameNode，所以也会丢失掉部分的数据信息。</li>
<li>启用主备两个NameNode。</li>
</ol>
</blockquote>
<h2 id="三、HDFS的运行机制"><a href="#三、HDFS的运行机制" class="headerlink" title="三、HDFS的运行机制"></a>三、HDFS的运行机制</h2><h3 id="1-副本机制"><a href="#1-副本机制" class="headerlink" title="1. 副本机制"></a>1. 副本机制</h3><blockquote>
<p>作用：<br>为了维护爱与和平…咳咳串台了，再来！为了保证集群的容错性和可用性。</p>
</blockquote>
<h3 id="2-心跳机制"><a href="#2-心跳机制" class="headerlink" title="2. 心跳机制"></a>2. 心跳机制</h3><p>NameNode 启动后，会等待所有 DataNode 的“心跳”：DataNode 每隔一定间隔（默认三秒）主动向 NameNode 发送“心跳”，主动报告自己的状态信息。然后 NameNode 通过心跳向 DataNode 下达命令。<br>如果长时间未收到，则可以证明该 DataNode 宕机，然后检查该 DataNode 上的块副本信息并备份到其他的 DataNode 上。<br>对了，DataNode 会给主备主数据节点都会发送“心跳”。</p>
<h3 id="3-副本放置与机架感应策略"><a href="#3-副本放置与机架感应策略" class="headerlink" title="3. 副本放置与机架感应策略"></a>3. 副本放置与机架感应策略</h3><h4 id="1-副本放置"><a href="#1-副本放置" class="headerlink" title="1) 副本放置"></a>1) 副本放置</h4><p>一个集群中多个机架，每个机架上多个数据节点，每个数据节点保存多个块副本。另外，元数据节点的元数据存储着每个数据节点所属的机架 ID。那么，如何分配文件的块副本到集群中的数据节点上面呢？</p>
<p>默认下，副本的配置数为 3，其中，有两个被放在同一机架的不同数据节点上面，另外一个被另一个机架上。</p>
<blockquote>
<p>一般情况下，3 个足矣。若大于等于 3，则之后的副本可以随意放置。避免一个机架有太多同意副本即可。</p>
</blockquote>
<h4 id="2-机架感应（rack-aware）"><a href="#2-机架感应（rack-aware）" class="headerlink" title="2) 机架感应（rack-aware）"></a>2) 机架感应（rack-aware）</h4><p>由于副本的存放位置会影响 HDFS 的可靠性和性能，HDFS 采用了一种机架感知策略来提高数据的可靠性，并提高网络带宽的利用率。<br>这样一来，即使一个机架发生故障，由于其他机架上的副本仍然可用，不会影响数据的可靠性。另外，当读取数据时，应用程序可用在多个机架上同时读取，大大提高数据的读取速度。</p>
<h3 id="4-联邦（Federation）机制"><a href="#4-联邦（Federation）机制" class="headerlink" title="4. 联邦（Federation）机制"></a>4. 联邦（Federation）机制</h3><p>每个文件的元数据信息都需要保存到 NameNode 的内存中，于是便有了联邦机制。</p>
<blockquote>
<p>作用：<br>集群横向扩展的方式解决 NameNode 的瓶颈问题，即<strong>增加元数据节点的数量</strong>。<br>由于 Hadoop 针对海量数据进行存储管理，并采用了数据冗余存储方式，所以<strong>磁盘I&#x2F;O才是集群的《主要瓶颈》。</strong></p>
</blockquote>
<p>在联邦机制中，每个 NameNode 分别管理文件系统命名口径的一部分（命名空间卷）。各卷中分别存储了命名空间的元数据和文件数据块的块池。同时，各卷相互独立互不影响互不通信。此外，集群中的所有 DataNode 都必须注册到各个 NameNode。</p>
<p>不过，没有解决掉单点故障问题，若某一个 NameNode 失效，仍无法恢复无法访问。</p>
<h3 id="5-HA（7-24小时不中断服务）-机制"><a href="#5-HA（7-24小时不中断服务）-机制" class="headerlink" title="5. HA（7*24小时不中断服务） 机制"></a>5. HA（7*24小时不中断服务） 机制</h3><p>所谓HA，即高可用（7*24小时不中断服务）。实现高可用最关键的是消除单点故障。<br>方式：允许运行主备两个 NameNode，当 NameNode 节点发生故障时，可以快速启用备用的 NameNode，以确保集群正常运行。</p>
<p>备主数据节点和主主数据节点始终同步（元数据信息一致），它们之间通过 JournalNode 守护进程进行通信。</p>
<h3 id="6-安全模式"><a href="#6-安全模式" class="headerlink" title="6. 安全模式"></a>6. 安全模式</h3><p>启用后，就进入了安全模式。该模式下，主数据节点会检查块的完整性。此外，它还是一种只读模式。<br>正常情况下，NameNode启动（额外延迟30s）就会退出安全模式，但是如果DataNode 丢失的数据块超过设定的值，集群就会一直处于安全模式。</p>
<p>两件事</p>
<ol>
<li>等待每个数据节点的心跳，判断是否宕机，然后NameNode 将 DataNode 所发送的 block 报告与其元数据进行对比，以判断数据块是否正常。</li>
<li>在内存中加载 fsimage，然后将 fsimage 和edits 合并成新的 fsimage，并创建一个新的 edits。合并完成后删除旧的 fsimage 和 edits，并将新的俩重命名。<h3 id="7-垃圾回收"><a href="#7-垃圾回收" class="headerlink" title="7. 垃圾回收"></a>7. 垃圾回收</h3>没有任何利用价值的块副本被认为是垃圾：若一个文件被删除，那么备份的该文件副本也就没有用。<br>删除不会直接删除，会移动到回收站。<h2 id="四、HDFS-的工作流程"><a href="#四、HDFS-的工作流程" class="headerlink" title="四、HDFS 的工作流程"></a>四、HDFS 的工作流程</h2>在 Hadoop 集群中，<strong>客户端</strong>与<strong>元数据节点</strong>之间的通信、<strong>元数据节点</strong>与<strong>数据节点</strong>之间的通信、<strong>数据节点</strong>相互之间的通信、都是基于 <strong>RPC（远程过程调用）</strong>机制的。</li>
</ol>
<h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1. 启动流程"></a>1. 启动流程</h3><p>在 HDFS 的启动过程中，需要启动 NameNode 和DataNode。<br>启动时，会先进入安全模式。<br>数据节点启动时，会开启一个 DataBlockScanner 进程来扫描 block，并且由该进程定期向各个 NameNode 发送“心跳”。</p>
<h3 id="2-读流程"><a href="#2-读流程" class="headerlink" title="2. 读流程"></a>2. 读流程</h3><p>Client 读取时，首先会访问 NameNode 以确认是否可以读取。是，则 Client 获得文件的 block 和 DataNode 信息，然后执行 HDFS 的读操作来获取数据。在读取数据结束后，需要关闭文件输入流。</p>
<h3 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3. 写流程"></a>3. 写流程</h3><p>Client 将数据预备写入到 HDFS 文件时，首先会访问 NameNode 确认写入的权限和文件是否存在（存在是否覆盖）。是，Client 在 NameNode 上创建写入文件的元数据信息，并返回可存储数据的 block 和 DataNode 信息，然后根据返回信息执行副本复制过程。写入结束后，需要关闭文件输出流。</p>
<h3 id="4-删除流程"><a href="#4-删除流程" class="headerlink" title="4. 删除流程"></a>4. 删除流程</h3><h4 id="1-使用-HDFS-命令删除文件"><a href="#1-使用-HDFS-命令删除文件" class="headerlink" title="1) 使用 HDFS 命令删除文件"></a>1) 使用 HDFS 命令删除文件</h4><p>root 用户的回收站目录为 <code>hdfs://hadoop0:9000/user/root/.Trash</code>。<br>当用户使用 HDFS 命令执行删除操作后，系统会将需要删除的文件移动到回收站内的“&#x2F;Current”下。例如，root用户删除了“koinl01.txt”文件，就可以在 <code>hdfs://hadoop0:9000/user/root/.Trash/Current/koinl01.txt</code> 找到。<br>回收站也是有时间周期滴。</p>
<h4 id="2-使用-Java-API-删除文件"><a href="#2-使用-Java-API-删除文件" class="headerlink" title="2) 使用 Java API 删除文件"></a>2) 使用 Java API 删除文件</h4><p>需要有一段延迟时间，才可以真正删除掉。</p>
<h2 id="五、HDFS-的基本操作"><a href="#五、HDFS-的基本操作" class="headerlink" title="五、HDFS 的基本操作"></a>五、HDFS 的基本操作</h2><p>基本操作包括：创建文件、移动文件、查看文件目录、读取文件等</p>
<h3 id="1-HDFS-命令行操作"><a href="#1-HDFS-命令行操作" class="headerlink" title="1. HDFS 命令行操作"></a>1. HDFS 命令行操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">解析</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hdfs dfs -help</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">hdfs dfs -ls &#x2F;</td>
<td align="center">查看HDFS根目录下目录和文件</td>
<td align="center">-R选项递归展示</td>
</tr>
<tr>
<td align="center">hdfs dfs -mkdir &#x2F;mywork</td>
<td align="center">根目录下创建文件夹</td>
<td align="center">-p选项多级目录</td>
</tr>
<tr>
<td align="center">hdfs dfs -put a.txt &#x2F;mywork</td>
<td align="center">虚拟机本地文件上传到HDFS中</td>
<td align="center">-f 强制覆盖</td>
</tr>
<tr>
<td align="center">hdfs dfs -get &#x2F;mywork&#x2F;a.txt &#x2F;root&#x2F;Downloads</td>
<td align="center">HDFS中文件下载到虚拟机本地</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">hdfs dfs -cp &#x2F;mywork&#x2F;a.txt &#x2F;mywork&#x2F;t1</td>
<td align="center">HDFS中文件复制到目录</td>
<td align="center">若复制到文件，即复制+重命名</td>
</tr>
<tr>
<td align="center">hdfs dfs -mv &#x2F;mywork&#x2F;a.txt &#x2F;input&#x2F;</td>
<td align="center">HDFS中文件移动到目录</td>
<td align="center">若移动到文件，即移动+重命名</td>
</tr>
<tr>
<td align="center">hdfs dfs -cat &#x2F;input&#x2F;word.txt</td>
<td align="center">HDFS中查看文件内容</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">hdfs dfs -rm &#x2F;imput&#x2F;a.txt</td>
<td align="center">HDFS中删除文件</td>
<td align="center">-r选项删除目录</td>
</tr>
<tr>
<td align="center">hdfs dfs -df&#x2F;</td>
<td align="center">查看HDFS可用空间</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="2-HDFS-Java-API-操作"><a href="#2-HDFS-Java-API-操作" class="headerlink" title="2. HDFS Java API 操作"></a>2. HDFS Java API 操作</h3><p>使用 HDFS Java API 可以远程对 HDFS 中文件进行创建、上传、下载、删除、读写等操作。</p>
<h4 id="1-新建-Map-x2F-Reduce-项目和测试类"><a href="#1-新建-Map-x2F-Reduce-项目和测试类" class="headerlink" title="1) 新建 Map&#x2F;Reduce 项目和测试类"></a>1) 新建 Map&#x2F;Reduce 项目和测试类</h4><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><p>在 Testfiles 类中添加一个<strong>用于创建目录</strong>的 createDir() 测试方法，该方法可以创建新目录<br>。</p>
<h5 id="上传-Windows-本地文件"><a href="#上传-Windows-本地文件" class="headerlink" title="上传 Windows 本地文件"></a>上传 Windows 本地文件</h5><p>在 Testfiles 类中添加一个<strong>用于上传文件</strong>的 putFiles() 测试方法，该方法用于从 Windows 系统本地上传多个文件到集群。</p>
<h5 id="下载文件到本地"><a href="#下载文件到本地" class="headerlink" title="下载文件到本地"></a>下载文件到本地</h5><p>在 Testfiles 类中添加一个<strong>用于下载文件</strong>的 getFiles() 测试方法，该方法通过正则表达式过滤出以“txt”为文件扩展名的文件并下载。</p>
<h5 id="删除文件（或目录）"><a href="#删除文件（或目录）" class="headerlink" title="删除文件（或目录）"></a>删除文件（或目录）</h5><p>在 Testfiles 类中添加一个<strong>用于删除文件（或目录）</strong>的 deleteFiles() 测试方法，该方法用于从 HDFS 中删除文件（或目录）。</p>
<h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><p>在 Testfiles 类中添加一个<strong>用于写入数据到文件</strong>的 writeHDFS() 测试方法，该方法用于向 HDFS 中写入文件。</p>
<h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><p>在 Testfiles 类中添加一个<strong>用于读取文件数据</strong>的 readHDFS() 测试方法，该方法可以分行读取文件数据。</p>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="posts/hadoop01/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81HFDS-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、HFDS 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HDFS-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E5%92%8C%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.1.</span> <span class="toc-text">1. HDFS 的设计目标和不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HDFS-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2. HDFS 的体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%9D%97%EF%BC%88block%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">3. 数据块（block）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-NameNode-%E5%92%8C-SecondaryNameNode"><span class="toc-number">1.2.2.</span> <span class="toc-text">4. NameNode 和 SecondaryNameNode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%83%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%EF%BC%88NameNode%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1) 元数据节点（NameNode）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SecondaryNameNode%EF%BC%88%E8%BE%85%E5%8A%A9%E8%80%85-%C2%B7-%E5%85%83%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2) SecondaryNameNode（辅助者 · 元数据节点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%EF%BC%88DataNode%EF%BC%89"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3) 数据节点（DataNode）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E9%9B%86%E7%BE%A4%E9%87%8C%E9%9D%A2%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A0%B4%EF%BC%9F"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">从现有集群里面动态增加一个数据节点，怎么破？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E9%94%99%E8%AF%AF%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">2.</span> <span class="toc-text">二、数据错误与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-block-%E6%8D%9F%E5%9D%8F%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">1. block 损坏处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-NameNode-%E5%92%8C-DataNode-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2. NameNode 和 DataNode 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NameNode-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">1) NameNode 错误处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81HDFS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">三、HDFS的运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">1. 副本机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">2. 心跳机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%AF%E6%9C%AC%E6%94%BE%E7%BD%AE%E4%B8%8E%E6%9C%BA%E6%9E%B6%E6%84%9F%E5%BA%94%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3. 副本放置与机架感应策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%89%AF%E6%9C%AC%E6%94%BE%E7%BD%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">1) 副本放置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%BA%E6%9E%B6%E6%84%9F%E5%BA%94%EF%BC%88rack-aware%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">2) 机架感应（rack-aware）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%81%94%E9%82%A6%EF%BC%88Federation%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">4. 联邦（Federation）机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HA%EF%BC%887-24%E5%B0%8F%E6%97%B6%E4%B8%8D%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%EF%BC%89-%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">5. HA（7*24小时不中断服务） 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">6. 安全模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.7.</span> <span class="toc-text">7. 垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HDFS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、HDFS 的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1. 启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2. 读流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3. 写流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">4. 删除流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-HDFS-%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.1.</span> <span class="toc-text">1) 使用 HDFS 命令删除文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-Java-API-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.2.</span> <span class="toc-text">2) 使用 Java API 删除文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81HDFS-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">五、HDFS 的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HDFS-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.</span> <span class="toc-text">1. HDFS 命令行操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HDFS-Java-API-%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">2. HDFS Java API 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA-Map-x2F-Reduce-%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">1) 新建 Map&#x2F;Reduce 项目和测试类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">创建目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0-Windows-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">上传 Windows 本地文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">下载文件到本地</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%88%E6%88%96%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">删除文件（或目录）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">写入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.1.6.</span> <span class="toc-text">读取数据</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/posts/hadoop02/">第二章  磁盘I/O操作</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/posts/DPaA04/">第四章  数据预处理</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>

<script src="http://cdn.yangxiang.cc/prism.js"></script>

<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: 'posts/hadoop01/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script>


<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script>
  /*页面载入完成后，创建复制按钮*/
!function (e, t, a) { 
/* code */
var initCopyCode = function(){
    var copyHtml = '';
    copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
    copyHtml += '  <i class="fa fa-globe"></i><span>copy</span>';
    copyHtml += '</button>';
    $(".highlight .code").before(copyHtml);
    new ClipboardJS('.btn-copy', {
        target: function(trigger) {
            return trigger.nextElementSibling;
        }
    });
}
initCopyCode();
}(window, document);
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="carousel" id="carousel_main">
      <ul id="div_img">
          <li class="every_img"><img src="/imgs/cover/LunBoTu/pan.jpg" id="link_img" onClick="link('https://www.csdn.net/', '_self')" alt="" title="" /></li>
          <li class="every_img"><img src="/imgs/cover/LunBoTu/development_log.jpg" id="link_img" onClick="link('https://koinl.github.io/development_log/', '_self')" alt="" title="" /></li>
          <li class="every_img"><img src="/imgs/cover/LunBoTu/home_welcome.jpg" id="link_img" onClick="link('https://koinl.github.io/page_home/', '_self')" alt="" title="" /></li>
          <li class="every_img"><img src="/imgs/cover/LunBoTu/Picture_APP_By_KoiNL.jpg" id="link_img" onClick="link('https://koinl.github.io/apk/APP_By_KoiNL.apk', '_self')" alt="" title="" /></li>
          <li class="every_img"><img src="/imgs/cover/LunBoTu/new_blog_theme.jpg" id="link_img" onClick="link('https://koinl.github.io/', '_self')" alt="" title="" /></li>
      </ul>
      <ul class="div_circle"><li class = every_circle></li><li class = every_circle></li><li class = every_circle></li><li class = every_circle></li><li class = every_circle></li></ul>
      <div class="btn left"><p class="btn_p">《&nbsp</p></div><div class="btn right"><p class="btn_p">&nbsp》</p></div>
  </div>
  <script type="text/javascript">$(function () { var max_num = 4; var time_stop = 4250; var time_swap = 1250; var num = 0; var chosen_circle_color = "#0aa1ed"; var chosen_not_circle_color = "#ffffff"; function every_thing() { $("#div_img").animate({ left: -$(".every_img").eq(0).width() * num }, time_swap); $(".every_circle").eq(num).css("background", chosen_circle_color).siblings('li').css("background", chosen_not_circle_color); } function Right_move() { if (num >= max_num) { num = 0; } else { num++; } every_thing(); } function Left_move() { if (num === 0) { num = max_num; } else { num--; } every_thing(); } $(".every_circle").eq(0).css("background", chosen_circle_color); $("#div_img").width($('.every_img').length * $('.every_img').eq(0).width()); var id = setInterval(Right_move, time_stop); $("#carousel_main").mouseover(function () { clearInterval(id) }); $("#carousel_main").mouseout(function () { id = setInterval(Right_move, time_stop); }); $(".left").click(function () { $("#div_img").stop(); Left_move(); }); $(".right").click(function () { $("#div_img").stop(); Right_move(); }); $(".every_circle").mouseover(function () { num = $(this).index(); $("#div_img").stop(); every_thing(); }); }); function link(jinliweili_Url, quality_target) { window.open(jinliweili_Url, quality_target);}</script>
    <div class="main-right--content">
      Hello~近期剽窃本站内容频发，本站唯一指定网站：https://koinl.github.io。请认准。点击<a target="_blank" rel="noopener" href="https://koinl.github.io">点击此处</a>选择进入。
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>

      <p>Theme：<a href="">koinl.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">信息来源于锦鲤未离</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        console.log(_commentDom)
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());

        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"路过人间的情书","artist":"陈恒媛","url":"music/路过人间的情书.mp3","cover":"http://p2.music.126.net/bRIshzdt9OWH0QvqHwfxjQ==/109951166380164291.jpg?param=177y177"},{"name":"安河桥","artist":"宋冬野","url":"http://ting6.yymp3.net:82/new25/songdongye/11.mp3","cover":"https://img2.baidu.com/it/u=1260056724,1076343118&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"卡布达","artist":"暂无","url":"music/kabuda.mp3","cover":"https://img2.baidu.com/it/u=705831265,2862720033&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>
  <script>
    // gray
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      if (/^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(location.pathname.replace(rootPath, ''))) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
          window.loadImageFn();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
      // $('.main-container').fadeIn()
    })
  </script>
</body>
</html>