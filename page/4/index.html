<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
  <meta charset="utf-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <link rel="icon" href="/favicon.ico">
  
  <title>锦鲤未离</title>
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/lib/fancybox/jquery.fancybox-1.3.4.css">

  <!--在这里倒入jquery 方便处理部分页面的jquery-->
  <script src="https://cdn.staticfile.org/jquery/1.7/jquery.min.js" type="text/javascript" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>
<body class="home">
	<header class="site-header navfixed-false">
  <div class="container">
      <h1><a href="/" title="锦鲤未离"><span class="octicon octicon-mark-github"></span> 锦鲤未离</a></h1>
      <nav class="site-header-nav" role="navigation">
        
              
              <a href="/"  class=" site-header-nav-item hvr-underline-from-center" title="Home">Home</a>
        
              
              <a href="/categories/"  class=" site-header-nav-item hvr-underline-from-center" title="Category">Category</a>
        
              
              <a href="/open-source/"  class=" site-header-nav-item hvr-underline-from-center" title="Open-Source">Open-Source</a>
        
              
              <a href="/message/"  class=" site-header-nav-item hvr-underline-from-center" title="Message">Message</a>
        
      </nav>
  </div>
</header>

	<section class="banner-false">
    <div class="collection-head">
        <div class="container">
            <div class="collection-title">
                <h1 class="collection-header" id="site-description">
                    
                </h1>
                <div class="collection-info">
                    
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-location">
                                   
                                        ChengDu, China
                                    
                                </span>
                                
                            
                        </span>
                    
                        <span class="meta-info">
                            
                                <span class="octicon octicon-mark-github">
                                   
                                </span>
                                
                                    <a href="http://github.com/yumemor" target="_blank">yumemor</a>
                                
                            
                        </span>
                    
                </div>
            </div>
        </div>
    </div>
</section>
	   <section class="container">
    <div class="columns">
        <div class="column two-thirds">
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202203Python/Python09第九章  标准库概览" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/python09/">第九章  标准库概览</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>9.1turtle库概述<br>turtle（海龟）是 Python重要的标准库之一，它能够进行基本的图形绘制。turtle 图形绘制的概念诞生于1969年，成功就用于LOGO编程语言。由于 turtle图形绘制概念十分直观且非常流行，Python接受了这个概念，形成了Python 的turtle库，<br>并成为标准库之一。<br>turtle 库绘制图形有一个基本框架:一个小海龟在坐标系中爬行，其爬行轨迹形成了绘制图形。对于小海龟来说，有“前进”“后退”“旋转”等爬行行为，对坐标系的探索也通过“前进方向”“后退方向”“左侧方向”和“右侧方向”等小海龟自身角度方位来完成。则开始绘制时，小海龟位于画布中，此处坐标为（o，0)，前进方向为水平右方。<br>turtle是最有价值的程序设计入门实践库,它是程序设计入门层面最常用的基本绘图库。5使用import 保留字对turtle库的引用有如下3种方式:<br>importturtle，则对turtle库中函数调用采用turtle.函数名()形式。<br>from turtle import* ,则对turtle库中函数调用直接采用函数名()形式，不再使用turtle作为前导。<br>from turtle import *circle(200)<br>import turtle as t ,则对turtle库中函数调用采用更简洁的t.函数名()形式，保留字as 的作用是将turtle库给予别名t。此处也可以使用t 之外的其他别名。<br>import turtle as t t.circle(200)<br>9.2turtle 库与基本绘图<br>turtle库包含100多个功能函数，主要包括窗体函数、画笔状态和画笔运动函数3类。<br>9.2.1窗体函数<br>turtle库的turtle.setup()函数与窗体有关。<br>函数定义如下:<br>turtle.setup(width,height,startx,starty)<br>参数详解:<br>width:窗口宽度。如果值是整数，表示的是像素值;如果值是小数，表示窗口宽度与屏幕的比例。<br>height:窗口高度。如果值是整数，表示的是像素值;如果值是小数，表示窗口高度与屏幕的比例。<br>startx:窗口左侧与屏幕左侧的像素距离。如果值是None，窗口位于屏幕水平中央。starty:窗口顶部与屏幕顶部的像素距离。如果值是None，窗口位于屏幕垂直中央。<br>import turtle<br>turtle.setup(100,100,100,100)<br>9.2.2画笔状态函数</p>
<p>pendown()：放下画笔,别名pd(),down()<br>penup()：提起画笔，与pendown()配对使用，别名pu(),up()<br>pensize(width)：设置画笔线条的粗细为指定大小，别名width()<br>pencolor()：设置画笔的颜色<br>color() I：设置画笔和填充颜色<br>begin_fill()：填充图形前,调用该方法<br>end_fill()：填充图形结束<br>filling():返回填充的状态,True为填充,False为未填充<br>clear():清空当前窗口，但不改变当前窗口的位置<br>reset():重置当前窗口，并重置位置等状态为默认值<br>screensize():设置画布窗口的宽度、.高度和背景颜色<br>hideturtle():隐藏画笔的turtle形状<br>showturtle():显示画笔的turtle形状<br>isvisible()：如果turtle可见，则返回True<br>write(str,font&#x3D;None)：输出font字体的字符串：font&#x3D;(‘Arial’,50,’normal’))<br>9.2.3画笔运动函数<br>turtle通过一组函数控制画笔的行进动作，进而绘制形状序号<br>forward(distance)：沿着当前方向前进指定距离，别名fd()<br>background(distance)：沿着当前相反方向后退指定距离，别名bk()<br>right(angle)：向右旋转angle角度<br>left(angle)：向左旋转angle角度<br>goto(x,y)：移动到绝对坐标(x,y)处<br>setx(x)：修改画笔的横坐标到x，纵坐标不变<br>sety(y)：修改画笔的纵坐标到y，横坐标不变<br>seth[eading] (angle)：设置当前朝向为angle角度<br>home()：设置当前画笔位置为原点，朝向东<br>circle(radius,e)<br>：绘制一个指定半径r和角度e的圆或弧形<br>dot(r,color)<br>：绘制一个指定半径r和颜色color的圆点<br>undo()：撤销画笔最后一步动作<br>speed()：设置画笔的绘制速度，参数为0~10之间<br>9.3random库概述<br>随机数在计算机应用中十分常见，Python语言提供了random库用于产生各种分布的伪随机数序列。random库采用梅森旋转算法生成伪随机数序列，可用于除随机性要求更高的加密算法外的大多数工程应用。<br>使用random库的主要目的是生成随机数。这个库提供了不同类型的随机数，其中最基本的函数是random.random()，它生成一个[0.0,1.0)之间的随机小数，所有其他随机数都是基于这个函数而来的。<br>seed(a&#x3D;None)：初始化随机数种子，默认值为当前系统时间<br>random()：生成一个[0.0,1.0)之间的随机小数<br>randint(a,b)：生成一个[a,b]之间的整数<br>getranddbits(k)：生成一个k比特长度的随机整数<br>randrange(start,stop[,step])：生成一个[start,stop)之间以step为步数的随机整数<br>uniform(a,b)：生成一个[a,b]之间的随机小数<br>choice(seq)：从序列类型中随机返回一个元素<br>shuffle(seq)：将序列类型中元素随机排列，返回打乱后的序列<br>sample(pop,k)：从pop类型中随机选取k个元素，以列表类型返回<br>与其他编程语言相似，Python语言中随机数的生成基于随机数“种子”，每个种子作为输入，利用算法生成一系列随机数，构成伪随机序列。random 库使用random.seed(a)对后续产生成的随机数设置种子。<br>所有的随机数都是基于random()函数实现的基种具体功能。(再次设置相同的种子，则后续产生的随机数相同)<br>9.5time 库概述<br>处理时间是程序最常用的功能之一，time库是 Python提供的处理时间标准库。Time库提供系统级精确计时器的计时功能，可以用来分析程序性能，也可让程序暂停运行时间。<br>使用time库之前需要使用import进行导入<br>time库的功能主要分为3个方面:时间处理、时间格式化和计时。<br>时间处理主要包括4个函数: time.time()、time.gmtime()、time.localtime()、 time.ctime()。<br>时间格式化主要包括3个函数:time.mktime()、time.strftime()、time.strptime()。<br>计时主要包括3个函数:time.sleep()、time.monotonic()、time.perf_counter()o使用time.time()获取当前时间戳<br>使用time.time()获取当前时间戳<br>使用time.gmtime(sec)获取当前时间戳对应的struct_time对象。<br>使用time.localtime(secs)获取当前时间戳对应的本地时间的 struct_time对象。与<br>time.gmtime()的区别，是UTC时间已自动转的为北京时间。<br>time.ctime(secs)获取当前时间戳对应的易读字符串表示，内部会调用time.localtime()函数以输出当地时间。<br>time库使用time.mktime()、time.strftime()、time.strptime()进行时间格式化。使用time.mktime(t)将 struct_time对象t转换为时间戳，注意t代表当地时间。<br>struct_time对象的元素构成<br>下标  属性  值<br>0 tm_year 年份、整数<br>1 tm_mon 月份[1,12]<br>tm_mday 日期[1,31]<br>tm_hour 小时[0,23]<br>tm_min 分钟[0,59]<br>tm_sec 秒[0,61]<br>tm_wday 星期[o,6]（o表示星期一）<br>tm_yday 该年第几天[1,366]<br>tm_isdst 是否夏令时，o否，1是，-1未知<br>调用time.mktime(t)函数</p>
<p>time.strftime()函数是时间格式化最有效的方法，几乎可以以任何通用格式输出时间。该方法利用一个格式字符串，对时间林式进行表示。<br>strftime()方法的格式化控制符<br>%Y 年份 0001<del>9999例如:1900<br>%m 月份 01</del>12例如:10<br>%B 月名 January<del>December例如:April<br>%b 月名缩写 Jan</del>Dec例如Apr<br>%d 日期 01<del>31例如25<br>%A 星期 Monday</del>Sunday 例如 wWednesday<br>%a 星期缩写 Mon<del>sun例如Wed<br>%H 小时（24h制) 00</del>23例如12<br>%I 小时（12h制) 01<del>12例如7<br>%p 上&#x2F;下午 AM,PM例如PM<br>%M 分钟 00</del>59例如26<br>%S 秒 o0~59例如26</p>
<p>strptime()方法与strftime()方法完全相反，用于提取字符串中的时间来生成struct_time对象，可以很灵活地作为time模块输入接口。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-26T23:22:06.596Z" itemprop="datePublished">2022-07-27</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Python/' title=''>Python</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202203Python/Python10第十章  第三方库概览" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/python10/">第十章  第三方库概览</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>10.1Python第三方库的获取和安装<br>Python第三方库依照安装方式灵活性和难易程序有3个方法，这三个方法是: pip工具安装、自定义安装、文件安装。<br>10.1.1pip工具安装<br>最常用且最高效的Python第三方库安装方式是采用pip工具安装。pip是Python官方提供并维护的在线第三方库安装工具。对于Python3.x版本环境，可以采用 pip3命令代替pip命令专为Python3.x版本安装第三方库。<br>使用pip安装第三方库需要联网。<br>安装语法:<br>pip install库名<br>10.1.2自定义安装<br>自定义安装指按照第三方库提供的步骤和方式安装。第三方库都有主页用于维护库的代码和文档。科学计算用的 numpy 的官方主页是:<a target="_blank" rel="noopener" href="http://numpy.org.浏览网页找到下载链接.http//scipy.org/scipylib/download.html%E3%80%82%E8%BF%9B%E8%80%8C%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA%E6%AD%A5%E9%AA%A4%E5%AE%89%E8%A3%85%E3%80%82">http://numpy.org。浏览网页找到下载链接。http://scipy.org/scipylib/download.html。进而根据提示步骤安装。</a><br>自定义安装一般适用于在pip中尚无登记或安装失败的第三方库。<br>10.1.3文件安装<br>由于Python某些第三方库仅提供源代码，通过pip下载文件后无法在 Windows系统编译安装，会导致第三方库安装失败。在 Windows平台下所遇到无法安装第三方库的问题大多属于这类<br>10.1.4pip工具使用<br>除了进行第三方库安装之外，pip工具能对第三方库进行基本的维护。执行pip-h 将列出pip 常用的子命令。<br>pip支持安装(install&gt;、下载( download)、卸载( uninstall&gt;、列表(list)、查看(show)、查找(search）等一系列安装和维护子命令。<br>pip 的uninstall子命令可以卸载一个已经安装的第三方库。<br>10.2PyInstaller库概述<br>PyIlnstaller是一个十分有用的 Python第三方库，它能够在 Windows、Linux、MacOS等操作系统下将Python源文件打包、变成直接可运行的可执行文件。<br>通过对源文件打包，Python程序可以在没有安装Python 的环境中运行，也可以作为一个独立文件方便传递和管理。PyInstaller需要在命令行下用pip工具安装。<br>pip install Pylnstaller<br>pip指令可以将PyInstaller 库自动安装到Python 解释器目录，与pip或pip3命令路径相同，可以直接在命令行调用。<br>Pylnstaller针对不同操作系统打包生成的可执行文件都不同。<br>10.3PyInstaller库与程序打包<br>使用PyInstaller库对Python源文件打包十分简单。语法结构:<br>Pyinstaller源文件名<br>执行完毕后，源文件所在目录将生成dist和 build两个文件夹。其中，build目录是PyInstaller存储临时文件的目录，可以安全删除。最终的打包程序在dist内部与源文件同中的目录中。目录中其他文件是可执行文件的动态链接库。<br>可以通过-F参数对Python源文件生成一个独立的可执行文件。<br>pyinstaller -F a.py<br>执行后在dist目录中出了a.exe文件，没有任何依赖库，执行它即可运行程序。使用Pylnstaller库需要注意以下问题:<br>文件路径不能出现空格和英文句号(.)源文件必须是UTF_8编码，暂时不支持其他编码类型。<br>pyinstaller命令的常用参数<br>-h、–help：查看帮助<br>–clean：清理打包过程中的临时文件<br>-D，–onedir：默认值，生成dist目录<br>-F，–onefile：在 dist文件夹中只能生成独立的打包文件<br>-i&lt;图标文件名.ico&gt;：指定打包程序使用的图标icon文件<br>pyinstaller命令不需要在Python源文件中增加代码，只需要通过命令进行打包即可。</p>
<p>10.4jieba库概述<br>由于中文文本的单词不是通过空格或者标点符号分割,中文及类似语言存在一个重要的“分词”问题。<br>jieba是Python 中一个重要的第三方中文分词函数库，能够将一段中文文本分割成中文词语的序列。jieba 库需要通过pip指令安装。<br>pip installer jieba<br>jieba 库的分词原理是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词，jieba还提供增加自定义中文单词的功能。<br>jieba库支持三种分词模式:精确模式，将句子最精确地切开，适合文本分析;全模式，把句子中所有可以成词的词语都扫描出来,速度非常快,但是不能解决歧义;搜索引擎模式，在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。<br>对中文分词来说，jieba只需要一行代码。(英文文本不存在分词问题)<br>10.5jieba库与中文分词<br>jieba 库主要提供中文分词功能，可以辅助自定义分词词典。<br>jieba库常用的分词函数<br>jieba.lcut(s)：精确模式，返回一个列表类型<br>jieba.lcut(s,cut_all&#x3D;True)：全模式，返回一个列表类型<br>jieba.lcut_for_search(s)：搜索引擎模式，返回一个列表类型<br>jieba.add_word(w)：向分词字典中增加新词w<br>jieba.lcut(s)是最常用的中文分词函数，用于精确模式，即将字符串分割成等量的中文词组，返回结果是列表类型。<br>jieba.lcut(s,cut_all&#x3D;True)用于全模式，即将字符串的所有分词可能均列出来，返回结果是列表类型，冗余性最大。<br>相比精确模式，全模式会找到所有分词可能，比如“计算机”被分词为3个可能词语“计算”、“计算机”、“算机”。<br>Jieba.lcut_for_search(s)返回搜索引掌候式，首先执行精确模式，在对其中长词进一步切分获得最终结果。<br>相比精确模式，其中长词“计算机”被再次分词成“计算”、“算机”、“计算机”三个词语，存在一定冗余。<br>提示:精确模式因为不产生冗余，最为常用。<br>搜索引擎模式更倾向于寻找短诃语，这种方式具有一定冗余度，但相比全模式较少。<br>3种分词模式如何选择?看需求<br>如果希望对文本准确分词，不产生冗余，只能选择jieba.Icut(s)函数<br>希望对文本分词更准确，不漏掉仕何可能的分词结果，选用全模式。没想好怎么用，可以使用搜索引擎模式。<br>jieba.add word()函数，用来向jieba词库增加新的单词。<br>10.6wordcloud 库概述<br>数据展示的方式多种多样，传统的统计图尽管很“科学”，但略显古板。尤其对于文本来说，更加直观、带有一定艺术感的展示效果需要很大，对于这类需求，词云特有的展示方式深得人心。<br>词云以词语为基本单元,根据其在文本中出现的频率设计不同大小以形成视觉上的不同效果，形成“关键云层”或“关键词渲染”，从而使用读者只要“一瞥”即可领略文本的主旨。这种展示方式已经成为文本展示的样板。<br>Wordcloud库是专门用于根据文本生成词云的Python第三方库，十分常用且有趣。提示:词去<br>能够将文本转变成词云，也是一种必备能力。<br>有关wordcloud库的详细介绍可访问<a target="_blank" rel="noopener" href="https://amueller.github.io/word">https://amueller.github.io/word</a> cloud&#x2F;安装wordcloud库在 Windows的cmd命令行使用如下:<br>10.7wordcloud库与可视化词云<br>在生成词云时，wordcloud默认会以空格或标点分隔符对目标文本进行分词处理。对于<br>中文文本，分词处理需要由用户来完成。一般步骤是先将文本分词处理，然后以空格拼接，再调用wordcloud库函数,处理中文时还需要指定中文字体。例如,选择了微软雅黑( msyh.ttc）<br>作为显示效果,需要将该字体文件与代码存放在同一目录下或在字体文件名前加上完整路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">txt=&#x27;程序设计语言是计算机能够理解和识别用户操作意图的一种交互体系，它按照特定规则组织、计算机指令，使用计算机能够自动进行各种运算处理&#x27;</span><br><span class="line">words=jieba.lcut(txt)</span><br><span class="line">newtxt=&#x27; &#x27;.join(words)</span><br><span class="line">wordcloud=WordCloud(font_path=&#x27;msyh.ttc&#x27;).generate(newtxt)wordcloud.to_file(&#x27;词云中文案例.png&#x27;)</span><br></pre></td></tr></table></figure>
<p>Wordcloud库的核心是 WordCloud类，所有的功能都封装在 WordCloud类中。使用时需要实例化一个 WordCloud类的对象，并调用其 generate(text)方法将text文本转化为词云。WordCloud在创建时有一系列可选参数，用于配置词云图片。<br>font_path<br>指定字体文件的完整路径，默认None<br>width<br>生成图片宽度，默认400像素<br>height<br>生成图片高度，默认200像素<br>mask<br>词云形状，默认None，即方形图<br>min_font_size<br>词云中最小的字体字号，默认4号<br>font_step<br>字号步进间隔，默认1<br>max_font_size<br>词云中最大的字体字号，默认None，根据高度自动调节<br>max_words<br>词云图中最大词数，默认200<br>stopwords<br>被排除词列表，排除词不在词云中显示<br>background_color<br>图片背景色，默认黑色<br>WordCloud类的常用方法<br>generate(text)<br>由text文本生成词云<br>to_file(filename)<br>将词云图保存为名为filename的文件<br>wordcloud可以生成任何形状的词云，为了获取形状，需要提供一张形状的图像。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-26T12:19:47.443Z" itemprop="datePublished">2022-07-26</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Python/' title=''>Python</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202203Python/Python第六章  第三方生态" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/python06/">第六章  第三方生态</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>numpy是Python的一种开源数值计算扩展第三方库，用于处理数据类型相同的多维数组，简称”数组”。这个库可用来存储和处理大型矩阵，比Python语言提供的列表结构要高效得多。numpy提供了许多高级的数值编程工具，如矩阵计算、矢量处理、N维数据变换等。<br>PIL库是Python语言在图像处理方面的重要第三方库，支持图像存储、处理和显示，它能够处理几乎所有的图片格式，可以完成对图形的缩放、剪裁、叠加以及向图像添加线条、图形和文字等。<br>PIL库可以完成图像归档和图形处理两方面功能需求。<br>Python语言中Web开发框架第三方库有：Flask、Django、Pyramid，而mayavi是python语言中数据可视化方向的第三方库。<br>Python网络爬虫领域的第三方库：scrapy和request。<br>numpy是Python语言中数据分析方向的第三方库，openpyxl是python语言中文本处理方向的第三方库，PyQt5是Python语言中用户图形界面方向的第三方库。<br>Python语言中数据分析方向的第三方库：numpy、scipy、pandas，而PIL第三方库可以完成图像归档和图形处理两方面功能需求。pandas用于数据分析<br>属于机器学习领域：PyTorch，MXNet，Tensorflow<br>Aracde是图形库<br>scrapy是Python语言中网络爬虫方向的第三方库，而numpy、scipy和pandas是Python语言中数据分析方向的第三方库，matplotlib是数据可视化方向的第三方库，也属于数据分析领域<br>Python语言中第三方库有三种安装方式：pip工具安装、自定义安装、文件安装，而pygame、PyQt5、pyinstaller是python语言中的第三方库。<br>Python语言中机器学习方向的第三方库有Tensorflow、Theano、scikit-learn，而numpy、pandas是数据分析方向的第三方库，pygame是游戏开发方向的第三方库。<br>Python语言中开发用户界面方向的第三方库：PyQt5、wxPython、PyGTK，而turtle库是python的标准库之一。<br>Python语言中数据分析方向的第三方库：numpy、scipy、pandas。Seaborn<br>Python语言中数据可视化析方向的第三方库：matplotliB、TVTK、mayavi。<br>mxnet是Python语言中深度学习方向的第三方库。<br>Python语言中Web开发框架第三方库有Flask、Django、Pyramid，而scrapy是python网络爬虫方向的第三方库。<br>Beautifulsoup4库，也称为Beautiful Soup库或bs4库，用于解析和处理HTML和XML。<br>random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。<br>于计算机视觉领域：OpenCV是一个强大的图像和视频工作库。它提供了多种程序接口，支持跨平台（包括移动端）应用。除了对图像进行基本处理外，还支持图像数据建模，并预制了多种图像识别引擎，如人脸识别<br>PyQt5库是Python语言当前最好的GUI（用户图形界面）第三方库，它可以在Windows、Linux和MacOS X等操作系统上跨平台使用。<br>人工智能领域：mxnet，keras，pytorch<br>Django：Web开发方向<br>NLTK：自然语言处理工具包<br>Luminoth：计算机视觉工具包<br>redis-py：数据存储<br>网络爬虫领域：Scrapy、Requests、PySpider。<br>SnowNLP用于处理中文文本内容。<br>Web开发方向：Tornado、Pyramid、Django。<br>Python语言中Web开发框架第三方库有Flask、Django、Pyramid。<br>pandas是数据分析的一个核心框架，集成了数据结构化和数据清洗以及分析的一些方法。pandas在numpy的基础上新增了三个数据类型，Series、DataFrame、Panel。可以进行高效的时间序列分析以及金融数据分析。</p>
<p>Pyinstaller命令的常用参数：<br>-h，–help：查看帮助<br>–clean：清理打包过程中的临时文件<br>-D，–onedir：默认值，生成dist目录<br>-F，–onefile：在dist文件夹中只生成独立的打包文件<br>-i&lt;图标文件名.ico&gt;：指定打包程序使用的图标（icon）文件</p>
<p>第11章Python第三方库纵览<br>11.1网络爬虫方向<br>网络爬虫是自动进行HTTP 访问并捕获HTML页面的程序。Python语言提供了多个具备网络爬虫功能的第三方库。<br>11.1.1requests<br>requests库是一个简洁且简单的处理HTTP请求的第三方库，其最大优点是程序编写过程更接近正常URL访问过程。这个库建立在Python语言的urllib3库基础上，类似这种在其他函数库之上再封装功能提供更友好函数的方式在Python语言中十分常见。在Python生态圈里，任何人都有通过技术创新或体验创建新发表意见和展示才华的机会。<br>Requests库支持非常丰富的链接访问功能，包括国际域名和URL获取、HTTP长连接和连接缓存、HTTP会话和 cookie 保持、浏览器使用风格的SSL 验证、基本的摘要认证、有效的键值对cookie记录、自动解压缩、自动内容解码、文件分块上传、HTTP(S）代理功能、连接超时处理、流数据下载等。<br>有关requests库的更多可访问<a target="_blank" rel="noopener" href="http://www.python-requests.org安装语法为/">http://www.python-requests.org安装语法为</a>:</p>
<p>python35 -m pip install requests -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>requests库提供了7个函数，用来表示对一个网页的HTTP请求，requests库的常用函数：<br>requests.request()：构造一个请求，支撑以下各方法的基础方法<br>requests.get()：获取HTML 网页的主要方法，对应于HTTP的GET<br>requests.head()：获取HTML 网页头的主要方法，对应于HTTP的HEAD<br>requests.post()：向HTML 网页提交POST请求的方法，对应于HTTP的POST<br>requests.put()：向HTML网页提交PUT请求的方法，对应于HTTP的PUT<br>requests.patch()：向HTML 网页提交局部修改请求，对应于HTTP的PATCH<br>requests.delete()：向HTML页面提交删除请求，对应于HTTP的DELETE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">resp=requests.get(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>
<p>11.1.2scrapy<br>Scrapy是Python开发的一个快速的、高层次的 Web获取框架。不同于简单的网络爬虫功能，scrapy框架本身包含了成熟网络爬虫系统所应该具有的部分共用功能，它是一个半成品,任何人都可以根据需求方便地利用框架已有功能经过简单扩展实现专业的网络爬虫系统。<br>Scrapy用途广泛，可以应用于专业爬虫系统的构建、数据挖掘、网络监控和自动化测试等领域。Scrapy提供URL队列、异步多线程访问、定时访问、数据库集成等众多功能，基于它构建的爬虫系统可以7*24运行，具备产品级运行能力。<br>有关scrapy库的更多介绍可以访问<a target="_blank" rel="noopener" href="https://scrapy.org/">https://scrapy.org/</a><br>python35-m pip install scrapy-i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple--trusted-host">http://pypi.douban.com/simple--trusted-host</a> pypi.douban.com<br>Scrapy框架结构，通过扩展函数完善功能后，可以利用这套框架实现对 Web页面不间断的获取。由于scrapy框架质量很高，可以用于产品设计和开发。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43597208/article/details/105712021">scrapy架构原理图</a></p>
<p>11.2 数据分析方向<br>数据分析是PYthon的一个优势方向，具有大批高质量的第三方库<br>11.2.1numpy<br>Numpy是 Python的一种开源数值计算扩展第三方库，用于处理数据类型相同的多维数组(ndarray)简称“数组”。这个库可用来存储和处理大型矩阵，比 Python语言提供的列表结构要高效很多。Numpy提供了许多高级的数值编程工具，如矩阵运算、矢量运算、N维数据变换等。<br>Numpy内部是c语言编写，对外采用Python语言进行封装。因此,在进行数据运算时，基于numpy的 Python程序可以达到接近c语言的处理速度。Numpy也成为Python数据分析方向各其他库的基础依赖库，已经成了科学计算事实上的“标准库”。<br>有关numpy库的更多介绍可访问: <a target="_blank" rel="noopener" href="http://www.numpy.org/">http://www.numpy.org/</a><br>安装语法：<br>python35-m pip install numpy -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple--trusted-host">http://pypi.douban.com/simple--trusted-host</a> pypi.douban.com<br>11.2.2scipy<br>Scipy是一款方便、易用、专为科学和工程设计的 Python 工具包，它在是numpy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。它包括统计、优化、整合、线性代数、傅立叶变换、信号分析、图像处理、常微分方程求解等众多模块。顾名思义，scipy主要用于科学和工程计算。<br>有关scipy库的更多介绍可访问:htts:&#x2F;&#x2F;scipy.org<br>安装语法:<br>python35-m pip install scipy -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.2.3pandas<br>pandas是基于numpy扩展的一个重要第三方库,它是为了解决数据分析任务而创建的。pandas提供了一批标准的数据模型和大量快速便捷处理数据的函数和方法，提供了高效地操作大型数据集所需要的工具。<br>Pandas最初被作为金融数据分析工具而开发，因此，pandas为时间序列分析提供了很好的支持。Pandas的名称来自面板数据(panel data）和 Python数据分析(data analysis)。Panel data是经济学中关于多维数据集的一个术语。Pandas 提供两种最基本的数据类型:Series和 DataFrame ,分别代表一维数组和二维数组类型。<br>有关scipy库的更多介绍可访问:<a target="_blank" rel="noopener" href="http://pandas.pydata.org/">http://pandas.pydata.org</a><br>安装语法:<br>python35-m pip install pandas -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple--trusted-host">http://pypi.douban.com/simple--trusted-host</a> pypi.douban.com</p>
<p>11.3文本处理方向<br>Python语言非常适合处理文本，因此，在这个方向也形成了大量有价值的第三方库。常用的有pdfminer、penpyxl、python-docx、beautifulsoup4。<br>11.3.1pdfminer<br>pdfminer是一个可以从PDF 文档中提取各类信息的第三方库。与其他PDF相关的工具不同，它能够完全获取并分析PDF的文本数据。pdfminer能够获取 PDF中文本的准确位置、字体、行数等信息，能够将PDF 文个把转为HTML及文本格式。pdfminer包含两个重要的工具: pdf2txt.py和dumppdf.py。<br>pdf2txt.py能够从PDF 文件中提取所有文本内容。dumppd.py能够把PDF文件内容变成XML格式，并进一步提取其中的图片。<br>在关pdfminer 库的更多介绍可访问<a target="_blank" rel="noopener" href="https://euske.github.io/pdfminer/">https://euske.github.io/pdfminer/</a><br>安装语法:<br>python35-m pip install pdfminer -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.3.2openpyxl<br>Openpyxl是一个处理Microsoft Excel文档的Python第三方库，它支持读写Excel的xls、xlsx、xlsm、xltx、xltm等格式文件，并进一步能处理Excel文件中的工作表、表单和数据单元。<br>有关openpyxl库的更多介绍可访问<a target="_blank" rel="noopener" href="http://openpyxl.readthedocs.io/">http://openpyxl.readthedocs.io/</a><br>安装语法:python35 -m pipinstall openpyxl -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.3.3python-docx<br>Python-docx是一个处理Microsoft Word文档的 Python第三方库，它支持读取、查询以及修改doc、docx等格式文件，并能够对Word常见样式进行编程设置，包括字符样式、段落样式、表格样式、页面样式等，进一步可以使用这个库实现添加和修改文本、图像.样式和文档等功能。<br>有关python-docx库的更多介绍可访问<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/python-docx%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35">https://pypi.python.org/pypi/python-docx安装语法:python35</a> -m pip install python-docx -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.3.4beautifulsoup4<br>beautifulsoup4库，也称为Beautiful Soup库或bs4库，用于解析和处理HTML和XML。<br>需要注意,它不是BeautifulSoup库。它的最大优点是能根据HTML和 XML语法建立解析树，进而高效解析其中的内容。<br>HTML建立的Web页面一般非常复杂，除了有用的内容信息处，还包括大量用于页面格<br>11.4数据可视化方向<br>数据可视化是指根据数据特点将其展示为易于理解的图形的过程。Python语言在数据可视化方面具有较强的优势。常用的有matplotlib、TVTK、mayavi。<br>11.4.1matplotlib<br>Matplotlib是提供数据绘图功能的第三方库，主要进行二维图表数据展示，广泛用于科学计算的数据可视化。使用这个库可以利用Pyhton程序绘制超过100种数据可视化效果。<br>有关matplotlib库的更多介绍可访问<a target="_blank" rel="noopener" href="http://matplotlib.org/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35">http://matplotlib.org/安装语法:python35</a> -m pip install matplotlib -i http:&#x2F;&#x2F;<br>pypi.douban.com&#x2F;simple –trusted-hostpypi.douban.com<br>11.4.2TVTK<br>TVTK库是在标准的VTK库之上用Traits库进行封装的Python第三方库。视觉工具函数库(Visualization Toolkit，VTK）是一个开源、跨平台、支持平行处理的图形应用函数库，它是专业可编程的三维可视化工具。TVTK在Python生态系统中被等同于VTK。<br>windows平台不能使用pip命令安装，可以通过文件安装，其他平台可以<br>11.4.3mayavi<br>虽然VTK 3D可视化软件包功能强大，Python的TVK封装使用方便简洁，但是要用这些工具快速编写实用的三维可视化程序仍然需要花费不少精力。Mayavi基于TVK开发，完全用Python 编写，提供了一个更为方便实用的可视化软件，可以简洁地嵌入到用户编写的Python程序中，或者直接使用其面向脚本的API快速绘制三维可视化图形。值得注意的是mayavi也被称为,mayavi2。<br>有关mayavi’*库的更多介绍可访问<a target="_blank" rel="noopener" href="http://docs.enthought.com/mayavi/mayavi/">http://docs.enthought.com/mayavi/mayavi/</a><br>mayavi库在 Windows平台上暂时不能使用pip命令安装，建议使用文件安装，在其它平台可使用pip命令安装。<br>11.5用户图形界面方向<br>Python标准库内置了一个GUl库—Tkinter，这个库基于Tcl&#x2F;Tk开发，然而这个库十分陈旧，提供的开发控制也很有限、编写出来的GUI风格与现代程序GUI风格相差甚远，从用户体验角度说，Tkinter库并不成熟。<br>常用的3个高质量的用户图形界面Python生态库:PyQt5、wxPython、PyGTK<br>11.5.1PyQt5<br>PyQt5是Q5应用框架的Python第三方库,它有超过620个类和近6000个函数和方法。它是Python中最为成熟的商业级GUI第三方库。这个库是Python语言当前最好的GUI第三方库，它可以 Window、Linux和 MacOSx等操作系统上跨平台使用。<br>PyQt5采用“信号-槽”机制将事件和对应的处理程序进行绑定。简单说，信号就是事件、槽是事件的处理程序。例如，鼠标点击操作是信号，处理鼠标点击的程序是槽。一个信号可以连接多个槽，也可以不连接槽。信号可以连接其他信息。PyQt5窗体有很内置信息，也可以自定义信号。<br>有关PyQt5库的更多介绍可访问 <a target="_blank" rel="noopener" href="https://www.riverbank.computing.com/software/pyqt/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35-m">https://www.riverbank.computing.com/software/pyqt/安装语法:python35-m</a> pip install pyqt5 -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.5.2wxPython<br>wxPython是 Python语言的一套优秀的GUI图形库，它是跨平台GUI库 wxWidgets的Python封装，可以使用Python程序员能够轻松地创建健壮可靠、功能强大的图形用户界面的程序。其中, wxWidgets使用C++语言编写,C&#x2F;C++语言编写的功能库进行二次封装是Python语言的重要特点之一。<br>有关wxPython库的更多介绍可访问<a target="_blank" rel="noopener" href="https://wxpython.org/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35">https://wxpython.org/安装语法:python35</a> -m pip install wxPython -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.5.3PyGTK<br>PyGTK是基于GTK+的Python语言封装，它提供了各式的可视元素和功能，能够轻构创建具有图形用户界面的程序。PyGTK具有跨平台性，利用它编写的代码能够不加修改地稳定运行在各操作系统中，如Windows、MacOS、Linux 等。<br>有关PyGTK库的更多介绍可访问<a href="http://www.pygtk.org安装语法:python35-m">http://www.pygtk.org安装语法:python35-m</a> pip install pygtk-i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.6机器学习方向<br>机器学习是人工智能领域的一个重要分支，Python 语言也是机器学习和人工智能的重要基础语言。常用的三个高质量的机器学习框架: scikit-learn、TensofFlow、Theano。<br>11.6.1scikit-learn<br>scikit-learn是一个简单且高效的数据挖掘和数据分析工具，它基于NumPy、SciP和matplotplib构建。 scikit-learn项目最早由数据科学家David Cournapeau在2007年组织开发，它是Python语言中专门针对机器学习应用而发展起来的一款开源框架。scikit-learn的基本功能主要包括6个部分:分类、回归、聚类、数据降维、模型选择和数据预处理。scikit-learn也被称为sklearn。<br>有关scikit-learn库更多的介绍可访问<a target="_blank" rel="noopener" href="http://scikit-learn.org/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35">http://scikit-learn.org/安装语法:python35</a> -m pipinstall scikit-learn -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.6.2TensorFlow<br>TensorFlow是谷歌公司基于DistBelief进行研发的第二代人工智能学习系统，也是用来支撑著名AlphaGo系统后台框架，其命名来源于其自身的运行原理。Tensor(张量)指N维数组，Flow（流）指基于数据流图的计算，TensorFlow描述张量从流图的一端流动到另一端的计算过程。<br>TensorFlow的应用十分广泛，从语音识别或图像识别到机器翻译或自主跟踪等，既可以运行在数万台服务器的数据中心，也可以运行在智能手机或嵌入式设备中。<br>有关TensorFlow库的的更多介绍可访问<a target="_blank" rel="noopener" href="http://www.tensorflow.org/">http://www.tensorflow.org/</a><br>11.6.3Theano<br>Theano为执行深度学习中大规模神经网络算法的运算而设计，擅长处理多维数组<br>Theano开发始于2007年，可以理解它是一个运算数学表达式的编译器，并可以高效运行在GPU或CPU上。Theano是一个偏向底层开发的库,更像一个研究平台而单纯的深度学习库。<br>有关Theano 库的更多介绍可访问<a target="_blank" rel="noopener" href="http://deeplearning.net/software/theano/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35-m">http://deeplearning.net/software/theano/安装语法:python35-m</a> pip install theano-i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.7Web开发方向<br>Web开发是Python语言流行的一个重要方向，主要用于服务器后端开发。根据 PythonWeb开发框架的复杂程序。常用的 Python第三方生态度有:Django、Pyramid、Flask。<br>11.7.1Django<br>Django是Python生态中最流行的开源Web应用框架。Django采用模型(Model&gt;、模板（Template）和视图(Views）的编写模式，称为MTⅣ模式。其中，模型即数据存取层，用于处理与数据相关的所有事务，包括如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等;模板即表现层，用于处理与表现相关的功能，通过模板方式定义页面风格;视图即业务逻辑层，用于存取模型及调取恰当模板的相关逻辑，是模型与模板的桥梁。<br>Django中提供了开发网站经常用到的模块，Django 的开发理念是DRY (Don’t Repeat Yourself)，用于鼓励快速开发、进而减少程序员建立一个高性能 Web 应用所花费的时间和精力，形成一种一站式解决方案。<br>有关Django库的更多介绍可访问<a target="_blank" rel="noopener" href="https://www.djangoproject.com/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35-m">https://www.djangoproject.com/安装语法:python35-m</a> pip install django-i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.7.2Pyramid<br>Pyramid是一个通、开源的Python Web应用程序开发框架。它主要的目的是让Python开发者更简单地创建Web应用。相比 Django，Pyramid是一个相对小巧、快速、灵活的开源PythonWeb框架。<br>与Django一样，Pyramid仍然面向较大规模的Web应用，但它更关注灵活性，开发者可以灵活选择所使用的数据库、模板风格、URL结构等内容。<br>有关Pyramid 库的更多介绍可访问<a target="_blank" rel="noopener" href="https://trypyramid.com/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35">https://trypyramid.com/安装语法:python35</a> -m pip install pyramid -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.7.3Flask<br>Flask是轻量级 Web应用框架，相比Django和 Pyramid，它也被称为微框架。使用Flask开发 Web应用十分方便，甚至几行代码即可建立一个小型网站。Flask核心十分简单，并不直接包含诸如数据库访问等的抽象访问层，而是通过扩展模块形式来支持。<br>有关Flask 库的更多介绍可访问<a target="_blank" rel="noopener" href="http://flask.pocoo.org/%E5%AE%89%E8%A3%85%E8%AF%AD%E6%B3%95:python35-m">http://flask.pocoo.org/安装语法:python35-m</a> pip install flask -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com<br>11.8游戏开发方向<br>游戏开发是一个有趣的方向，在游戏逻辑和功能实现层面，Python已经成为重要的支撑性语言。有Python中有三个常用的生态库:Pygame、Panda3D、cocos2d。<br>11.8.1Pygame<br>Pygame是在SDL库基础上进行封装的、面向游戏开发入门的Python第三方库，除了制作游戏外，还用于制作多媒体应用程序。其，中 sDL (Simple DirectMedia Layer）是开源、跨平台的多媒体开发库，通过 OpenGL和 Direct3D底层函数提供对音频、键盘、鼠标和图形硬件的简洁访问。<br>Pygame是一个游戏开发框架，提供了大量与游戏相关的底层逻辑和功能支持，非常适合作为入门库理解并实践游戏开发。<br>有关Pygame 库的更多介绍可访问<a href="http://www.pygame.org安装语法:python35">http://www.pygame.org安装语法:python35</a> -m pip install pygame -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> —trusted-hostpypi.douban.com<br>11.8.2Panda3D<br>Panda3D是一个开源、跨平台的3D渲染和游戏开发库，简单说，它是一个 3D游戏引擎，由迪士尼和卡耐基.梅隆大学娱乐技术中心共同开发。Panda3D支持 Python和C++两种语言，但对Python支持更全面。<br>Panda3D支持很多当代先进游戏引擎所支持的特性，如法线贴图、光泽贴图、HDR、卡通渲染和线框渲染等。<br>有关Panda3D库的更多介绍可访问<a href="http://www.panda3d.org安装语法:python35">http://www.panda3d.org安装语法:python35</a> -m pipinstall panda3d -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>python35 -m pipinstall panda3d -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.8.3cocos2d<br>Cocos2d是一个构建2D游戏和图形界面交互式应用的框架,它包括C++、JavaScript .Swift、Python等多个版本。Cocos2d基于OpenGL进行图形渲染，能够利用GPU进行加速。Cocos2d引擎采用树形结构来管理游戏对象，一个游戏划分为不同场景，一个场景又分为不同层，每个层处理并响应用户事件。<br>11.9更多第三方库<br>Python语言有十几万个第三方库，覆盖信息技术几乎所有领域。即使在每个方向，也会有大量的专业人员开发多个第三方库来给出具体设计。除了本章所提到的方向外，还有以下几个第三方库也是比较常用的。</p>
<p>11.9.1PIL<br>PIL库是Python语言在图像处理方面的重要第三方库，支持图像存储、处理和显示，它能够处理几乎所有的图片格式，可以完成对图像的缩放、剪截、叠加以及向图像添加线条、图像和文字等操作。使用Python语言处理图像相关的程序，首选PIL库。<br>PIL库主要可以完成图像归档和图像处理两方面功能需求。<br>图像归档:对图像进行批处理、生成图像预览、图像格式转换等。图像处理:图像基本处理、像素处理、颜色处理等。<br>有关PIL库的更多介绍可访问<a href="http://pillow.readthedocs.io安装语法:python35">http://pillow.readthedocs.io安装语法:python35</a> -m pip install pillow -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-hostpypi.douban.com<br>11.9.2SymPy<br>SymPy是一个支持符号计算的Python第三方库，它是一个全功能的计算机代数系统。SymPy代码简洁、易于理解、支持符号计算、高精度计算、模式匹配、绘图、解方程、微积分、组合数学、离散数学、几何学、概论与统计、物理学领域的计算和应用。</p>
<p>有关SymPy库的更多介绍可访问:<a target="_blank" rel="noopener" href="http://www.sympy.org/">http://www.sympy.org/</a><br>安装语法:python35-m pip install sympy -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple--trusted-host">http://pypi.douban.com/simple--trusted-host</a> pypi.douban..com<br>11.9.3NLTK<br>NLTK是一个非常重要的自然语言处理Python第三方库，它支持多种语言，尤其对中文支持良好。NLTK可以进行语料处理、文本统计、内容理解、情感分析等我种应用，具备非常可靠的应用价值。<br>有关NLTK的更多介绍可访问<a target="_blank" rel="noopener" href="http://www.nltk.org/">http://www.nltk.org/</a><br>11.9.4WeRoBot<br>WeRoBot是一个微信公众号开发框架，也称为微信机器人框架。WeRoBot可以解析微信服务器发来的消息，并将消息转换成Message或者Event类型。其中，表示用户发来的消息，如文本消息、图片消息:Event则表示用户触发的事件，如关注事件、扫描二维确事件。在消息解析、转换完成后。WeRoBot 会将消息转交给Handler进行处理，并将Handler 的返回值给微信服务器，进而实现完整的微信机器人功能。<br>有关 WeRoBot库的更多介绍可访问<a target="_blank" rel="noopener" href="http://werobot.readthedocs.io安装语法/">http://werobot.readthedocs.io安装语法</a>:<br>python35 -m pipinstall werobot -i http;&#x2F;&#x2F;pypi.douban.com&#x2F;simple –trusted-hostpypi.douban.com<br>11.9.5MyQR<br>MyQR是一个能够产生基本二维码、艺术二维码和动态效果二维码的Python第三方库。有关MyQR库的更多介绍可访问<a target="_blank" rel="noopener" href="https://github.com/sylnsfar/qrcode">https://github.com/sylnsfar/qrcode</a><br>安装命令:<br>python35-m pip install myqr-i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple--trusted-host">http://pypi.douban.com/simple--trusted-host</a> pypi.douban.com</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-25T11:35:57.397Z" itemprop="datePublished">2022-07-25</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/Python/' title=''>Python</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/SqlServer考试大题第三题" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver3/">『SQL Server』考三</a>
  

      </h3>
      <div class="repo-list-description">
        
          <h2 id="第一套-性能优化"><a href="#第一套-性能优化" class="headerlink" title="第一套  性能优化"></a>第一套  性能优化</h2><p>设某全国性的运输企业创建了大型OLTP系统，并在该系统之上创建了数据仓库。OLTP系统和数据仓库中有以下数据表：<br>运输明细表(运输单ID，发送站ID，终到站ID，货物ID，货物重量，运输价格，发货日期)<br>汇总表1(发送站ID，终到站ID，货物ID，发货日期，总重，总运价)<br>汇总表2(发送站ID，终到地区ID，货物ID，发货日期，总重，总运价)<br>汇总表3(发送站ID，终到站ID，货物ID，发货月份，总重，总运价)<br>汇总表4(发送地区ID，终到地区ID，货物类别ID，发货日期，总重，总运价)<br>该企业管理的货运站约有100个，货物约有500种共10类，各汇总表都建有主码，且各表有合理的维护策略，在每次维护后数据能保持一致。设有视图V，该视图的访问频率很高，其查询结果模式为(发送地区ID，终到站ID，发货月份，总重，总运价)，该视图现以汇总表1为计算数据源。经监控发现，汇总表1的被访问频率太高，致使系统总体性能降低，而其它汇总表被访问频率较低。在不增长汇总表和索引的状况下，请给出一个改善系统服务性能的优化方案，并简要说明理由。</p>
<p>【解题思路】<br>　　计算机系统中存在着两类不同的数据处理工作：操作型处理和分析型处理，也称作OLTP(联机事务处理)和OLAP(联机分析处理)。操作型处理也叫事务处理，是指对数据库联机的日常操作，通常是对一个或一组纪录的查询或修改，例如火车售票系统、银行通存通兑系统、税务征收管理系统等。这些系统要求快速响应用户请求，对数据的完全性、完整性以及事务吞吐量要求很高。结合本题中存在的问题，视图本身的访问量很高，而又仅仅以汇总表1为计算数据源，而其它汇总表访问率低，导致了资源利用不合理。因此本题考察了联机事务处理中的资源调度问题。<br>【参考答案】<br>　　由于汇总表1和视图的模式访问频率都很高，而且视图的数据源来自汇总表1，又因为其他汇总表的访问率较低，所以只需要将视图的数据源绑定为汇总表3，因为汇总表3也可以满足视图的输出模式。这样不仅提升了汇总表3的数据访问率，而且降低了汇总表1的数据访问率，系统性能和服务性能得到了很大的优化。又因为货物约有500种，共10类， 可以再建立一个视图绑定数据源为汇总表4，这样就可以充分利用汇总表4的数据信息，从而可以进一步优化系统性能。</p>
<h2 id="第二套-性能优化-索引"><a href="#第二套-性能优化-索引" class="headerlink" title="第二套  性能优化 索引"></a>第二套  性能优化 索引</h2><p>在进行某学校教务管理系统的数据库设计时，数据库设计人员设计了如下几个关系模式：<br>系(系号，系名)，系号为主码<br>学生(学号，姓名，所在系号)，学号为主码<br>课程(课程号，课程名，开课系号)，课程号为主码<br>选课(学号，课程号，选课时间)，学号和课程号为主码<br>开发人员在将关系模式实施到SQL Server 2008的“教务”数据库时，使用了如下表结构定义语句：<br>CREATE TABLE系(<br>系号varchar(10)NOT NULL，<br>系名varchar(100)<br>)</p>
<p>CREATE TABLE学生(<br>学号varchar(50)NOT NULL，<br>姓名varchar(50)，<br>所在系号varchar(10)<br>)<br>CREATE TABLE课程(<br>课程号varchar(50)NOT NULL，<br>课程名varchar(100)，<br>开课系号varchar(10)<br>)<br>CREATE TABLE选课(<br>学号varchar(50)NOT NULL，<br>课程号varchar(50)NOT NULL，<br>选课时间datetime<br>)<br>在执行如下查询语句时发现执行效率很低：<br>SELECT *FROM选课JOIN学生0N学生.学号&#x3D;选课.学号<br>JOIN系ON系.系号&#x3D;学生.所在系号<br>JOIN课程0N课程.课程号&#x3D;选课.课程号<br>WHERE系.系号&#x3D;ˊ012 ˊ<br>AND convert(vvarchar(10)，选课时间，120)&gt;&#x3D;ˊ2010-01-01ˊ<br>(1)在查找原因时发现建表语句有问题。请指出问题并说明该问题是否会影响此查询语句的执行效率。(4分)<br>(2)设已在“选课”表的“选课时间”列及“学生”表的“所在系号”列上建立了索引。请问这两个索引是否能够提高该查询语句的执行效率?如果不能，请说明原因。(4分)</p>
<p>4、建表时没有设置主键，也没有说明外键，但不会影响此查询语句的执行效率。<br>[解析]本题中查询语句的功能是得到12系全体学生在2010年1月1日后的选课情况的汇总表。在每个数据表的定义时都必须严格定义表中的完整性约束条件，包括主键的设置，否则之后会出现主键有相同值的情况，破坏了数据的完整性。<br>5、”选课”表的”选课时间”可以建立索引，从而提高查询效率，而”学生w表的”所在系号w建立索引不会提高查询效率。索引的意义就是将记录按目标关键字顺序排列，这样查找某个目标关键字的对应值的位置就缩小了查找范围。”选课时间”的重复率低，所以可以作为索引，而学生”所在系号”的重复率太高，则不会提高查询效率。<br>[解析]”选课”表的”选课时间”列上建立了索引，从而能够提高执行效率。经常出现在where子句中的字段，特别是大表的字段，应该建立索引。索引的作用就类似于书的目录，即会按照章节的顺序排列。因此如果在一本数百页的书里面查找某个章节位置的时候，就可以只扫描书的目录。扫描的范围缩了n倍，查询的效率自然就会提高。另外，在sQL Server内存够用的情况下，索引会被放到内存中，在内存中查找自然又会提高效率，所以必须合理利用索引。</p>
<h2 id="第三套-性能优化"><a href="#第三套-性能优化" class="headerlink" title="第三套  性能优化"></a>第三套  性能优化</h2><p>某商场商品经营管理系统使用SQL Server 2008数据库管理系统，此系统上线运行1年后，业务人员使用某统计功能（此功能每月使用一次)时发现速度很慢。该统计功能主要执行的SQL语句如下:<br>SELECT商品号,SUM(销售数量<em>销售价格)销售额FROM销售明细<br>GROUP BY商品号;<br>该销售明细表的建表语句如下:CREATE TABLE销售明细(<br>序列号intlIDENTITY(1,1) NOT NULL,商品号intNOT NULL,<br>销售日期datetime NULL,销售数量intNOT NULL,销售价格intNOT NULL);<br>并在销售明细表上建有如下索引:<br>CREATE index ix_销售明细_商品号on销售明细(商品号);某技术人品提出涌过执行下述语句以提高此杳询的运行效率:<br>CREATE VIEW商品销售额视图<br>WITH SCHEMABINDINGAS<br>SELECT商品号,SUM(销售数量</em>销售价格)销售额,COUNT_BIG(*) cnt<br>FROM dbo.销售明细GROUP BY商品号;<br>CREATE UNIQUE CLUSTERED INDEX ix_商品销售额ON商品销售额视图(商品号);(10分)<br>(1）请分析该技术人员给出的语句功能以及对原有查询语句的性能影响，并给出原因。<br>(2）此商场的销售量很大，每天有大量数据插入到销售明细表中。请从数据库整体性能角度分析，此技术人员提出的优化方法是否合适，并给出原因。</p>
<p>语句功能:建立包含(商品号，销售额，该商品表中出现次数)带索引的视图，并建立按商品号对应销售额UNIQUE聚簇排序的索引，大大缩小」含询语可的食诩汇围，提高了查询效率。原因:税图中将间按相大周2小了推索空间，同时建商品号，销售数量，销售价格）转换成了目标属性列，减少了搜索空间;同时建立UNIQUE CLUSTERED索引，使查询商品号的数据记录唯一，降低了搜索范围，提高了搜索效率。</p>
<p>不合适，每天大量的插入操作使得在修改表的同时也要对视图进行修改，增加了系统的负担，然而该统计功能一个月才用一次，这样导致系统的利用率也较为低下。</p>
<h2 id="第四套-性能优化"><a href="#第四套-性能优化" class="headerlink" title="第四套  性能优化"></a>第四套  性能优化</h2><p>某教务管理系统使用SQL Server 2008数据库管理系统，数据库软硬件配置信息如下：<br>Ⅰ．数据库运行在两路Intel Xeon E5-2609 2.4GHz CPU(每路CPU4核心)，128GB内存、2块300GB 15000转SAS硬盘(RAID 1)的服务器上；<br>Ⅱ．服务器操作系统为Windows 2003 32位企业版，安装SP2补丁；<br>Ⅲ．数据库为SQL Server 2008 Enterprise(32 位)，数据库中总数据量近130GB。<br>近一个学期以来，用户反映系统运行缓慢，经程序员定位，确定为数据库服务器响应缓慢，需要进行调优。</p>
<p>根据SQL Server 2008数据库的特性以及题目中的条件，综合给出以下的调优方案。<br>(1）表结构优化:重新优化数据库设计结构，规范数据库逻辑设计;设计主键和外键;设计合适大小的字段。<br>(2）硬件优化:购买一块同样大小的硬盘，将硬盘做成RAID5,用以提高数据库读写速度;增加服务器<br>CPU<br>个数;扩大服务器的内存。<br>(3）索引优化:采用对经常作为条件查询的列设计索引，在查W中经吊尺到的入操作的表不要建立过多的繁进行范围查询、排序、分组的列上建立.策族索引，对了有从系选i索引。<br>(4)采用视图:合理使用视图和分区视图，在需要更新和刎陈探作个夕、亘闲抹止十从乐PB长向拉一的再句兹(5)sQL语句优化:选择运算应尽可能先做，开仕X问一个衣应1多件想出数据较小的信息，再在这些信息在前面，较弱的选择条件写在后面，这样就可以无根伯权加充询，把子奋询转换成联结来实现。字段中根据后面较弱的条件得到满足条件的信息。应避免使用相关子查询，把子查询转换成联结来实现。字段<br>提取按照”需多少，提多少”的原则，避免”SELECT *”，”SELECT *”需要数据库返回相应表的所有列信息，这对于一个列较多的表无疑是一项费时的操作，采用存储过程，使用存储过程提高数据处理速度。</p>
<h2 id="第五套-性能优化"><a href="#第五套-性能优化" class="headerlink" title="第五套  性能优化"></a>第五套  性能优化</h2><p>某采购中心采购了一套商品批发查询管理系统，此系统采用SQL Server 2008数据库管理系统，该系统需要经常处理百万级以上的数据查询。同时该系统提供了第三方人员开发的SQL接口，第三方人员可以根据自己的需要开发自己的应用程序来访问数据库中的相关数据。<br>(1)系统在使用的过程中，业务人员反应系统操作速度很慢。经过工程师检查测试后，数据库系统本身及网络传输过程中存在着一些问题，请给出针对数据库系统本身及网络传输过程中可能的一些调优方案。<br>(2)工程师在完成数据库系统本身和网络问题的优化后，发现第三方开发人员的SQL查询语句存在很多没有优化的问题，请从第三方开发人员角度给出一些优化方案。</p>
<p>①把数据、日志、索引放到不同的I&#x2F;0设备上，增加读取速度，数据量（尺寸)越大，提高I&#x2F;0越重要。②纵向、横向分割表，减少表的尺寸。<br>③升级硬件，扩大服务器的内存 ,Windows 2000和SQL Server 2000能支持4-8G的内存。配置虚拟内存，虚拟内存大小应基于计算机上并发运行的服务进行配置。增加服务器CPU个数。<br>分布式分区视图可用于实现数据库服务器联合体。<br>联合体是一组分开管理的服务器，但它们相互协作<br>分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层Web 站点的处理需要。<br>⑤重建索引: DBCC REINDEX ,DBCC INDEXDEFRAG;收缩数据和日志:DBCC SHRINKDB,DBCC SHRINKFILE。设置自动收缩日志，对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。<br>优化锁结构。<br>2)<br>①对查询进行优化，尽量避免全表扫描，首先应考虑在<br>where 及 order by 涉及的列上建立索引。<br>②应尽量避免在 where子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。③任何地方都不要使用select * from进行全表扫描<br>，用具体的字段列代替”*”，不要返回冗余字段。<br>④避免频繁创建和删除临时表，以减少系统表资源的消耗。<br>⑤尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。⑥尽量避免大事务操作，提高系统并发能力。</p>
<h2 id="第六套-恢复-性能优化"><a href="#第六套-恢复-性能优化" class="headerlink" title="第六套  恢复  性能优化"></a>第六套  恢复  性能优化</h2><p>某网上商城因为业务发展，原有的系统不能很好的满足需要，因此采用了一套新的经营管理系统，此系统使用SQL Server 2008数据库管理系统。此系统上线运行前，需将商场原有的数据导入到新系统中。原有系统使用SQL Server 2000，数据结构与新系统不完全一致。<br>因此需要把数据从SQL Server 2000导入到SQL Server 2008中，为了保证数据一致性，数据导人过程中要求暂停业务且必须在3小时内完成。<br>(1)在原有数据导入新系统的过程中，实施人员发现原有数据量很大，导人数据需要四小时，业务无法接受。经分析某工程师认为，数据导入过程中的数据库I／O很高，但导人数据的程序本身对系统资源占用率很低。该工程师建议将数据导人过程中的数据恢复模式从“完整”模式改为“简单”模式以提高数据导入速度；而另一位工程师则认为此方法未必能提高数据导人速度，而且还可能导致数据丢失，不建议使用此方法。<br>请分析此方法是否能够提高数据导入速度并给出理由，同时分析此操作的数据丢失风险。<br>(2)在成功导入历史数据后，此系统顺利上线运行。在上线运行的第一周，发现数据库服务器的CPU使用率很高，达到近90％，高峰期间达到100％，且系统内存占用率达到90％，但系统I／O很轻。业务人员反应系统操作速度很慢。为了提高系统运行速度。<br>在不修改应用程序的前提下，两位工程师提出了不同的解决办法：<br>Ⅰ 为服务器增加2颗CPU，缓解CPU使用率很高的问题；<br>Ⅱ 为服务器增加一倍内存，缓解内存使用率很高的问题。<br>考虑成本，现阶段只能按照一种方案实施。请指出在现有情况下，哪种方案更合理并给出理由。 </p>
<p>(1）此方法能够提高数据导入速度。<br>原因:此系统I&#x2F;o很高，修改恢复模式后，系统最大限度减少日志开销，可提高导入速度。由于仅在数据导入过程中修改恢复模式，所以并无数据丢失风险。<br>(2）第一种方案比较合理。原因:SQL Server 2008采用将数据缓冲在内存的方式，因此内存的使用率比较高是正常情况，且现阶段Ⅰ&#x2F;O并不存在问题，表明内存满足需求。此阶段CPU使用率很高，表明CPU计算资源不足，因此增加CPU数量对解决问题有效。</p>
<h2 id="第八套-性能优化"><a href="#第八套-性能优化" class="headerlink" title="第八套  性能优化"></a>第八套  性能优化</h2><p>设某超市经营管理系统使用SQL Server 2008数据库管理系统，此数据库服务器有2颗CPU、16GB内存、2TB磁盘。上线运行1年后，用户在生成每天每个销售人员及每个收银台的总销售额报表时速度缓慢。经技术人员分析，发现速度缓慢的原因为销售单据表和销售单据明细表数据量合计已经达到60GB。已知这两个表结构如下：<br>销售单据表(销售单据编号，销售时间，销售人员编号，收银台编号)<br>销售单据明细表(销售单据编号，商品编号，单价，数量)<br>在进行此报表计算时数据库服务器CPU消耗非常高。为了优化此操作，某工程师建议在销售单据表中增加”付款总金额”属性，取值由触发器自动计算。请从磁盘空间使用、销售操作时对数据库服务器的影响、数据一致性以及对总销售额计算速度影响方面分析此方案优劣。请判断此方案是否可行，并从时空代价和优化效果方面分析原因。</p>
<p>此方案不可行。<br>①触发器可以通过数据库中的相关表进行层叠更改，这比直接把代码写在前<br>台的做法更安全合理，保证了数据的一致性，但同时增加了磁盘空间的消耗。在超市经营中要批量操作、多次触发的情况下，触发器的效率低，因为<br>它相当于每次都执行一段SQL语句，使CPU的消耗更高。因而从时空代价角度来说并不能达到优化的效果。<br>②在数据单据表中增加”付款总金额”不是正确的优化方法，应该在数据单据明细表中增加”付款总金额”，这样才能提高查询效率<br>【解题思路】<br>在数据库设计阶段，主要强调的是高效率利用存储空间，减少数据的冗余，减少数据的不一致性，这个过程也就是规范化的过程。但是在数据库运行阶段要考虑到高效率的进行数据处理。<br>完全规划化的数据库会产生很多表，对于一个频繁使用的查询，如果它要求操作多个相关表中的数据，则每次为生成需要的查询结果而在连接多个表中相关行时，数据库管理系统就会消耗更多的计算资源，因为连接操作非常耗时。<br>而反规范化是将规范化的关系转换为非规范化的关系的过程，目的是提高查询的效率。常见的方法有增加派生冗余列，增加冗余列，重新组表，分割表和新增汇总表等方法。<br>该题解决的方式就是增加派生冗余列–”付款总金额”。派生性冗余列是指表中增加的列由表中的一些数据项经过计算而成，它的作用是查询时减少连接操作，避免使用聚合函数。例如销售单据明细表（销售单据编号，商品编号，单价，数量)中增加”付款总金额”，因为付款总金额&#x3D;单价*数量得到，说明”付款总金额”是派生性冗余列。如果不要该字段，那么每次使用总价时，都要先执行代码计算后才能使用，如果商品数量较多，而且要频繁使用”付款总金额”时，计算”付款总金额”时执行的次数也会随着增加，这显然会影响数据库的执行效率。若增加”付款总金额”这个派生性冗余字段，虽然破坏了规范化原则，但只要执行一次计算”付款总金额”就可以把商品金额存在数据库中，以后不管什么时候使用”付款总金额”字段，只需要提取其值就可以了，不必在执行代码了。因此增加”付款总金额”，虽然提高了磁盘空间的使用，但是可以提高系统执行的效率，达到以空间换时间的目的。</p>
<h2 id="第十一套-性能优化"><a href="#第十一套-性能优化" class="headerlink" title="第十一套  性能优化"></a>第十一套  性能优化</h2><p>3.设某超市经营管理系统(C&#x2F;S结构)使用SQL Server 2008数据库管理系统。系统上线运行1年后，用户反映系统运行速度不稳定，不定期会出现速度变慢的问题。<br>数据库管理员在数据库服务器上采集了一段时间系统运行状态数据，情况如下：<br>CPU最高使用率：30%<br>内存最高使用率：80%<br>磁盘IO很低<br>同时，数据库管理员在客户端使用ping命令对数据库服务器进行测试，结果如下<br>192.168.1.100 的Ping统计信息：<br>    数据包：已发送&#x3D;100，已接收&#x3D;90，丢失&#x3D;10<br>往返行程的估计时间（以毫秒为单位）：<br>    最短&#x3D;10ms，最长&#x3D;502ms，平均&#x3D;100ms<br>(5分)请根据以上数据，判断最有可能的问题，并给出判断的理由。<br>在以上问题解决后，用户反映每日的定时统计汇总SQL语句仍然速度比较慢。数据库管理员在系统无任何人员使用时运行该语句，同时在数据库服务器上采集系统运行状态数据，情况如下：<br>CPU最高使用率：12.5%(CPU配置：2路4核，共8核，关闭超线程)<br>内存最高使用率：80%(内存配置：128GB<br>磁盘IO很低(磁盘配置：5块300GB磁盘，RAID5)<br>(5分)请分析在进行统计汇总时，数据库服务器最有可能的瓶颈是CPU、内存还是磁盘，并给出判断的理由。</p>
<p>【参考答案】<br>(1）产生掉线的最有可能的原因是网络产生问题。因为通过ping命令测试，发现丢包率达到10%。而CPU，内存、磁盘I&#x2F;O使用率没有达到100%，说明还是有—定的富余，引起网络掉线的可能性较小。<br>(2）数据库服务器最有可能的瓶颈是内存。因为内存的使用率在无任何操作的情况下达到80%，使用率较高。说明内存容量不足以完全支持服务器活动。<br>对于一台数据库服务器来说，如果其在业务空闲时使用率超过90%，说明服务器缺乏CPU资源;如果高峰时CPU使用率仍然很低，则说明服务器CPU资源充足。据此，可以判断一个数据库系统CPU的使用情况。本题中CPU的最高使用率只有12.5%，说明CPU不可能是数据库服务器的瓶颈。磁盘&#x2F;O很低，说明也不可能是服务器的瓶颈。<br>【解题思路】<br>数据库系统运行需要依赖服务器、操作系统、存储、网络等多种因素。当这些数据库环境出现瓶颈时就会导致数据库运行变慢，甚至是无法完成正常业务。<br>一般情况下，数据库访问代价模型由四部分组成:CPU处理数据的时间(即CPU代价)，磁盘读取的时间(即I&#x2F;O代价)，查询的内存开销(即内存代价)，对于网络中的数据库还要加上数据在网络上传输的时间(即通信代价)。因此数据库访问的代价模型是:总代价&#x3D;CPU代价+l&#x2F;O代价+内存代价+通信的代价。<br>(1) CPU。当数据库操作对CPU性能的要求超过数据库服务器的CPU性能时，数据库性能就会受到CPU的限制。对于一台数据库服务器来说，如果其在业务空闲时使用率超过90%，说明服务器缺乏CPU资源;如果高峰时CPU使用率仍然很低，则说明服务器CPU资源充足。据此，可以判断一个数据库系统CPU的使用情况。解决的方法是为服务器适当增加CPU的数量或者终止需要许多资源的进程。<br>(2）数据库性能优劣的一个重要度量是响应时间，而I&#x2F;O时间是响应时间的最大组成部分。因此，可以通过令I&#x2F;O时间最小化，减少磁盘上的文件竞争带来的瓶颈等方法来改善数据库系统的性能。<br>(3)通过调整相关参数控制数据库的内存分配，也可以在很大程度上改善数据库系统的性能。<br>(4)大量的SQL数据在网络上传输会导致网速变慢。网卡、交换机、集线器等网络设备的性能对网络的影响很明显，所以，通过调整网络设备，也可以在—定程度上提高数据库系统的性能。</p>
<h2 id="第十三套-性能优化"><a href="#第十三套-性能优化" class="headerlink" title="第十三套  性能优化"></a>第十三套  性能优化</h2><p>设某学校选课系统使用SQL Server 2008数据库管理系统，在学生选课期间，用户反映速度缓慢，大部分时间内，学生无法正常选课（选课学生近1万人）。经技术人员分析，发现速度缓慢的原因为数据库服务器响应缓慢。在选课期间，数据库服务器CPU使用率为100%，内存使用率95%，磁盘IO占用10%，网络带宽占用20%。在进—步分析后发现，学生在选课过程中需要在每次选定课程前校验相关课程的成绩信息，而校验成绩的SQL语句在业务不繁忙时仍需要1-2分钟才能执行完成。现有服务器硬件情况如下:CPU:两颗英特尔至强处理器E5-2640 2.50GHz内存:128GB，主频1600MHz 磁盘:6块600GB 15000转6Gbps SAS硬盘，RAID5网卡:千兆网卡<br>为了保证系统稳定运行，现有如下优化方案:(1)将CPU更换为两颗英特尔至强处理器E5-2690 2.90GHz。(2）将内存提高到256GB，主频1600MHz。(3）将磁盘更换为6块800GB读取密集型MLC 6Gpbs硬盘，保持RAID5。(4）将网卡更换为万兆网卡。<br>(5)优化校验成绩SQL语句并建立相关索引，校验完成时间降低到1秒。根据题目描述，请从是否能解决选课运行速度缓慢问题的角度逐个评价以上5个方案并给出原因。</p>
<p>【参考答案】<br>(1)）提高CPU的主频，可以稍微缓解选课速度慢的问题。因为CPU主频提高，单位时间内处理的数据多一些，但不能根本解决服务器响应慢的问题。本题中的CPU在选课期间使用率达到100%，增加CPU的频率不能从根本解决问题。大量的SQL数据在网络上传输可能会导致网速变慢。<br>(2)内存提高，可以改善选课速度慢的问题，内存的增加可以从一定程度上提高数据处理的效率。本题中，选课期间内存使用率达到95%，说明内存没有完全使用，因此内存容量不是产生服务器响应慢的原因。<br>(3) SAS的特点是成本高、容量小、速度快，而MLC的特点是容量大、成本低,但是速度慢。因此替换原有的SAS硬盘不能提高数据存取的速度，不能解决选课运行速度慢的问题。<br>(4）更换网卡不能解决选课运行速度慢的问题，因为本题中网络带宽的使用率占用20%，说明网络问题不是选课慢的主要原因。<br>(5）可以从根本上解决选课慢的问题。原有校验成绩的SQL语句需要1-2分钟才能执行完成，当大量的学生选课时，CPU和内存主要用于处理SQL语句，大量的资源被消耗，引起服务器反应减慢。本题中，SQL语句的效率低下，是产生服务器响应慢的根本原因，应当对SQL语句优化。一般来说，效率低下的SQL语句常常是系统效率不佳的主要原因。<br>【解题思路】<br>数据库系统运行需要依赖服务器、操作系统、存储、网络等因素。当这些数据库环境出现瓶颈时会导致数据库运行缓慢，甚至无法完成业务。一般来说，可以从外部环境、调整内存分布、调整磁盘&#x2F;O、调整资源竞争等几方面来改变数据库的参数，提高其性能。<br>(1)外部调整包括CPU调整和网络调整。当数据库操作对CPU性能的要求超过数据库服务器的CPU性能时，数据库性能就受到CPU的限制，使数据库操作变慢。<br>(2)通过调整相关参数控制数据库的内存分配，也可以在很大程度上改善数据库系统的性能。<br>(3）调整磁盘&#x2F;O。数据库性能优劣的一个重要度量是响应时间，而I&#x2F;O时间是响应时间的最大组成部分。因此，可以通过令I&#x2F;O时间最小化，减少磁盘上的文件竞争带来的瓶颈等方法来改善数据库系统的性能。<br>(4)调整竞争。多个进程对相同的资源发出申请时，导致了竞争的发生，从而引起服务器的反应缓慢。<br>(5）效率低下的SQL语句常常是系统效率不佳的主要原因。因此采用高效率的SQL语句，可以显著减少服务器的反应时间，提高服务器处理的速度。<br>本题中，SQL语句的效率低下是产生服务器响应慢的根本原因，提高SQL语句的执行效率，可以有效提高服务器的响应速度。</p>
<h2 id="第十四套-索引-性能优化"><a href="#第十四套-索引-性能优化" class="headerlink" title="第十四套  索引 性能优化"></a>第十四套  索引 性能优化</h2><p>在数据库中存在销售单据明细表，其建表语句为:<br>CREATE TABLE销售单据明细表 (<br>销售单据编号 varchar(20),<br>商品编号 varchar(8),<br>单价 money,<br>数量 int,<br>总价 money<br>);<br>为了保持数据一致性，此表中存在如下触发器：<br>CREATE TRIGGER AutoCountSum<br>ON 销售单据明细表 FOR INSERT,UPDATE<br>AS<br>DECLARE @UnitPrice money,@Quantity int,@Amount money<br>SELECT @UnitPrice &#x3D; 单价,@Quantity &#x3D; 数量 FROM inserted<br>SET @Amount&#x3D;@UnitPrice * @Quantity<br>UPDATE 销售单据明细表 SET 总价&#x3D;@Amount<br>WHERE 销售单据编号&#x3D;(SELECT 销售单据编号 FROM inserted)<br>AND 商品编号&#x3D;(SELECT 商品编号 FROM inserted)<br>在系统运行一段时间后，此表中有近千万条数据，此时发现对此表以“销售单据编号”和“商品编号”为条件，对其他字段进行修改时操作速度很慢。请分析原因，并在不改变硬件和SQL语句的前提下，给出优化方法。<br>在解决了①中的问题系统平稳运行3年后，用户反映系统速度很慢，管理员考虑更换硬件。经过一段时间的监控，系统资源使用情况如下:CPU使用率一般不超过70%内存使用率95%磁盘IO使用率高峰期90%-95%，主要为读操作请根据以上数据，说明在此次更换硬件过程中，应该着重提高哪方面硬件性能，并给出原因。</p>
<p>(1）对字段修改时操作速度很慢的原因是大量数据的查询速度慢，从而引起修改慢。优化的方法是在“销售单据编号”和“商品编号”上建立索引。(2）更换硬件时应该提高内存容量，磁盘在经济条件许可的条件下才有RAID10磁盘阵列。</p>
<p>(1）索引技术是一种快速数据访问技术，建立索引的目的就是为了提高查询的效率。查询的性能在很大程度上取决于存在什么样的索引来加快选择和联接的处理。对于大星数据，只有快速的定位、减少查询的时间就会增加修改的速度。(2)对于CPU、内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。本题中，内存和磁盘的使用率都高于90%，而CPU的使用率不高于70%，说明内存、硬盘的资源匮乏，需要调整，而CPU的资源充足不需要调整。因此在硬件调整时，应提高内存的容量和硬盘的访问效率。使用RAID时，可以将基本表和建立在表上的索引分别放在不同的磁盘上，这样访问基本表时，存放数据和存放索引的磁盘驱动器并行工作，可以得到较快的文件读写速度;类似的，日志文件与数据对象（表、索引等)也可分别存放在不同磁盘上以改善系统的I&#x2F;O性能。在RAID中，RAID10是一个RAIDO与RAID1的组合体，它继承了RAIDO的快速和RAID1的安全，同时读写速度均提高。</p>
<h2 id="第十五套-分区-性能优化"><a href="#第十五套-分区-性能优化" class="headerlink" title="第十五套  分区 性能优化"></a>第十五套  分区 性能优化</h2><p>某学校网络计费系统使用SQL Server 2008作为数据库管理系统，系统中需保存每个用户的每次登录和退出时间，该表的结构如下：<br>CREATE TABLE 登录日志表(<br>    序列号       int identity(1,1),<br>    帐号         varchar(8),<br>    登录时间     datetime,<br>    退出时间     datetime,<br>    本次上网费用 real<br>);<br>在系统运行一段时间后，此表中有近5千万条数据。此时，用户按照登录时间查询自己近期上网情况时速度缓慢。为了提高用户体验，某工程师提出建议对此表进行分区，请分析其建议合理性（若合理请给出最优的分区方案），并说明原因。<br>在解决了①中的问题系统平稳运行3年后，管理员考虑升级硬件。经过监控，系统资源使用情况如下：<br>•CPU使用率一般不超过50%<br>•内存使用率90%<br>•磁盘IO使用率高峰期90%-95%，主要为读操作<br>某工程师给出两种升级后的硬件配置方案：<br>•配置一：2颗处理器，6核心，主频2.4GHz；64GB内存；300GB 10K转SAS硬盘，3块，RAID0<br>•配置二：2颗处理器，6核心，主频1.9GHz；128GB内存；800GB 固态硬盘 SAS 读取密集型 MLC，2块，RAID1<br>请根据以上数据，在不考虑费用因素的前提下，说明哪种配置更合理，并给出原因。</p>
<p>【参考答案】<br>(1）因为操作仅限于查询，建立分区表可以有效的提高查询效率。对登录日志表中在登录时间列上以月为单位创建右侧分区函数，将登陆日志表分成12个分区，每个分区对应一年中一个月的值。<br>(2）采用方案2。对于内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。本题中，内存和磁盘的使用率都高于90%，而CPU的使用率不高于50%，说明内存、硬盘的资源匮乏，需要调整，而CPU的资源充足不需要调整。因此在硬件调整时，应提高内存的容量和硬盘的访问效率。RAID1相对于RAIDO来说提高了读速度，加强了系统的可靠性，但是写效率没有提高。<br>【解题思路】<br>本题考查的是分区表的相关知识和数据库运行环境和参数调整知识。<br>(1）分区表是将表中的数据按照水平方式分成不同的子集，这些数据子集存储在数据库的一个或多个文件组中。合理使用分区会在很大程度上提高数据库的性能。是否创建分区表主要取决于表当前的数据星大小以及将来数据星大小，同时还取决于对表中数据进行的操作特点。通常，如果某个大型表同时满足下列条件，则比较适合于进行分区∶①该表包含(或将包含)以多种不同形式使用的大星数据，②数据是分段的，比如数据以年份分隔。然而，数据量大并不是创建分区表的唯一条件，如果表中大星的数据都是经常使用的数据，而且他们的操作方式基本是一样的，则最好不要使用分区表。而对数据的操作只涉及一部分数据而不是所有数据时，可以考虑建立分区表。<br>(2)对于CPU、内存、磁盘等硬件设备在空闲时使用率超过90%，说明硬件资源匮乏。如果在高峰时使用率小于90%说明硬件资源充足。<br>对于分区表来说，如果对某表中当前分段数据，经常进行的操作是添加、修改、删除、查询，而对于其他的数据，则几乎不操作，或者操作仅限于查询，那么就可以对表进行分区。<br>使用RAID时，可以将基本表和建立在表上的索引分别放在不同的磁盘上，这样访问基本表时，存放数据和存放索引的磁盘驱动器并行工作，可以得到较快的文件读写速度;类似的，日志文件与数据对象（表、索引等)也可分别存放在不同磁盘上以改善系统的I&#x2F;O性能。RAID1相对于RAIDO来说提高了读速度，加强了系统的可靠性，但是写效率没有提高。在RAID中，如果不考虑价格因素，其实RAID10最适合的，它是一个RAIDO与RAID1的组合体，它继承了RAIDO的快速和RAID1的安全，同时读写速度均提高。但题目中主要考查的读能力，因此RAID1RAIDO更适合些。</p>
<h2 id="第十七套-索引-性能优化"><a href="#第十七套-索引-性能优化" class="headerlink" title="第十七套  索引 性能优化"></a>第十七套  索引 性能优化</h2><p>设在SQL Server 2008某数据库中存在销售单据明细表，其建表语句为：<br>CREATE TABLE 销售单据明细表(销售单据编号 varchar(10),商品编号 varchar(8),是否有效 varchar(4),单价 money,数量 int,总价 money)<br>在系统运行一段时间后，此表中有近千万条数据。该系统中存在如下操作：<br>       select * from 销售单据明细表<br>         where 销售单据编号 &#x3D; ‘135671445’ and 商品编号 &#x3D; ‘021’ and 是否有效 &#x3D; ‘是’;<br>在系统运行中发现此操作的效率比较低，系统工程师提出如下建议：<br>由于查询中使用了“销售单据编号”、“商品编号”和“是否有效”三个条件，因此可以分别在这三列上建立索引，提高查询效率。<br>系统工程师建议中建立的三个索引是否能够提高查询效率？请简要说明原因。<br>随着系统运行时间增长，系统运行速度逐渐变慢，经分析为磁盘IO不能满足数据库系统频繁读写的要求。工程师建议增加一块相同磁盘，将两块磁盘调整为RAID1模式。请从读写两方面分析，此操作是否能够改善磁盘IO问题。</p>
<p>【解题,思路】<br>本题考查的是索引相关知识，如索引定义，在什么地方建立索引，建立索引的条件以及RAID1磁盘阵列的特点。<br>(1）索引的知识<br>索引技术是一种快速数据访问技术，它将一个文件的每个记录在某个或某些领域（或称为属性)上的取值与该记录的物理地址直接联系起来，提供了一种根据记录域的取值快速访问文件记录的机制。索引的使用要恰到好处，其使用原则一般如下:<br>1经常在查询中作为条件被使用的列，应为其建立索引;<br>②频繁进行排序或分组（即进行group by或order by操作）的列，应为其建立索弓3一个列的值域很大时，应为其建立索引;<br>④如果待排序的列由多个，应在这些列上建立复合索引。(2) RAID1磁盘阵列的特点<br>RAID1磁盘阵列级，是一种镜像磁盘阵列，其原理就是将一块硬盘的数据以相同位置指向另一块硬盘的位置。RAID1又称为Mirror或Miroring，它的宗旨是最大限度地保证用户数据的可用性和可修复性。RAID1的操作方式是把用户写入硬盘的数据百分之百地自动复制到另外一个硬盘上。由于对存储的数据进行百分之百的备份，在所有RAID级别中，RAID1提供最高的数据安全保障。同样，由于数据的百分之百备份，备份数据占了总存储空间的一半，因而，Mirror的磁盘空间利用率低，存储成本高。Mirror虽不能提高存储性能，但由于其具有的高数据安全性，使其尤其适用于存放重要数据，如服务器和数据库存储等领域。<br>RAID1提高了读速度，加强了系统可靠性。但其磁盘的利用率低，冗余度为50%，同时写速度并未提高。RAID1经常要求保证用户数据的可用性和可修复性场所，体现系统的可靠性，而不是读写速度。<br>RAID1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量<br>因为另一块只是当作数<br>据”镜像””。RAID1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAIDO磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID1磁盘阵列一般支持”热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。<br>【参考答案】<br>(1“销售单据编号”、“商品编号和“是否有效”都是查询的条件，因此在这三列上建立索引，可以提高查询效率。<br>原因:经常在查询中作为条件被使用的列，应为其建立索引，可提高查询效率。<br>(2):RAID1通常被称为Mirror，RAID中的硬盘分成相同而两组，互为镜像，当其中一块磁盘出现故障时，可以利用其镜像上的数据恢复，从而提高系统的容错能力。RAID1对数据的操作仍采用分块后并行传输方式。RAID1提高了读速度，加强了系统的可靠性。但其缺点是硬盘的利用率低，冗余度为50%，同时写速度并未提高。根据题意，磁盘IO不能满足数据库系统频繁读写的要求，如果增加一块相同磁盘，并调整为RAID1模式，能提高读的速度，但是写的速度并未提高，所以不能改善磁盘IO的问题。<br>或者<br>从读的方面来看：当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1可以提高读取性能，也提高了磁盘的存储空间。增加一个RAID1可以提高磁盘的存储空间，在一定程度上提高了读速度，加强了系统的可靠性。但是增加RAID1，系统变成四块硬盘，同时也就增加了系统的I&#x2F;O开销，当数据量大时，并不能很好地提高系统的读的速度。<br>    从写的方面来看：RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。现在增加了一块RAID1磁盘阵列，相当于有四块硬盘，在写入数据时，可能会做两个备份，写入的速度更慢。<br>    因此从读写两个方面来说，增加一块RAID1磁盘阵列不是解决问题的好的方式，这种方法不建议使用。</p>
<h2 id="第十八套-性能优化-索引·复合"><a href="#第十八套-性能优化-索引·复合" class="headerlink" title="第十八套  性能优化 索引·复合"></a>第十八套  性能优化 索引·复合</h2><p>在SQL Server 2008的数据库中存在如下两张关系表：<br>学生表(学号，姓名，性别，身份证号，系所号)，学号为主码<br>系所表(系所号，系所名，系所简称)，系所号为主码<br>在数据库中执行如下T-SQL代码：<br>DECLARE @DeptID varchar(10)<br>DECLARE @cnt int<br>SET @cnt&#x3D; 0<br>DECLARE cursor1 cursor FOR SELECT 系所号 FROM 系所表<br>    WHERE 系所名 LIKE ‘%电%’<br>OPEN cursor1<br>FETCH NEXT from cursor1 into @DeptID<br>WHILE @@FETCH_STATUS &#x3D; 0<br>BEGIN<br>    DECLARE @temp_cnt int<br>    SELECT @temp_cnt &#x3D; COUNT(<em>) FROM 学生表 WHERE 系所号 &#x3D; @DeptID<br>    SET @cnt &#x3D; @cnt + @temp_cnt<br>    FETCH NEXT from cursor1 into @DeptID<br>END<br>CLOSE cursor1<br>DEALLOCATE cursor1<br>SELECT @cnt AS 学生总数<br>执行过程中发现速度比较缓慢，为了解决性能问题，需在功能不变的情况下，将此T-SQL代码改为一条SQL语句：<br>  SELECT COUNT(</em>) FROM 学生表 JOIN 系所表 ON 学生表.系所号&#x3D;系所表.系所号<br>  WHERE 系所名 LIKE ‘%电%’<br>请分析此改变是否可以提高性能，并给出原因。<br>学生表的身份证号和姓名上建有一个复合索引，索引建立语句为<br>    CREATE INDEX idx_身份证号_姓名 ON 学生表 (身份证号,姓名)<br>请指出如下两个查询语句能否使用此索引并说明原因。<br>  SELECT * FROM 学生表 WHERE 身份证号 &#x3D; ‘123456789012345678’;<br>  SELECT * FROM 学生表 WHERE 姓名 &#x3D; ‘小明’;</p>
<p>【解题思路】<br>本题考查的是T-SQL与SQL语句使用的区别，以及索引相关知识，如索引定<br>入<br>义，在什么地方建立索引，建立索引的条件等等。<br>(1)T-SQL即Transact-SQL，是SQL在Microsoft SQL Server 上的增强版，它是用来让应用程序与SQL Server沟通的主要语言。T-SQL提供标准SQL的DDL和DML功能，加上延伸的函数、系统预存程序以及程式设计结构（例如IF和WHILE)让程式设计更有弹性。<br>SQL是集DDL、DML、DCL为—体的标准关系数据库语言。其中DDL数据定义语言用于定义和管理SQL数据库中的所有对象的语言;DML数据操纵语言，SQL中处理数据等操作统称为数据操纵语言。<br>SQL作为结构化查询语言，是标准的关系型数据库通用的标准语言;T-SQL是在SQL基础上扩展的SQL Server中使用的语言。<br>(2)索引的知识<br>索引技术是—种快速数据访问技术，它将一个文件的每个记录在某个或某些领域(或称为属性)上的取值与该记录的物理地址直接联系起来，提供了一种根据记泉域的取值快速访问文件记录的机制。索引的使用要恰到好处，其使用原则—般如下:<br>①经常在查询中作为条件被使用的列，应为其建立索引;<br>②频繁进行排序或分组(即进行group by或order by操作)的列，应为其建立索引;<br>③一个列的值域很大时，应为其建立索引;<br>④如果待排序的列由多个，应在这些列上建立复合索引。【参考答案】<br>(1) SELECT COUNT(*)FROM学生表JOIN系所表ON学生表.系所号&#x3D;系所表.系所号WHERE系所名LIKE’%电%’性能更好。<br>原因:T-SQL的代码需要先扫描—遍系所表，然后根据扫描得到的每个记录重新扫描—遍学生表得出结果。使用所写的SQL语句实现同样的功能，将学生表和系所表连接之后按条件过滤，只需要扫描一遍连接之后的表即可。(2）创建的复合索引对第二条语句的查询效率提高不明显，因为其是复合索引且身份证号排在前面，对查找姓名的查询效率提高不明显，而明显会提高第—条语句的查询效率。<br>或者<br>：[1]:能够提高性能。<br>    原本的代码中使用了游标。游标是一种临时的数据库对象，常见用途就是保存查询结果，以便以后使用。游标的结果集是由SELECT语句产生的，如果处理过程需要重复使用一个记录集，那么创建一次游标而重复使用若干次，比重复查询数据库要快的多。<br>    但是，题中检索的是系所名中含有”电”字的，事实上所有学生被检索的概率理论上都是相同的，此处不符合”创建一次，使用多次”的前提条件。<br>    另外，游标使用时会对行加锁，可能会影响其他业务的正常进行。同时数据量大时，游标会导致效率低下。<br>    还有，游标其实是相当于把磁盘数据整体放入了内存中，可能会带来巨量的内存占用的情况。<br>    综上所述，一般情况下尽量不要使用游标，因为会降低效率影响性能。除非遇到特殊情况。游标在使用完毕后应及时释放销毁，以释放资源。<br>[2]:第一条select语句可以使用此索引，第二条select语句无法使用此索引。<br>    基于多个列来创建的索引是复合索引。以下列语句为例：<br>    CREATE INDEX idx_test ON 学生表 (身份证号,姓名,性别)<br>    此索引将优先对”身份证号”排序（第一顺序），若存在身份证号相同的多名学生，则对这些学生的”姓名”排序（第二顺序），若姓名也存在相同的，则按照”性别”排序（第三顺序）。</p>
<pre><code>在使用上述示例的复合索引时，存在下列限制：
</code></pre>
<p>复合abc索引中，可以查询只可以a，ab，abc<br>         所以，题中第一条select语句是单独查询第一顺序的身份证号，可行；题中第二条select语句是单独查询第二顺序的姓名，无法使用该复合索引</p>
<h2 id="第二十套-并、交、差运算-性能优化"><a href="#第二十套-并、交、差运算-性能优化" class="headerlink" title="第二十套  并、交、差运算 性能优化"></a>第二十套  并、交、差运算 性能优化</h2><p>某商品经营管理系统使用SQL Server数据库。在数据库中存在销售单据表，建表语句为：<br>CREATE TABLE 销售单据表(<br>销售单据编号 char(20),<br>付款总金额 money,<br>销售日期 datetime,<br>销售人员编号 varchar(8),<br>收银台编号 varchar(6)<br>);<br>由于该表数据量巨大，因此建立了销售单据历史表，将1年以前的数据从销售单据表转入销售单据历史表。销售单据历史表的建表语句如下：<br>CREATE TABLE 销售单据历史表(<br>销售单据编号 char(20),<br>付款总金额 money,<br>销售日期 datetime,<br>销售人员编号 varchar(8),<br>收银台编号 varchar(6)<br>);<br>其中销售单据编号为主键，在收银台编号和销售人员编号上有索引。<br>[1]在系统运行一段时间后，发现如下语句执行速度缓慢：<br>SELECT 销售单据编号,付款总金额,销售日期 FROM 销售单据表 WHERE 收银台编号&#x3D; ‘001000’<br>union<br>SELECT 销售单据编号,付款总金额,销售日期 FROM 销售单据历史表 WHERE 收银台编号&#x3D; ‘001000’<br>请给出该语句执行速度缓慢的原因，并给出SQL语句的优化方案。<br>[2]在系统运行过程中，磁盘I&#x2F;O很重，数据库数据量近200G且磁盘写入性能要求非常高。考虑对硬件进行升级，3位工程师给出了不同配置方案：<br>•方案1：CPU保持不变，内存16G，2块300GB SAS硬盘，使用硬件RAID卡做RAID1<br>•方案2：CPU保持不变，内存8G，4块300GB SAS硬盘，使用硬件RAID卡做RAID0<br>•方案3：CPU保持不变，内存16G，3块146GB SAS硬盘，使用硬件RAID卡做RAID5<br>在不考虑成本的情况下，请指出哪种方案更适合此应用并给出原因。</p>
<p>本题考查的是sQL语言支持对查询结果在进行并、交、差运算以及不同磁盘阵列RAID的特点。<br>(1）并运算可将两个或多个查询语句的结果集合并为一个结果集，这个运算可以使用UNTON运算符直符实现。UNION是一个特殊的运算符，通过它可以实现让两个或更多的查询产生单一的结果集。<br>使用UNION谓词的语法格式为:<br>SELECT语句1<br>UNION [ALL ]SELECT语句2UNION [ALL]…<br>SELECT语句n<br>其中:ALL表示在结果集中包含所有查询语句产生的全部记录，包括重复的记录。如果没有指定ALL，则系统默认是删除合并后结果集中的重复记录。UNION和UNION ALL的区别是:UNION会自动压缩多个结果集合中的重复结果，而UNION ALL则将所有的结果全部显示出来。<br>(2）磁盘阵列RAID所采用的方法不同，可以将其分为很多级别，常见的RAID级别有RAIDO、RAID1、RAID5等。下面分别对不同级别RAID的特点进行介绍。<br>①RAID O向RAID O写入数据时，RAID将数据分成许多块，然后并行地将它们写到RAID中各个硬盘上﹔读出数据时，RAID从各个硬盘上读取数据，把这些数据恢复为原来顺序后传给主机。RAID O的优点是采用数据分块、并行传送方式，能够提高读写速度。但RAID中存储空间没有冗余，对系统的可靠性没有任何提高，任一个硬盘介质出现故障时，数据将无法恢复。<br>②RAID 1:RAID 1通常也被称为Mimor，RAID中的硬盘分为相同的两组，互为镜像，当其中一块磁盘出现故障时，可以利用其镜像上的数据恢复，从而提高系统的容错能力。RAID1对数据的操作仍然采用分块后并行传输方式。RAID 1提高了读速度，加强了系统的可靠性。但其缺点是硬盘利用率低，冗余度为50%，同时写速度并未提高。<br>③RAID 5、RAID 5可以为系统提供数据安全保障，但保障程序要比RAID 1低而磁盘空间利用率要比RAID 1高。RAID) 5具有和RAID O相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息.，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低。<br>【参考答案】<br>(1)在执行完Union语句后，需要对表中数据逐个查询，该表数据量较大，所以执行速度缓慢。sQL语句的优化方案:<br>SELECT销售单据编号,付款总金额,销售日期FROM销售单据表WHERE收银台编号&#x3D;’001000’Union All<br>SELECT销售单据编号,付款总金额,销售日期FROM销售单据历史表WHERE收银台编号&#x3D;’001000<br>这个执行效率较高。在执行完Umion语句后，执行alti语句，根据由销售日期和销售人员编号建立的索引，直接查询，故效率较高。<br>(2)RAID O并行读写于多个磁盘上，具有很高的数据传输率，但它只是单纯地提高性能，并没有为数据的可靠性提供保障。RAD 1高数据可靠性，通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能，但是CPU占用率同样也很高，而磁盘的利用率比较低。RAID 5是一种存储性能、数据安全和存储成本兼顾的存储解决方案。故方案3更合适。<br>或者<br>[1]union有一个distanct的动作，需要进行并运算的数据量越大，其操作执行越慢。只需把union改为union  all，就会取消这个distanct操作，速度将会大幅增加。</p>
<p>[2]由于题目已提及I&#x2F;O很高，方案1的RAID1方案对于I&#x2F;O没有帮助，所以否决。<br>    方案2的RAID0方案虽然对磁盘I&#x2F;O的提升最大，但是由于RAID0对于数据的可靠性没有任何帮助，暂时候选。<br>    方案3采用RAID5方案。RAID5的读取性能与RAID0接近，但写入速度比单个磁盘稍慢，而数据的可靠性高于RAID0。<br>    结合题目提及对于磁盘写入性能要求非常高，所以只能选方案2，因为方案1对读写性能没有提升，而方案3本题中十分看重的降低了写入性能。</p>
<h2 id="第二十一套-索引-性能优化"><a href="#第二十一套-索引-性能优化" class="headerlink" title="第二十一套  索引 性能优化"></a>第二十一套  索引 性能优化</h2><p>在SQL Server某数据库中存在销售单据明细表，其建表语句为：<br>CREATE TABLE 销售单据明细表（销售单据编号 varchar(20),商品编号 varchar(8),单价 money,数量 int);<br>系统运行一段时间后，此表中有近千万条数据，程序员在数据库中执行如下SQL语句：<br>SELECT 商品编号,sum(单价*数量) FROM 销售单据明细表 WHERE 单价&gt;150 GROUP BY 商品编号<br>1.为提高此查询的执行效率，在不改变SQL语句且不进行硬件调整的情况下，请给出提高查询执行效率的方案。<br>2.在运行过程中，发现此系统数据库CPU使用率很高，达到近95%，高峰期间达到100%，且系统内存使用率达到90%，但系统I&#x2F;O很轻。业务人员反映系统操作速度慢。为了提高系统运行速度，在不修改应用程序的前提下，两位工程师提出了两种不同的解决方案：<br>方案一：为服务器增加1颗CPU<br>方案二：为服务器增加一倍内存<br>考虑成本因素，现阶段只能选择一种方案实施。请指出在现有情况下，哪种方案更合理并给出原因。</p>
<p>【参考答案】<br>(1）在不改变SQL语句且不进行硬件调整的情况下，可以为销售单据明细表“商品编号”建立一个索引来提高查询的效率。<br>(2)方案一合理。提高数据库性能的方法，一般是从外部环境、调整内存分配、调整磁盘IO、调整竞争资源等几方面着手来改变数据库的参数。SQL Server采用将数据缓冲在内存的方式，因此在数据库系统运行的过程中会占用一定的内存，又因为IO并不存在问题, 说明内存上满足需求。CPU使用率很高，说明CPU计算能力不足，应增加CPU的数量。<br>或者<br>1、由于运行一段时间后，就有了近千万条数据，说明数据的写入量很大，这种情况下不能使用索引，因为写入量大，所以索引的维护开销将非常巨大，不仅无法提高效率，反而会降低性能，所以不适合查询优化。<br>由于题目不允许改变SQL语句，所以无法使用反规范化或使用临时表的方式，以空间换取时间。题目同样不允许硬件调整，不允许进行硬件升级。<br>本题最适合的方案是数据表的水平分割，由于商品编号有很多，所以应该按照单价区间进行水平分割<br>2、根据题目表述，两种方案都能够提高系统运行速度。但是，即便是平峰时CPU的负载也很高，高峰时甚至达到100%，而内存使用率低于CPU使用率，迫切程度低于CPU的需求。所以在成本有限的前提下，应该选择方案1，增加一颗CPU以缓解CPU的性能压力。选择此方案所得到的效果将高于方案2。</p>
<h2 id="第二十二套-索引-触发器"><a href="#第二十二套-索引-触发器" class="headerlink" title="第二十二套  索引 触发器"></a>第二十二套  索引 触发器</h2><p>某商品经营管理系统使用SQL Server数据库管理系统。在数据库中存在销售单据明细表，其建表语句为:<br>CREATE TABLE销售单据明细表 (<br>销售单据编号 varchar(20),<br>商品编号 varchar(8),<br>单价 money,<br>数量 int,<br>总价 money<br>);<br>为了保持数据一致性，此表中存在如下触发器：<br>CREATE TRIGGER AutoCountSum ON 销售单据明细表 FOR INSERT,UPDATE<br>AS<br>DECLARE @UnitPrice money,@Quantity int<br>SELECT @UnitPrice &#x3D; 单价,@Quantity &#x3D; 数量 FROM inserted<br>UPDATE 销售单据明细表 SET 总价&#x3D;@UnitPrice * @Quantity<br>WHERE 销售单据编号&#x3D;(SELECT 销售单据编号 FROM inserted) AND 商品编号&#x3D;(SELECT 商品编号 FROM inserted)<br>在系统运行一段时间后，此表中有近一千万条数据。<br>程序员在数据库中执行如下SQL语句：<br>SELECT 商品编号,sum(数量) FROM 销售单据明细表 WHERE 单价&gt;200 GROUP BY 商品编号<br>为提高此查询的执行效率，在不改变SQL语句的情况下，请给出提高查询执行效率的方案并阐明理由。<br>对此表的插入操作速度很慢，请分析插入速度慢的原因，并在不改变数据库服务器硬件、不改变表基本结构、不清理数据的情况下，说明应如何优化此表的插入操作。</p>
<p>【参考答案】<br>(1）在不改变SQL语句且不进行硬件调整的情况下，可以为销售单据明细表“商品编号”建立一个索引来提高查询的效率。<br>另外如果只针对本条select语句进行优化，那么还可以使用分区表的方式，将单价按照&lt;&#x3D;200和&gt;200的关系分为两张表，也可以提高检索效率。<br>(2）在一个插入或更新事务处理中，新建行被同时添加到INSERTED表和触发器表中。INSERTED表中行是触发器表中新行的副本。当表中有一千万条数据时，INSERTED表中也存储着大量的数据，而触发器要在INSERTED表中进行查询，所以插入的速度会很慢。可以通过删除INSERTED表中数据的方法来优化插入的速度,不会影响数据库服务器硬件、不改变表基本结构、不清理数据的情况下。<br>或者<br>(2)由题可知，该触发器名叫AutoCountSum，是后触发型触发器，引发触发器执行的操作是插入（insert）和更新（update）。<br>该触发器执行时，会定义两个变量@UnitPrice和@Quantity，分别用来存储刚刚插入的单价和数量（因为是inserted表），并将销售单据明细表中对应记录的总价更新为@UnitPrice * @Quantity ，即单价*数量的值。<br>触发器的缺点是会消耗系统资源，如果频繁触发，对系统性能影响将会非常大。根据题中描述，系统运行一段时间后表中有近一千万条数据，说明插入操作非常频繁，所以触发器是导致插入速度慢的直接原因。只需要使用存储过程来替代触发器即可解决此问题，优化此表的插入操作</p>
<h2 id="第九套-备份"><a href="#第九套-备份" class="headerlink" title="第九套  备份"></a>第九套  备份</h2><p>设某超市经营管理系统使用SQL Server 2008数据库管理系统。为了保证数据库可靠运行，数据库管理员设置了每天夜间对数据库一次全备份，备份数据保留2个月的备份策略。上线运行1年后，SQL Server数据库中数据已经达到近200GB。每天夜间要运行3个小时才能将数据库进行一次全备份，影响了夜间统计等业务正常运行。同时，备份空间也非常紧张。请解释出现此现象的原因，并提出优化的方法。(10分)</p>
<p>产生此现象的原因是系统采用了全备份策略，随着业务的开展，需要备份数据量逐渐增大，备份时间越来越长，占用了系统的资源，从而影响了其它业务。解决的方法是采用全备份+差异备份+日志备份组合策略备份数据库。全备份+差异备份+日志备份组合策略是指在全备份中加—些差异备份，比如每周日0:00进行一次全备份，然后每天0:00点进行一次差异备份，然后再两次差异备份之间增加一些日志备份。这样做备份和恢复的速度都比较快，而当系统出现故障时，丢失的数据也很少。<br>备份示意图如下:<br>目志备份1目志备份2<br>日志备份3目志备份4<br>全各份1<br>差异各份1<br>差异各份2<br>周o:oo12:0018:00周一0:0o<br>12:0018:00周二0:0o<br>如果系统在周二的差异备份之前出现故障，则应首先尝试备份活动日志（(日志尾部)，然后再按顺序恢复全备份1，差异备份1，日志备份3和日志备份4，然后再恢复备份的尾部日志。如果尾部日志备份成功，则数据库可以还原到故障点。<br>这种备份策略虽然备份频率高，但是备份时间短，占用的备份空间也小，而且不会产生数据丢失。<br>【解题思路】<br>全备份(Full Backup)就是对整个系统进行完全备份，包括系统和数据。这种备份方式的好处就是很直观，容易被人理解，当数据丢失时容易恢复。然而它也有不足之处:首先由于每天都对系统进行完全备份，因此在备份数据中有大量重复的，这些重复的数据占用大量的存储空间;其次，由于需要备份的数据量相当大，因此备份所需的时间比较长。<br>差异备份(Differential Backup)就是每次备份的数据是相对于上一次全备份之后增加和修改过的数据。它以前一次全备份为基准点，备份全备份之后变化的数据文件、日志文件以及数据库中其它被修改的内容。因此，差异备份通常比全备份占用的时间小且执行速度快，带回增加备份的复杂程度。日志备份(Log Bakup) :日志备份并不备份数据库本身，它只是备份日志记录，从而只备份上次备份之后到当前备份时间发生变化的日志内容。-般情况下，日志备份比完整备份和差异备份使用的资源少，因此可以更频繁的使用日志备份，以减少数据丢失的风险。<br>全备份+差异备份+日志备份组合策略组合了三种备份方式的优点，可以缩短备份时间、节约备份空间，提高备份的效率。</p>
<h2 id="第十套"><a href="#第十套" class="headerlink" title="第十套"></a>第十套</h2><p>设某社交网站使用SQL Server 2008数据库管理系统，上线运行1年后，用户操作速度明显变慢，数据库服务器负荷很高。经技术人员分析，发现速度缓慢的原因为用户频繁访问网站，查看自己是否有新消息。某工程师建议利用数据库复制技术将相关数据表定期（例如1分钟)分发到另外一台服务器的只读数据库中，以便用户查询使用。请从数据─致性、用户体验、可扩展性三个方面逐一分析此方案优劣。说明此方案是否可行，并简要给出理由。</p>
<p>优点:该方案能满足数据一致性。因为利用数据库快照复制技术，可以将相关表分发给另外一台服务器，可以满足数据的一致性。<br>数据的更新可以采用自动更新和手动更新方式。更新时间可以在建立分发数据库时设置，设置时间小于1分钟。通过这种方式可以满足用户体验。<br>数据库的分发只是在软件层面进行，对于已经建好的发布和定阅可以直接用delete按钮删除，然后重新进行设置，可扩展性强。<br>缺点:增加了一台服务器的开销。<br>对于本题，该方案可行。存放网站系统的服务器被设为发布服务器，另外一台服务器可以作为分发服务器和订阅服务器。发布服务器以事务复制的方式向分发服务器发送信息。客户端通过订阅服务器获取数据，实现信息同步更新。这种方式不会影响网站系统服务器的运行，又能保证客户端可以随时刷新信息。<br>【解题思路】<br>SQL Server主要采用发布、分发、订阅的方式来处理复制。源数据所在的服务器是发布服务器，复制发布数据。发布服务器把要发布的数据的所有改变情况复制到分发服务器，分发服务器包含一个分发数据库，可接收数据的所有改变，并保存这些改变，再把这些改变发给订阅服务器。<br>SQL Server复制技术包括快照复制、事务复制和合并复制。<br>快照复制:发布服务器会定时向订阅服务器传送数据，如果订阅服务器修改过数据，定时传递后订阅服务器的数据修改会全部丢失，全部以发布服务器为准。事务复制:发布服务器会定时检查数据是否有修改过，如果有则向订阅服务器传送数据（记录行级)。<br>合并复制:发布服务器与订阅服务器可以独立修改，会定时合并。</p>
<p>【康解释】</p>
<h2 id="第十二套-分割表-分区表"><a href="#第十二套-分割表-分区表" class="headerlink" title="第十二套  分割表 分区表"></a>第十二套  分割表 分区表</h2><p>设某超市经营管理系统使用SQL Server 2008数据库管理系统，上线运行一年后，用户反映速度缓慢。经技术人员分析，发现速度缓慢的原因为销售单据表和销售单据明细表数据量巨大，当进行这两个表相关查询时就会造成SQL语句执行缓慢。已知这两个表结构如下：销售单据表(销售单据编号，付款总金额，销售时间，销售人员编号，收银台编号)，销售单据明细表(销售单据编号，销售时间，商品编号，单价，数量，总价)从业务上看，程序经常会查询1个月内和最近6个月内销售相关数据。为了保证系统稳定运行，两位工程师分别给出了两种优化方案：甲工程师：按照销售时间将两张表分别拆分为每月一张表，在系统进行查询时按照给定条件到相关的表中直接查询，降低查询涉及到的数据。乙工程师：使用SQL Server 2008的分区功能，将两张表变为分区表，按照销售时间每年一个分区，降低查询涉及到的数据。请从程序修改的难易程度、查询1个月内数据的执行速度、查询最近6个月内数据的执行速度3个方面比较甲乙工程师方案。根据上述分析结果，请基于甲乙工程师的方案给出最合理的优化方案并说明理由。</p>
<p>【康解释】<br>表分割对于所有的数据库都适用，而表分区只能用于特定的数据库;表分区属于数据库物理设计，表分割属于逻辑设计。<br>从程序修改的难易程度：甲工程师易于实现。<br>查询1个月内数据的执行速度：甲工程师速度快<br>查询最近6个月内数据的执行速度：乙工程师快</p>
<p>采用乙工程师的优化方案比较好。因为分区表的特点是∶如果数据量大，而且数据是分段的，而且对不同段的数据使用的操作不同，则适于使用分区表。本题中对表中当前月的数据，经常进行的操作是添加、修改、删除和查询，而对于以往的数据，则几乎不需要操作，或者操作仅限于查询，那么就可以按月份对表进行分区，从而提高系统的执行效率。</p>
<h2 id="第十六套-触发器-临时表"><a href="#第十六套-触发器-临时表" class="headerlink" title="第十六套  触发器 临时表"></a>第十六套  触发器 临时表</h2><p>某学校图书管理系统保存了能够借书的教师数据，该数据来源于人事系统(另一家开发商开发)的教师数据。现需要将教师数据自动同步到图书管理系统中，教师数据总计约1万条，每天数据修改量约20条。<br>为了实现自动数据同步，图书管理系统新上线了一数据同步程序。在同步程序上线后，数据库管理员发现每天数据备份量大幅度增加，尤其是数据库日志大幅度增加。经核查，该数据同步程序操作为每10分钟将所有从人事系统中同步的数据删除，而后将数据重新插入。<br>现需要对同步程序进行优化，某工程师提出了两套方案：<br>    ①在人事系统相关表中新增触发器，提取新增数据到增量数据表，同步程序每10分钟将增量数据表中数据同步至图书管理系统中。<br>    ②在图书管理系统中新建一临时数据库，在其中新增与人事系统结构相同的表，同步程序每10分钟将人事的数据传输到图书管理系统对应表中，在图书管理系统数据库中使用SQL语句对比图书管理系统数据，获取增量后修改图书管理系统数据。<br>请从对人事系统影响、对图书管理系统影响、系统整体运行效率、相关开发人员协调复杂度四方面比较两套方案，并给出理由。</p>
<p>使用方案①，如果数据量大时会影响人事系统的运行，但对图书管理系统影响不大，系统整体运行效率能提高，相关开发人员协调复杂度也小。而使用方案②会影响人事系统和图书管理系统的运行，也会增加系统的开销，相关开发人员协调的复杂度，比方案①低。<br>总体而言，方案①优于方案②。<br>原因是在方案①中，只有在触发器设计时需要相关人员协调，数据量大时可能会影响人事系统的运行，而方案②只有在开发人员协调的复杂度比方案①低以外，总体来说会增加图书管理系统的开销。因为新建的数据库会占用系统的开销，影响系统整体运行的效率。<br>【解题思路】<br>触发器是―种特殊的存储过程，其特殊性在于它不需要由用户来直接调用，而是对表中的数据进行UPDATE、INSERT和DELETE操作时自动触发执行的。触发器通常用于保证业务规则和数据完成性，其主要优点是用户可以用编程的方法来实现复杂的处理逻辑和商业规则，增强了数据完整性约束的功能。触发器通常用在下列场合:完成比CHECK约束更复杂的数据约束，为保证数据库性能而维护的非规范化数据，可实现复杂的商业规则，触发器也可以评估数据修改前后的表状态，并根据差异采取对策。在方案①中，只有在触发器设计时需要相关人员协调，数据量大时可能会影响人事系统的运行，但是总体而言是比方案②优秀的。</p>
<p>【康解释】<br>     方案1，在数据量大时会影响人事系统相关表的运行，但对图书管理系统影响不大，系统的整体效率会提高，相关开发人员协调复杂度小<br>     方案2，会影响人事系统和图书管理系统的运行，新建数据库会增加系统的开销，影响系统整体运行效率，相关人员协调的复杂度相比较方案1，更低<br>    综上所述，方案1优于方案2.因为而方案2仅仅在开发人员协调的复杂度比方案1低</p>
<h2 id="第十九套-索引-A-S架构"><a href="#第十九套-索引-A-S架构" class="headerlink" title="第十九套  索引 A-S架构"></a>第十九套  索引 A-S架构</h2><p>在SQL Server 2008数据库中存在销售单据明细表，其建表语句为：<br>CREATE TABLE 销售单据明细表(<br>    销售单据编号 varchar(8),<br>    商品编号     varchar(8),<br>    单价         money,<br>    数量         int,<br>    总价         money<br>);<br>在系统运行一段时间后，此表中有近千万条数据，程序员在数据库中执行如下SQL语句：<br>    SELECT 商品编号, sum(总价) FROM 销售单据明细表 WHERE 单价 &gt; 50 GROUP BY 商品编号<br>为提高此查询的执行效率，需在此表中建立索引，请给出建立索引的方案。<br>为了提高系统的可靠性和性能，某工程师提出将原有单机运行的SQL Server 2008改为Active-Standby架构的数据库运行模式：在不考虑硬件性能提升因素的前提下，请分析此架构是否能够提高系统的性能和可靠性，并说明原因。</p>
<p>本题考查的是索引相关知识，如索引定义，在什么地方建立索引，建立索引的条件等等，以及Active-Standby架构的数据库运行<br>模式的机<br>制。</p>
<p>(1)【参考答案】<br>CREATE UNIQUE CLUSTERED INDEX ix_商品编号on销售单据明细表(商品编号)<br>(2)【参考答案】<br>此架构为数据库服务器容错架构，双机热备份方案中的双机热备模式。在不考虑硬件性能提升因素的前提下，此架构是能够提高系统的性能和可靠性，<br>原因:<br>双机热备份技术是一种软硬件结合的较高容错应用方案。该方案是由两台服务器系统和一个外接共享磁盘阵列柜及相应的双机热备份软件组成。<br>在这个容错方案中，操作系统和应用程序安装在两台服务器的本地系统盘上，整个网络系统的数据是通过磁盘阵列集中管理和数据备份的。<br>数据集中管理是通过双机热备份系统，将所有站点的数据直接从中央存储设备读取和存储，并由专业人员进行管理，极大地保护了数据的安全性和保密性。用户的数据存放在外接共享磁盘阵列中，在一台服务器出现故障时，备机主动替代主机工作，保证网络服务不间断。</p>
<p>(2) Active-Standby架构的数据库运行模式<br>双机热备特指基于高可用系统中的两台服务器的热备(或高可用)，因两机高可用在国内使用较多，故得名双机热备，双机高可用按工作中的切换方式分为:主-备方式(Active-sStandby方式)和双主机方式(Active-Active方式)，主-备方式即指的是一台服务器处于某种业务的激活状态(即Active状态)，另一台服务器处于该业务的备用状态(即Standby状态)。而双主机方式即指两种不同业务分别在两台服务器上互为主备状态(即Active-Standby和Standby-Active状态)。<br>双机热备有两种实现方式，一种是两台服务器通过一个共享的存储设备（一般是共享的磁盘阵列或存储区域网SAN)，通过安装双机软件实现双机热备，称为共享方式。另一种方式是没有共享的存储设备，数据同时存放于各自服务器中，称为纯软件方式或软件同步数据方式。基于存储共享的实现方式是双机热备的最标准的方案，在主从模式工作中，两台服务器以一个虚拟的IP地址对外提供服务，服务请求发送给主服务器(active server) 承担。同时，两台服务器通过心跳线(heartbeat line)侦测另一台服务器的工作状况。一旦主服务器出.见故障，备服务器(standby server)根据心跳侦测的情况做出判断，在较短时间内完成切换，接管主机上的所有资源，成为新的主服务器。由于使用共享的存储设备，因此两台服务器使用的实际上是一样的数据，由双机或集群软件对其进行管理。</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-19T11:19:20.836Z" itemprop="datePublished">2022-07-19</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/考试大题第二题" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver2/">『SQL Server』考二</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>没有8，9，至10（含）</p>
<h2 id="第一套"><a href="#第一套" class="headerlink" title="第一套"></a>第一套</h2><p>商品表（商品号，商品名，单价）<br>销售表（销售单据号，商品号，销售时间，销售数量，销售单价）。<br>商品号，单价，销售数量，销售单价均为整型<br>请编写查询某年某商品的销售总毛利的存储过程，毛利&#x3D;销售数量<em>（销售单价-单价）<br>要求商品号和年份为输入参数，总毛利用输出参数返回。<br>CREATE PROC p_name @商品号 int,@年份 int,@毛利 int output<br>AS<br>DECLARE @销售量 int,@单价 int,@销售单价 int<br>BEGIN<br>SELECT @单价 &#x3D; 单价 FROM 商品表 WHERE 商品号&#x3D;@商品号<br>SELECT @销售单价&#x3D; 销售单价, @销售量&#x3D; sum(销售数量)FROM 销售表 WHERE<br>@商品号&#x3D;商品号 AND 销售时间&#x3D;@年份<br>IF @单价 IS NULL THEN  &#x2F;<em>有？</em>&#x2F;<br>  ROLLBACK;<br>  RETURN;<br>END IF<br>IF @销售单价 IS NULL THEN&#x2F;<em>卖？</em>&#x2F;<br>  ROLLBACK;<br>  RETURN;<br>END IF<br>SET @毛利&#x3D;(@销售单价-@单价)</em>@销售量<br>end</p>
<h2 id="第二套"><a href="#第二套" class="headerlink" title="第二套"></a>第二套</h2><p>在SQL Server 2008中，设某数据库中有商品表（商品号，商品名，进货价格)，商品号为主码;销售表（商品号，销售时间，销售数量，销售价格，本次利润)，商品号和销售时间为主码，销售价格为本次销售商品的单价。现要求每当在销售表中插入前4列数据时（假设—次只插入一行数据)，系统自动计算本次销售产生的利润，并将该利润赋给销售表的第5列”本次利润”。请编写实现上述功能的后触发型触发器代码。(10分)<br>CREATE TRIGGER tri_name ON 销售表 FOR INSERT<br>  AS<br>   DECLARE @进价 money, @销量 int,@售价 money,@利润 money<br>   SElECT @进价 &#x3D; 进货价格 FROM 商品表<br>   SELECT @销量 &#x3D; 销售数量,@售价 &#x3D; 销售价格 FROM inserted<br>   SET @利润 &#x3D; @销量*(@售价-@进价)<br>   UPDATE 销售表 SET 本次利润 &#x3D; @利润<br>   WHERE 商品号 IN(SELECT 商品号 FROM inserted)<br>   AND 销售时间 IN(SELECT 销售时间 FROM inserted)<br>END</p>
<h2 id="第三套"><a href="#第三套" class="headerlink" title="第三套"></a>第三套</h2><p>设在SQL Server 2008某数据库中，已建立了四个文件组: fg1、fg2、fg3和fg4，以及一个分区函数RangePF1。RangePF1的定义代码如下:<br>CREATE PARTITION FUNCTION RangePF1(int)AS RANGE LEFT FOR VALUES(100,200,300)<br>(1)请基于RangePF1创建一个分区方案RangePS1，每个分区对应一个文件组。(5分)<br>(2）请使用RangePS1创建一个分区表PartitionT(Gid, GoodName, Price)，该表基于Gid列创建分区。其中Gid: int类型，取值大于等于1; GoodName:统一字符编码可变长类型，最多可存储20个汉字;Price:定点小数类型，小数部分1位，整数部分到千位。(5分)<br>[][创建分区方案 方案名 as 分区 函数名 to （文件组）]<br>[][CREATE TABLE tb_name （）on 方案名（Gid）]<br>1:<br>create partition scheme RangePS1<br>as partition RangePF1<br>to(fg1,fg2,fg3,fg4)<br>2:<br>create table orders<br>(<br>GID int identity(1,1) primary key,<br>GoodName varchar(40),<br>Price numeric(5,1)<br>)<br>on RangePS1(GID)</p>
<h2 id="第五套"><a href="#第五套" class="headerlink" title="第五套"></a>第五套</h2><p>设有图书管理数据库，包含三张表:图书明细表(图书编号，图书类别，图书名称，作者，出版社，出版日期，定价);读者表（借书证号，姓名，系别，办证日期);借出信息表（借出编号，借书证号，图书编号，借书日期);完成下列操作:(10分)定义一个多语句表值函数，用于查询学生借书情况，只需提供参数:借书证号，就可以通过调用函数返回此学生的借书情况，若有借书籍，则返回所借书籍的编号、书籍名称、定价和借书日期;若没有在借书籍，则返回记录为空。设函数名为: f_BorrowBook(@jszh char(20))。</p>
<p>CREATE FUNCTION f_BorrowBook(@jszh char(20))<br>RETURNS @jsqkb TABLE(书籍编号 char(20),书籍名称 char(50),定价 float,借书日期 datetime)<br>AS<br>BEGIN<br>INSERT INTO @jsqkb<br>SELECT图书明细表.图书编号,图书名称,定价,借出信息表.借书日期 FROM 借出信息表,图书明细表<br>WHERE 借出信息表.图书编号&#x3D;图书明细表.图书编号 AND 借出信息表.借书证号&#x3D;@jszh<br>RETURN<br>END</p>
<h2 id="第七套"><a href="#第七套" class="headerlink" title="第七套"></a>第七套</h2><p>BORROWER：<br>借书证号  姓名  系名  班级<br>12011106 张三 计算机 12-1<br>12011107 李四 计算机 12-1<br>12012113 王五 语文 12-2</p>
<p>LOANS??<br>借书证号  图书馆登记号  借书日期<br>12011106 T001001 2012.01.02<br>12012113 T001026 2013.02.06</p>
<p>BOOKS??<br>索书号 书名  作者 图书登记号 出版社 价格<br>TP311.1 数据库 李明 T001001 人民 19.00<br>TP311.2 二级C语言 王珊 T001026 科学 32.00<br>1.检索至少借了五本书的同学借书证号，姓名，系名，借书数量<br>2.检索借书和王五同学所借图书的任意一本相同的学牲姓名，系名，书名和借书日期<br>SELECT LOANS.借书证号,姓名,系名,COUNT(<em>) AS 借书数量<br>FROM BORROWER,LOANS<br>WHERE BORROWER.借书证号&#x3D;LOANS.借书证号<br>GROUP BY LOANS.借书证号,姓名,系名<br>HAVING COUNT(</em>)&gt;&#x3D;5;</p>
<p>SELECT 姓名,系名,书名,借书日期<br>FROM  BORROWER,LOANS , BOOKS<br>WHERE<br> BORROWER.借书证号&#x3D;LOANS.借书证号 AND LOANS.图书馆登记号&#x3D;BOOKS.图书馆登记号<br>AND 索书号 IN<br>(SELECT 索书号 FROM BORROWER,LOANS,BOOKS<br>WHERE BORROW.借书证号&#x3D;LOANS.借书证号<br>AND LOANS.图书馆登记号&#x3D;BOOKS.图书馆登记号<br>AND 姓名&#x3D;”王五”)<br>group by 姓名,系名,书名,借书日期<br>having 姓名 !&#x3D;’王五’</p>
<h2 id="塢-洢"><a href="#塢-洢" class="headerlink" title="??????????????????????????????????????塢?????????????????? ?洢????"></a>??????????????????????????????????????塢?????????????????? ?洢????</h2><p>CREATE TABLE 商品表(<br>商品号 char(10) PRIMARY KEY,<br>商品名 varchar(40),<br>类别 varchar(20),<br>进货单价 int,<br>销售总量 int default 0)<br>CREATE TABLE 销售表(<br>商品号 char(10) REFERENCES 商品表(商品号),<br>销售时间 datetime,<br>销售数量 int,<br>销售单价 int,<br>PRIMARY KEY(商品号,销售时间))<br>9.12.创建存储过程:指定类别的每种商品今年的销售总数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create proc p_name @lb varchar(20)</span><br><span class="line">as</span><br><span class="line">select 商品名, (select sum(销售数量) from 销售表 a </span><br><span class="line">where a.商品号=b.商品号 and year(销售时间)=year(getdate())) as 销售总数量</span><br><span class="line">from 商品表 b</span><br><span class="line">where b.类别=@lb</span><br></pre></td></tr></table></figure>
<p>8.11.创建存储过程:指定类别的每种商品今年的销售总金额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create proc p_name @lb varchar(20)</span><br><span class="line">as</span><br><span class="line">select 商品名, (select sum(销售数量*销售单价) from 销售表 a</span><br><span class="line">where a.商品号=b.商品号 and year(销售时间)=year(getdate())) as 销售总金额</span><br><span class="line">from 商品表 b</span><br><span class="line">where b.类别=@lb</span><br></pre></td></tr></table></figure>
<p>13.创建存储过程:指定类别的每种商品去年的销售总数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create proc p_name @lb varchar(20)</span><br><span class="line">as</span><br><span class="line">select a.商品号,商品名,sum(销售数量) as 销售总数量</span><br><span class="line">from 商品表 a join 销售表 b</span><br><span class="line">on a.商品号=b.商品号</span><br><span class="line">where year(销售时间)=year(dateadd(year,-1,getdate()))</span><br><span class="line">and 类别=@lb</span><br><span class="line">group by a.商品号,商品名</span><br></pre></td></tr></table></figure>
<p>17.创建存储过程:指定日期范围每种商品的销售总数量,包括未销售的商品.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create proc p1 @start_date date, @end_date date</span><br><span class="line">as</span><br><span class="line">select 商品表.商品号,sum(销售数量) from 商品表</span><br><span class="line">left join 销售表 on 商品表.商品号=销售表.商品号</span><br><span class="line">where 销售时间 between @start_date and @end_date</span><br><span class="line">group by 商品表.商品号</span><br></pre></td></tr></table></figure>
<p>19.创建存储过程:指定商品号的商品销售总数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create proc p1 @model varchar(10),@total int output</span><br><span class="line">as</span><br><span class="line">set @total=(select sum(销售数量) from 销售表 s </span><br><span class="line">join 商品表 c on s.商品号=c.商品号</span><br><span class="line">where 商品号=@model)</span><br></pre></td></tr></table></figure>
<p>14.创建存储过程:指定类别的每个商品的销售总利润,包括未销售的(值为0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create proc p_Profit @lb char(10)</span><br><span class="line">as</span><br><span class="line">select 商品表.商品号,</span><br><span class="line">case</span><br><span class="line">when 销售表.商品号 is null then 0</span><br><span class="line">else sum((销售单价-进货单价)*数量)</span><br><span class="line">end as 销售总利润</span><br><span class="line">from 商品表 left join 销售表 on 商品表.商品号=销售表.商品号</span><br><span class="line">where 类别=@lb</span><br><span class="line">group by 商品表.商品号</span><br></pre></td></tr></table></figure>
<p>16.标量函数:指定商品号返回销售总金额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create function dbo.f_TotalQty(@GoodID char)</span><br><span class="line">returns int</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">return(select sum(销售数量*销售单价)from 商品表 join 销售表</span><br><span class="line">on 商品表.商品号=销售表.商品号</span><br><span class="line">where 商品号=@GoodID)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>4.多语句表值函数: 返回类别参数的每种商品在2012年的销售总利润,并降序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create function f_Profit(@lb char(10))</span><br><span class="line">returns @ProfitTable table(商品号 char(10),总利润 int)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">insert into @ProfitTable</span><br><span class="line">select a.商品号,sum(销售数量*(销售单价-进货单价)) as 总利润</span><br><span class="line">from 销售表 a join 商品表 b on a.商品号=b.商品号</span><br><span class="line">where a.商品号 in(select 商品号 from 商品表 where 类别=@lb)</span><br><span class="line">group by a.商品号</span><br><span class="line">order by 总利润 desc</span><br><span class="line">return @ProfitTable</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>10.6.多语句表值函数：统计指定年份中每个商品的销售总额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create function fun_name(@year int)</span><br><span class="line">returns @fun_name table(商品号 char(10),销售总金额 int)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">insert into @fun_name</span><br><span class="line">select a.商品号,sum(a.销售单价*b.销售数量) from 商品表 a</span><br><span class="line">join 销售表 b on a.商品号=b.商品号</span><br><span class="line">where year(b.销售时间)=@year</span><br><span class="line">group by a.商品号</span><br><span class="line">return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>15.18.创建触发器:每当在销售表中插入一条销售记录, 修改商品表中对应商品的销售总量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create trigger tri_name on 销售表 for insert</span><br><span class="line">as</span><br><span class="line">update 商品表</span><br><span class="line">set 销售总量=商品表.销售总量+(select 销售数量 from inserted)</span><br><span class="line">where 商品号 in(select 商品号 from inserted)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create trigger tri_name on 销售表 after insert</span><br><span class="line">as</span><br><span class="line">declare @Sales_Amount int</span><br><span class="line">set @Sales_Amount=(select 销售数量 from inserted)</span><br><span class="line">update 商品表 set 销售总量=商品表.销售总量+@Sales_Amount</span><br><span class="line">where 商品号 in (select 商品号 from inserted)</span><br></pre></td></tr></table></figure>








<h2 id="第二十套"><a href="#第二十套" class="headerlink" title="第二十套"></a>第二十套</h2><p>CREATE TABLE 出租表(<br>房屋号 char(10),<br>出租日期 datetime,<br>租期 int not null, –月数<br>到期日期 datetime,<br>PRIMARY KEY(房屋号,出租日期));<br>创建触发器:每当在出租表插入一行数据(房屋号,出租日期,租期),自动计算到期日期<br>CREATE TRIGGER tri ON 出租表 FOR insert<br>AS<br>update 出租表 SET 到期日期 &#x3D; dateadd(month,租期,出租日期)<br>WHERE 房屋号 &#x3D; (SELECT 房屋号 FROM inserted )<br>and 出租日期&#x3D;(select 出租日期 from inserted)</p>
<h2 id="洢"><a href="#洢" class="headerlink" title="?????????????? ????????洢????"></a>?????????????? ????????洢????</h2><p>create table 房屋表(<br>房屋号 char(10) primary key,<br>房屋地址 char(20) not null,<br>面积 int,<br>月租金 int<br>)<br>create table 租贷表(<br>房屋号 char(10),<br>租贷日期 datetime,<br>租贷月数 int not null,<br>本次总租金 int,<br>primary key(房屋号,租贷日期),<br>foreign key(房屋号) references 房屋表(房屋号)<br>)<br>创建触发器:每当在租贷表插入一行数据（房屋号，租贷日期，租贷月数），计算本次月租金</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create trigger tri_name on 租贷表 for insert</span><br><span class="line">as</span><br><span class="line">declare @x int </span><br><span class="line">set @x=(select 月租金 from 房屋表 where 房屋号=</span><br><span class="line">(select 房屋号 from inserted))</span><br><span class="line">update 租贷表 set 本次月租金=租贷月数*@x</span><br><span class="line">from 租贷表 a join 房屋表 b on a.房屋号=b.房屋号</span><br><span class="line">and a.租贷日期=b.租贷日期</span><br></pre></td></tr></table></figure>
<p>创建存储过程：输入房屋号，计算历史租金总和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create proc p1 @room char(10),@total int output</span><br><span class="line">as</span><br><span class="line">set @total=(select sum(租贷月数*月租金) from 房屋表</span><br><span class="line">join 租贷表 on 房屋表.房屋号=租贷表.房屋号</span><br><span class="line">where a.房屋号=@room)</span><br></pre></td></tr></table></figure>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-18T11:08:39.099Z" itemprop="datePublished">2022-07-18</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/SqlServer第十二章  备份与恢复数据库" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver12/">『SQL Server』第十二章  备份与恢复数据库</a>
  

      </h3>
      <div class="repo-list-description">
        
          <h1 id="第十二章-备份与恢复数据库"><a href="#第十二章-备份与恢复数据库" class="headerlink" title="第十二章  备份与恢复数据库"></a>第十二章  备份与恢复数据库</h1><p>1.恢复数据库:类型:介质故障恢复<br>非介质故障恢复<br>模式:简单恢复模式<br>完整恢复模式<br>大容量日志恢复模式<br>2.备份数据库:数据库备份:完整数据库备份 钟情master,支持还原单个页,数据更改不频繁,量不大<br>                      差量数据库备份<br>           文件备份:文件备份<br>                   差异文件备份<br>           事务日志备份<br>完整数据库备份:完全转储:数据库+日志<br>              差量转储:<br>日志备份:纯日志备份：间隔一段时间的事务日志，不包含大容量日志 不可以first备份<br>           大容量操作日志备份，不可以进行时间点恢复<br>           结尾日志备份：出现故障时进行，防止丢失数据，可包含上两种<br>1.备份的T-SQL语句:backup database db_name to 设备 with init(覆盖原有内容)…事务日志备份则使用log<br>2.恢复的T-SQL语句:restore database db_name from 设备</p>
<p>简单恢复模式：无日志备份。<br>完整恢复模式：有日志备份<br>大容量日志恢复模式：有日志备份，完整恢复模式的附加模式</p>
<p>BACKUP DATABASE db1 TO budb1 WITH DIFFERENTIAL,NOINIT<br>对数据库db1进行依次差异备份，被分到budb1设备上，保留该设备已有内容</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-17T01:14:49.694Z" itemprop="datePublished">2022-07-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/SqlServer第九章  安全管理" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver09/">『SQL Server』第九章  安全管理</a>
  

      </h3>
      <div class="repo-list-description">
        
          <p>题1: 设 log1 是身份验证模式的数据库服务器登录账户，现在要授予该账户创建数据库的权限，请补全下列语句：<br>EXEC sp_addsrvrolemember ‘log1’, ‘____’<br>解析1:数据库主要的固定服务器级角色及权限如下表:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">bulkadmin</td>
<td align="center">执行 BULK INSERT 语句</td>
</tr>
<tr>
<td align="center">dbcreator</td>
<td align="center">创建修改删除和还原数据库对象√</td>
</tr>
<tr>
<td align="center">diskadmin</td>
<td align="center">管理磁盘文件</td>
</tr>
<tr>
<td align="center">processadmin</td>
<td align="center">管理运行的进程</td>
</tr>
<tr>
<td align="center">serveradmin</td>
<td align="center">配置服务器范围</td>
</tr>
<tr>
<td align="center">setupadmin</td>
<td align="center">增删链接服务器</td>
</tr>
<tr>
<td align="center">sysadmin</td>
<td align="center">系统管理员√</td>
</tr>
<tr>
<td align="center">securityadmin</td>
<td align="center">管理服务器登陆账户</td>
</tr>
</tbody></table>
<p>例2: 只具有修改数据库全部用户表数据权限的系统角色是____<br>解析2: 下表是服务器级角色</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">db_owner</td>
<td align="center">创建数据量对象; 配置,维护,删除数据库</td>
</tr>
<tr>
<td align="center">db_accessadmin</td>
<td align="center">增删用户</td>
</tr>
<tr>
<td align="center">db_backupoperator</td>
<td align="center">备份恢复数据库和日志</td>
</tr>
<tr>
<td align="center">db_datareader</td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center">db_datawriter</td>
<td align="center">增删改</td>
</tr>
<tr>
<td align="center">db_ddladmin</td>
<td align="center">执行数据定义语言(DDL)</td>
</tr>
<tr>
<td align="center">db_denydatareader</td>
<td align="center">不可读</td>
</tr>
<tr>
<td align="center">db_denydatawriter</td>
<td align="center">不可增删改</td>
</tr>
<tr>
<td align="center">db_securityadmin</td>
<td align="center">管理数据库角色,角色成员以及数据库中语句和对象的权限</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">默认角色</td>
</tr>
</tbody></table>
<p>对数据的访问是通过SQL server 的权限层次结构管理的.通过以下三种语句来管理这个权限层次结构.<br>用户 u1 在 数据库 db1 的查询表 t1 的权限, 此权限用户可以转授<br>GRANT SELETE ON db1(t1) TO u1 WITH GRANT OPTION<br>收回用户 u1 对表 t1 的数据更改权<br>REVOKE UPDATE ON t1 FROM|TO u1 CASCADE<br>拒绝用户 u1 对表 t1 的删除权限<br>DENY DELETE ON t1 TO u1</p>
<p>用户 u1 在数据库 db1 中有建表权限<br>GRANT CREATE TABLE ON db1 TO u1<br>收回用户 u1 对数据库 db1 的创建视图权限<br>REVOKE CREATE VIEW FROM u1<br>美国国防部对强制存取控制的分级为:验证保护,强制保护,自主保护,最小保护,分别为ABCD级别.<br>yqzz 有气质罪</p>
<p>DROP USER u1<br>CREATE LOGIN l1 WITH PASSWORD&#x3D;’a123’<br>DROP LOGIN l1<br>ALTER LOGIN u1 ENABLE</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-17T01:14:49.689Z" itemprop="datePublished">2022-07-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/SqlServer第二章  需求分析" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver02/">『SQL Server』第二章  需求分析</a>
  

      </h3>
      <div class="repo-list-description">
        
          <h1 id="第二章-需求分析"><a href="#第二章-需求分析" class="headerlink" title="第二章  需求分析"></a>第二章  需求分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="需求分析的概念与意义"><a href="#需求分析的概念与意义" class="headerlink" title="需求分析的概念与意义"></a>需求分析的概念与意义</h3><ul>
<li>概念:系统要”干什么”<h3 id="需求获取的方法"><a href="#需求获取的方法" class="headerlink" title="需求获取的方法"></a>需求获取的方法</h3><h3 id="需求分析过程"><a href="#需求分析过程" class="headerlink" title="需求分析过程"></a>需求分析过程</h3><h2 id="需求分析方法"><a href="#需求分析方法" class="headerlink" title="需求分析方法"></a>需求分析方法</h2></li>
<li>结构化分析与建模方法</li>
<li>面向对象分析与建模方法<h3 id="需求分析方法概述"><a href="#需求分析方法概述" class="headerlink" title="需求分析方法概述"></a>需求分析方法概述</h3><h3 id="DFD需求建模方法"><a href="#DFD需求建模方法" class="headerlink" title="DFD需求建模方法"></a>DFD需求建模方法</h3><h3 id="其他需求建模方法"><a href="#其他需求建模方法" class="headerlink" title="其他需求建模方法"></a>其他需求建模方法</h3><h3 id="DFD与IDEF-0比较"><a href="#DFD与IDEF-0比较" class="headerlink" title="DFD与IDEF-0比较"></a>DFD与IDEF-0比较</h3></li>
</ul>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-17T01:14:49.684Z" itemprop="datePublished">2022-07-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
                  <article id="post-过去半年前的学习部分/2021-2022年课程/202201SQL_Server/SqlServer第八章  数据库后台编程技术" class="repo-list">
    <div class="repo-list-item" >
      <h3 class="repo-list-name" itemprop="name">
        
  
      <a class="article-title" href="/posts/sqlserver08/">『SQL Server』第八章  数据库后台编程技术</a>
  

      </h3>
      <div class="repo-list-description">
        
          <h1 id="第八章-数据库后台编程技术"><a href="#第八章-数据库后台编程技术" class="headerlink" title="第八章  数据库后台编程技术"></a>第八章  数据库后台编程技术</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ol>
<li>创建:<code>create proc</code> proc_name<br>　 　@var type,@var1 type <code>output</code><br>　 　<code>as</code><br>　 　<code>begin</code><br>　 　sql_statement<br>　 　<code>end</code></li>
<li>执行:<code>exec</code> proc_name @var&#x3D;<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>分类:标量函数:<code>create function</code> fun_name<code>(</code>@var type<code>)</code><br>　　  　　    　　<code>returns</code> type<br>　　  　　    　　<code>as</code><br>　　  　　    　　<code>begin</code><br>　　  　　    　　sql_statement<br>　　  　　    　　<code>end</code><br>CREATE FUNCTION 表(@总价 char(10))<br>RETURNS INT AS<br>BEGIN<br>RETURN(SELECT…)<br>END<br>　 　表值函数:内嵌表值函数:<code>create function</code> fun_name<code>(</code>@var type<code>)</code><br>　　　　　　　　  　　 　   　<code>returns table</code><br>　　　　　　　　  　　 　   　<code>as</code><br>　　　　　　　　  　　 　   　<code>begin</code><br>　　　　　　　　  　　 　   　<code>return(</code>sql_statement<code>)</code><br>　　　　　　　　  　　 　   　<code>end</code><br>　　 　　 　多语句表值函数:<code>create function</code> fun_name<code>(</code>@var type<code>)</code><br>　　　　　　　　  　　 　   　<code>returns</code> @tb_name <code>table(</code>col_name<code>)</code><br>　　　　　　　　  　　 　   　<code>as</code><br>　　　　　　　　  　　 　   　<code>begin</code><br>　　　　　　　　  　　 　   　sql_statement<br>　　　　　　　　  　　 　   　<code>return</code><br>　　　　　　　　  　　 　   　<code>end</code><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2></li>
</ol>
</li>
<li>创建:<code>create trigger</code> tri_name<br><code>on</code> tb_name<br><code>&#123;for | instead of&#125;</code> <code>&#123;insert | update | delete&#125;</code><br><code>as</code><br><code>begin</code><br>sql_statement<br><code>end</code></li>
</ol>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><ol>
<li>声明:<code>declare</code> cur_name <code>cursor</code><br> 　   　<code>for</code> sql_statement</li>
<li>打开:<code>open</code> cur_name</li>
<li>提取:<code>fetch</code> <code>first | last | next | prior | absolute n | relative n</code><br><code>from</code> cur_name into 变量名</li>
<li>关闭:<code>close</code> cur_name</li>
<li>释放:<code>deallocate</code> cur_name</li>
<li>全局变量:@@fetch_status</li>
</ol>
<p>create proc p1…<br>调用:exec p1 default,20</p>

        
      </div>
      <p class="repo-list-meta">
        <span class="meta-info">
          <span class="octicon octicon-calendar"></span>
           <time datetime="2022-07-17T01:14:49.678Z" itemprop="datePublished">2022-07-17</time>
        </span>

        
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href='/categories/SqlServer/' title=''>SqlServer</a>
          </span>
        
      
        <!--
          
        -->

      </p>
    </div>
  </article>
            
        </div>
        <div class="column one-third">
          <!--处理未安装 search 插件 默认 Google 搜索-->
 

<h3>Search</h3>

<div id="site_search">

	<!-- Google -->
	
		<form action="http://www.google.com/search?" data-site="">
	    	<input type="text" id="search_box" name="q" placeholder="Search">
	    	<button type="button" class="btn btn-default" id="site_search_do"><span class="octicon octicon-search"></span></button>
	    </form>
	

	<!-- 本地搜索 -->
	

</div>

<h3>Popular Repositories</h3>
    <div class="popular-container"></div>
    
    <script type="text/template" id="popular-list-template">
        <a href="{%=clone_url%}" class="card text-center" target="_blank">
            <div class="thumbnail">
                <div class="card-image geopattern" data-pattern-id="{%=name%}">
                    <div class="card-image-cell">
                        <h3 class="card-title">
                            {%=name%}
                        </h3>
                    </div>
                </div>
                <div class="caption">
                    <div class="card-description">
                        <p class="card-text">
                            {%=description%}
                        </p>
                    </div>
                    <div class="card-text">
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=stargazers_count%} stars">
                            <span class="octicon octicon-star"></span> {%=stargazers_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="{%=forks_count%} forks">
                            <span class="octicon octicon-git-branch"></span> {%=forks_count%}
                        </span>
                        <span class="meta-info tooltipped tooltipped-n" aria-label="最后更新时间：{%=updated_at%}">
                            <span class="octicon octicon-clock"></span>
                            <time datetime="{%=updated_at%}">{%=updated_at%}</time>
                        </span>
                    </div>
                </div>
            </div>
        </a>
    </script>

    
<script src="/js/baiduTemplate.js"></script>

    <script type="text/javascript">
        var popular_repos = function(){

            var baiduTpl = new Object();

            var handleTpl = function(){
                baiduTpl.popular_list = baidu.template("popular-list-template");
            };

            var handleGithub = function(){
                var popularContainer = $(".popular-container");

                var repos = "hexo-theme-primer".split(",");
                for(var i in repos){
                    var name = repos[i];
                    $.get("https://api.github.com/repos/yumemor/"+name,handle);
                }

                function handle(result){
                    result.updated_at = result.updated_at.split("T")[0];
                    if(result){
                        var html = baiduTpl.popular_list(result);
                        popularContainer.append(html);
                        $(".geopattern").each(function(){           
                            $(this).geopattern($(this).data('pattern-id'));
                        });
                    }
                }
            };

            return {
                init:function(){
                    handleTpl();
                    handleGithub();
                }
            }
        }; 
        $(popular_repos().init);
    </script>

        </div>
    </div>

    
      <div class="pagination text-align">
          <div class="btn-group">
              <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">&amp;raquo;</a>
          </div>
      </div>
    
</section>

<footer class="container">
    <div class="site-footer" role="contentinfo">
        <div class="copyright left mobile-block">
                © 2016
                <span title="yumemor">yumemor</span>
                <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
        </div>

        <ul class="site-footer-links right mobile-hidden">
            <li>
                <a href="javascript:window.scrollTo(0,0)" >TOP</a>
            </li>
        </ul>

        <a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" aria-label="view source code">
            <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
        </a>

        <ul class="site-footer-links mobile-hidden">
            
                  
                  <li>
                    <a href="/"  title="Home">Home</a>
                  </li>
            
                  
                  <li>
                    <a href="/categories/"  title="Category">Category</a>
                  </li>
            
                  
                  <li>
                    <a href="/open-source/"  title="Open-Source">Open-Source</a>
                  </li>
            
                  
                  <li>
                    <a href="/message/"  title="Message">Message</a>
                  </li>
            
            <li>
                <a href="/atom.xml">
                    <span class="octicon octicon-rss" style="color:orange;"></span>
                </a>
            </li>
        </ul>
    </div>
</footer>

		
<script src="/js/geopattern.js"></script>

		
<script src="/js/highlight.pack.js"></script>

		
<script src="/lib/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


		

		
<script src="/js/index.js"></script>


		 
<script src="/js/popular_repo.js"></script>
 

	</body>
</html>